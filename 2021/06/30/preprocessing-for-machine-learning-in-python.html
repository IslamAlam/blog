<h1 id="preprocessing-for-machine-learning-in-python">Preprocessing for Machine Learning in Python</h1>

<h2 id="preprocessing-for-machine-learning-in-python-1">Preprocessing for Machine Learning in Python</h2>

<p>This is the memo of the 8th course (23 courses in all) of ‘Machine Learning Scientist with Python’ skill track.<br />
<strong>You can find the original course</strong> <a href="https://www.datacamp.com/courses/preprocessing-for-machine-learning-in-python"><strong>HERE</strong></a>.</p>

<p><strong>Course Description</strong></p>

<p>This course covers the basics of how and when to perform data preprocessing. This essential step in any machine learning project is when you get your data ready for modeling. Between importing and cleaning your data and fitting your machine learning model is when preprocessing comes into play. You’ll learn how to standardize your data so that it’s in the right form for your model, create new features to best leverage the information in your dataset, and select the best features to improve your model fit. Finally, you’ll have some practice preprocessing by getting a dataset on UFO sightings ready for modeling.</p>

<p><strong>Table of contents</strong></p>

<ol>
  <li>Introduction to Data Preprocessing</li>
  <li><a href="https://datascience103579984.wordpress.com/2019/12/23/preprocessing-for-machine-learning-in-python-from-datacamp/2/">Standardizing Data</a></li>
  <li><a href="https://datascience103579984.wordpress.com/2019/12/23/preprocessing-for-machine-learning-in-python-from-datacamp/3/">Feature Engineering</a></li>
  <li><a href="https://datascience103579984.wordpress.com/2019/12/23/preprocessing-for-machine-learning-in-python-from-datacamp/4/">Selecting features for modeling</a></li>
  <li><a href="https://datascience103579984.wordpress.com/2019/12/23/preprocessing-for-machine-learning-in-python-from-datacamp/5/">Putting it all together</a></li>
</ol>

<h4 id="1-introduction-to-data-preprocessing"><strong>1. Introduction to Data Preprocessing</strong></h4>

<p><strong>1.1 What is data preprocessing?</strong></p>

<p><img src="https://datascience103579984.files.wordpress.com/2019/12/1-11.png?w=835" alt="" /></p>

<p><strong>1.1.1 Missing data – columns</strong></p>

<p>We have a dataset comprised of volunteer information from New York City. The dataset has a number of features, but we want to get rid of features that have at least 3 missing values.</p>

<p>How many features are in the original dataset, and how many features are in the set after columns with at least 3 missing values are removed?</p>

<p>`volunteer.shape</p>

<h2 id="665-35">(665, 35)</h2>

<p>volunteer.dropna(axis=1,thresh=3).shape</p>

<h2 id="665-24">(665, 24)`</h2>

<p><strong>1.1.2 Missing data – rows</strong></p>

<p>Taking a look at the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset again, we want to drop rows where the <code class="language-plaintext highlighter-rouge">category_desc</code> column values are missing. We’re going to do this using boolean indexing, by checking to see if we have any null values, and then filtering the dataset so that we only have rows with those values.</p>

<p>`# Check how many values are missing in the category_desc column</p>

<p>print(volunteer[‘category_desc’].isnull().sum())</p>

<h2 id="48">48</h2>

<h2 id="subset-the-volunteer-dataset">Subset the volunteer dataset</h2>

<p>volunteer_subset = volunteer[volunteer[‘category_desc’].notnull()]</p>

<h2 id="print-out-the-shape-of-the-subset">Print out the shape of the subset</h2>

<p>print(volunteer_subset.shape)</p>

<h2 id="617-35">(617, 35)`</h2>

<p><strong>1.2 Working with data types</strong></p>

<p><img src="https://datascience103579984.files.wordpress.com/2019/12/2-12.png?w=975" alt="" /></p>

<p><strong>1.2.1 Exploring data types</strong></p>

<p>Taking another look at the dataset comprised of volunteer information from New York City, we want to know what types we’ll be working with as we start to do more preprocessing.</p>

<p>Which data types are present in the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset?</p>

<p><code class="language-plaintext highlighter-rouge">set(volunteer.dtypes.values) {dtype('int64'), dtype('float64'), dtype('O')}</code></p>

<p><strong>1.2.2 Converting a column type</strong></p>

<p>If you take a look at the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset types, you’ll see that the column <code class="language-plaintext highlighter-rouge">hits</code> is type <code class="language-plaintext highlighter-rouge">object</code>. But, if you actually look at the column, you’ll see that it consists of integers. Let’s convert that column to type <code class="language-plaintext highlighter-rouge">int</code>.</p>

<p>`volunteer[“hits”].dtype</p>

<h2 id="dtypeo">dtype(‘O’)</h2>

<h2 id="convert-the-hits-column-to-type-int">Convert the hits column to type int</h2>

<p>volunteer[“hits”] = volunteer[“hits”].astype(‘int’)</p>

<p>volunteer[“hits”].dtype</p>

<h2 id="dtypeint64">dtype(‘int64’)`</h2>

<p><strong>1.3 Class distribution</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/3-12.png?w=996" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/4-12.png?w=980" alt="" /></li>
</ul>

<p><strong>1.3.1 Class imbalance</strong></p>

<p>In the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset, we’re thinking about trying to predict the <code class="language-plaintext highlighter-rouge">category_desc</code> variable using the other features in the dataset. First, though, we need to know what the class distribution (and imbalance) is for that label.</p>

<p>Which descriptions occur less than 50 times in the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset?</p>

<p><code class="language-plaintext highlighter-rouge">volunteer.category_desc.value_counts() Strengthening Communities 307 Helping Neighbors in Need 119 Education 92 Health 52 Environment 32 Emergency Preparedness 15 Name: category_desc, dtype: int64</code></p>

<p><strong>1.3.2 Stratified sampling</strong></p>

<p>We know that the distribution of variables in the <code class="language-plaintext highlighter-rouge">category_desc</code> column in the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset is uneven. If we wanted to train a model to try to predict <code class="language-plaintext highlighter-rouge">category_desc</code>, we would want to train the model on a sample of data that is representative of the entire dataset. Stratified sampling is a way to achieve this.</p>

<p>`# Create a data with all columns except category_desc</p>

<p>volunteer_X = volunteer.drop(‘category_desc’, axis=1)</p>

<h2 id="create-a-category_desc-labels-dataset">Create a category_desc labels dataset</h2>

<p>volunteer_y = volunteer[[‘category_desc’]]</p>

<h2 id="use-stratified-sampling-to-split-up-the-dataset-according-to-the-volunteer_y-dataset">Use stratified sampling to split up the dataset according to the volunteer_y dataset</h2>

<p>X_train, X_test, y_train, y_test = train_test_split(volunteer_X, volunteer_y, stratify=volunteer_y)</p>

<h2 id="print-out-the-category_desc-counts-on-the-training-y-labels">Print out the category_desc counts on the training y labels</h2>

<p>print(y_train[‘category_desc’].value_counts())`</p>

<p><code class="language-plaintext highlighter-rouge">Strengthening Communities 230 Helping Neighbors in Need 89 Education 69 Health 39 Environment 24 Emergency Preparedness 11 Name: category_desc, dtype: int64</code></p>

<p>``</p>

<p>``</p>

<h4 id="2-standardizing-data"><strong>2. Standardizing Data</strong></h4>

<p><strong>2.1 Standardizing Data</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/5-12.png?w=813" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/6-12.png?w=863" alt="" /></li>
</ul>

<p><strong>2.1.1 When to standardize</strong></p>

<ul>
  <li>A column you want to use for modeling has extremely high variance.</li>
  <li>You have a dataset with several continuous columns on different scales and you’d like to use a linear model to train the data.</li>
  <li>The models you’re working with use some sort of distance metric in a linear space, like the Euclidean metric.</li>
</ul>

<p><strong>2.1.2 Modeling without normalizing</strong></p>

<p>Let’s take a look at what might happen to your model’s accuracy if you try to model data without doing some sort of standardization first. Here we have a subset of the <code class="language-plaintext highlighter-rouge">wine</code> dataset. One of the columns, <code class="language-plaintext highlighter-rouge">Proline</code>, has an extremely high variance compared to the other columns. This is an example of where a technique like log normalization would come in handy, which you’ll learn about in the next section.</p>

<p>| 123456789 | &lt;p&gt;<code># Split the dataset and labels into training and test sets</code><br />&lt;/p&gt;&lt;p&gt;<code>X_train, X_test, y_train, y_test = train_test_split(X, y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Fit the k-nearest neighbors model to the training data</code><br />&lt;/p&gt;&lt;p&gt;<code>knn.fit(X_train,y_train)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Score the model on the test data</code><br />&lt;/p&gt;&lt;p&gt;<code>print(knn.score(X_test,y_test))</code><br />&lt;/p&gt;&lt;p&gt;<code># 0.5333333333333333</code>&lt;/p&gt; |
| ——— | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p><strong>2.2 Log normalization</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/7-12.png?w=789" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/8-11.png?w=996" alt="" /></li>
</ul>

<p><strong>2.2.1 Checking the variance</strong></p>

<p>Check the variance of the columns in the <code class="language-plaintext highlighter-rouge">wine</code> dataset. Which column is a candidate for normalization?</p>

<p>| 12345678910111213141516 | &lt;p&gt;<code>wine.var()</code><br />&lt;/p&gt;&lt;p&gt;<code>Type 0.600679</code><br />&lt;/p&gt;&lt;p&gt;<code>Alcohol 0.659062</code><br />&lt;/p&gt;&lt;p&gt;<code>Malic acid 1.248015</code><br />&lt;/p&gt;&lt;p&gt;<code>Ash 0.075265</code><br />&lt;/p&gt;&lt;p&gt;<code>Alcalinity of ash 11.152686</code><br />&lt;/p&gt;&lt;p&gt;<code>Magnesium 203.989335</code><br />&lt;/p&gt;&lt;p&gt;<code>Total phenols 0.391690</code><br />&lt;/p&gt;&lt;p&gt;<code>Flavanoids 0.997719</code><br />&lt;/p&gt;&lt;p&gt;<code>Nonflavanoid phenols 0.015489</code><br />&lt;/p&gt;&lt;p&gt;<code>Proanthocyanins 0.327595</code><br />&lt;/p&gt;&lt;p&gt;<code>Color intensity 5.374449</code><br />&lt;/p&gt;&lt;p&gt;<code>Hue 0.052245</code><br />&lt;/p&gt;&lt;p&gt;<code>OD280/OD315 of diluted wines 0.504086</code><br />&lt;/p&gt;&lt;p&gt;<code>Proline 99166.717355</code><br />&lt;/p&gt;&lt;p&gt;<code>dtype: float64</code>&lt;/p&gt; |
| ———————– | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– |</p>

<p><strong>Proline 99166.717355</strong></p>

<p><strong>2.2.2 Log normalization in Python</strong></p>

<p>Now that we know that the <code class="language-plaintext highlighter-rouge">Proline</code> column in our wine dataset has a large amount of variance, let’s log normalize it.</p>

<p>| 12345678910 | &lt;p&gt;<code># Print out the variance of the Proline column</code><br />&lt;/p&gt;&lt;p&gt;<code>print(wine.Proline.var())</code><br />&lt;/p&gt;&lt;p&gt;<code># 99166.71735542436</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Apply the log normalization function to the Proline column</code><br />&lt;/p&gt;&lt;p&gt;<code>wine['Proline_log'] = np.log(wine.Proline)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Check the variance of the Proline column again</code><br />&lt;/p&gt;&lt;p&gt;<code>print(wine.Proline_log.var())</code><br />&lt;/p&gt;&lt;p&gt;<code># 0.17231366191842012</code><br />&lt;/p&gt;&lt;p&gt;&#x3C;code&gt;&#x3C;/code&gt;&lt;/p&gt; |
| ———– | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>2.3 Scaling data for feature comparison</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/9-11.png?w=852" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/10-11.png?w=559" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/11-10.png?w=750" alt="" /></li>
</ul>

<p><strong>2.3.1 Scaling data – investigating columns</strong></p>

<p>We want to use the <code class="language-plaintext highlighter-rouge">Ash</code>, <code class="language-plaintext highlighter-rouge">Alcalinity of ash</code>, and <code class="language-plaintext highlighter-rouge">Magnesium</code> columns in the wine dataset to train a linear model, but it’s possible that these columns are all measured in different ways, which would bias a linear model.</p>

<p>| 12345678910 | &lt;p&gt;<code>wine[['Ash','Alcalinity of ash','Magnesium']].describe()</code><br />&lt;/p&gt;&lt;p&gt;<code>Ash Alcalinity of ash Magnesium</code><br />&lt;/p&gt;&lt;p&gt;<code>count 178.000000 178.000000 178.000000</code><br />&lt;/p&gt;&lt;p&gt;<code>mean 2.366517 19.494944 99.741573</code><br />&lt;/p&gt;&lt;p&gt;<code>std 0.274344 3.339564 14.282484</code><br />&lt;/p&gt;&lt;p&gt;<code>min 1.360000 10.600000 70.000000</code><br />&lt;/p&gt;&lt;p&gt;<code>25% 2.210000 17.200000 88.000000</code><br />&lt;/p&gt;&lt;p&gt;<code>50% 2.360000 19.500000 98.000000</code><br />&lt;/p&gt;&lt;p&gt;<code>75% 2.557500 21.500000 107.000000</code><br />&lt;/p&gt;&lt;p&gt;<code>max 3.230000 30.000000 162.000000</code>&lt;/p&gt; |
| ———– | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– |</p>

<p><strong>2.3.2 Scaling data – standardizing columns</strong></p>

<p>Since we know that the <code class="language-plaintext highlighter-rouge">Ash</code>, <code class="language-plaintext highlighter-rouge">Alcalinity of ash</code>, and <code class="language-plaintext highlighter-rouge">Magnesium</code> columns in the wine dataset are all on different scales, let’s standardize them in a way that allows for use in a linear model.</p>

<p>| 1234567891011 | &lt;p&gt;<code># Import StandardScaler from scikit-learn</code><br />&lt;/p&gt;&lt;p&gt;<code>from sklearn.preprocessing import StandardScaler</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Create the scaler</code><br />&lt;/p&gt;&lt;p&gt;<code>ss = StandardScaler()</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Take a subset of the DataFrame you want to scale</code><br />&lt;/p&gt;&lt;p&gt;<code>wine_subset = wine[['Ash','Alcalinity of ash','Magnesium']]</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Apply the scaler to the DataFrame subset</code><br />&lt;/p&gt;&lt;p&gt;<code>wine_subset_scaled = ss.fit_transform(wine_subset)</code>&lt;/p&gt; |
| ————- | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– |</p>

<p>| 123456 | &lt;p&gt;<code>wine_subset_scaled[:5]</code><br />&lt;/p&gt;&lt;p&gt;<code>array([[ 0.23205254, -1.16959318, 1.91390522],</code><br />&lt;/p&gt;&lt;p&gt;<code>[-0.82799632, -2.49084714, 0.01814502],</code><br />&lt;/p&gt;&lt;p&gt;<code>[ 1.10933436, -0.2687382 , 0.08835836],</code><br />&lt;/p&gt;&lt;p&gt;<code>[ 0.4879264 , -0.80925118, 0.93091845],</code><br />&lt;/p&gt;&lt;p&gt;<code>[ 1.84040254, 0.45194578, 1.28198515]])</code>&lt;/p&gt; |
| —— | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p><strong>2.4 Standardized data and modeling</strong></p>

<p><strong>2.4.1 KNN on non-scaled data</strong></p>

<p>Let’s first take a look at the accuracy of a K-nearest neighbors model on the <code class="language-plaintext highlighter-rouge">wine</code> dataset without standardizing the data.</p>

<p>| 123456789 | &lt;p&gt;<code># Split the dataset and labels into training and test sets</code><br />&lt;/p&gt;&lt;p&gt;<code>X_train, X_test, y_train, y_test = train_test_split(X,y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Fit the k-nearest neighbors model to the training data</code><br />&lt;/p&gt;&lt;p&gt;<code>knn.fit(X_train, y_train)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Score the model on the test data</code><br />&lt;/p&gt;&lt;p&gt;<code>print(knn.score(X_test, y_test))</code><br />&lt;/p&gt;&lt;p&gt;<code># 0.6444444444444445</code>&lt;/p&gt; |
| ——— | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– |</p>

<p><strong>2.4.2 KNN on scaled data</strong></p>

<p>The accuracy score on the unscaled <code class="language-plaintext highlighter-rouge">wine</code> dataset was decent, but we can likely do better if we scale the dataset. The process is mostly the same as the previous exercise, with the added step of scaling the data.</p>

<table>
  <thead>
    <tr>
      <th>12345678910111213</th>
      <th>&lt;p&gt;<code># Create the scaling method.</code><br />&lt;/p&gt;&lt;p&gt;<code>ss = StandardScaler()</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Apply the scaling method to the dataset used for modeling.</code><br />&lt;/p&gt;&lt;p&gt;<code>X_scaled = ss.fit_transform(X)</code><br />&lt;/p&gt;&lt;p&gt;<code>X_train, X_test, y_train, y_test = train_test_split(X_scaled, y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Fit the k-nearest neighbors model to the training data.</code><br />&lt;/p&gt;&lt;p&gt;<code>knn.fit(X_train,y_train)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Score the model on the test data.</code><br />&lt;/p&gt;&lt;p&gt;<code>print(knn.score(X_test,y_test))</code><br />&lt;/p&gt;&lt;p&gt;<code># 0.9555555555555556</code>&lt;/p&gt;</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h4 id="3-feature-engineering"><strong>3. Feature Engineering</strong></h4>

<p><strong>3.1 Feature engineering</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/12-11.png?w=862" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/13-10.png?w=895" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/14-8.png?w=880" alt="" /></li>
</ul>

<p><strong>3.1.1 Examples for creating new features</strong></p>

<ul>
  <li>timestamps</li>
  <li>newspaper headlines</li>
</ul>

<p>Timestamps can be broken into days or months, and headlines can be used for natural language processing.</p>

<p><strong>3.1.2 Identifying areas for feature engineering</strong></p>

<p>| 123 | &lt;p&gt;<code>volunteer[['title','created_date','category_desc']].head(1)</code><br />&lt;/p&gt;&lt;p&gt;<code>title created_date category_desc</code><br />&lt;/p&gt;&lt;p&gt;<code>0 Volunteers Needed For Rise Up &#x26; Stay Put! Home... January 13 2011 Strengthening Communities</code>&lt;/p&gt; |
| — | —————————————————————————————————————————————————————————————————————————————————————– |</p>

<p>All of these columns will require some feature engineering before modeling.</p>

<p><strong>3.2 Encoding categorical variables</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/18-5.png?w=1024" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/15-8.png?w=1024" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/16-6.png?w=756" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/17-4.png?w=669" alt="" /></li>
</ul>

<p><strong>3.2.1 Encoding categorical variables – binary</strong></p>

<p>Take a look at the <code class="language-plaintext highlighter-rouge">hiking</code> dataset. There are several columns here that need encoding, one of which is the <code class="language-plaintext highlighter-rouge">Accessible</code> column, which needs to be encoded in order to be modeled. <code class="language-plaintext highlighter-rouge">Accessible</code> is a binary feature, so it has two values – either <code class="language-plaintext highlighter-rouge">Y</code> or <code class="language-plaintext highlighter-rouge">N</code> – so it needs to be encoded into 1s and 0s. Use scikit-learn’s <code class="language-plaintext highlighter-rouge">LabelEncoder</code> method to do that transformation.</p>

<p>| 12345678 | &lt;p&gt;<code># Set up the LabelEncoder object</code><br />&lt;/p&gt;&lt;p&gt;<code>enc = LabelEncoder()</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Apply the encoding to the "Accessible" column</code><br />&lt;/p&gt;&lt;p&gt;<code>hiking['Accessible_enc'] = enc.fit_transform(hiking.Accessible)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Compare the two columns</code><br />&lt;/p&gt;&lt;p&gt;<code>print(hiking[['Accessible', 'Accessible_enc']].head())</code>&lt;/p&gt; |
| ——– | ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p>| 123456 | &lt;p&gt;<code>Accessible Accessible_enc</code><br />&lt;/p&gt;&lt;p&gt;<code>0 Y 1</code><br />&lt;/p&gt;&lt;p&gt;<code>1 N 0</code><br />&lt;/p&gt;&lt;p&gt;<code>2 N 0</code><br />&lt;/p&gt;&lt;p&gt;<code>3 N 0</code><br />&lt;/p&gt;&lt;p&gt;<code>4 N 0</code>&lt;/p&gt; |
| —— | ———————————————————————————————————————————————————————————————- |</p>

<p><strong>3.2.2 Encoding categorical variables – one-hot</strong></p>

<p>One of the columns in the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset, <code class="language-plaintext highlighter-rouge">category_desc</code>, gives category descriptions for the volunteer opportunities listed. Because it is a categorical variable with more than two categories, we need to use one-hot encoding to transform this column numerically.</p>

<p>| 12345 | &lt;p&gt;<code># Transform the category_desc column</code><br />&lt;/p&gt;&lt;p&gt;<code>category_enc = pd.get_dummies(volunteer["category_desc"])</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Take a look at the encoded columns</code><br />&lt;/p&gt;&lt;p&gt;<code>print(category_enc.head())</code>&lt;/p&gt; |
| —– | —————————————————————————————————————————————————————————————————————————————————————— |</p>

<p>| 12345678 | &lt;p&gt;<code>Education Emergency Preparedness ... Helping Neighbors in Need Strengthening Communities</code><br />&lt;/p&gt;&lt;p&gt;<code>0 0 0 ... 0 0</code><br />&lt;/p&gt;&lt;p&gt;<code>1 0 0 ... 0 1</code><br />&lt;/p&gt;&lt;p&gt;<code>2 0 0 ... 0 1</code><br />&lt;/p&gt;&lt;p&gt;<code>3 0 0 ... 0 1</code><br />&lt;/p&gt;&lt;p&gt;<code>4 0 0 ... 0 0</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code>[5 rows x 6 columns]</code>&lt;/p&gt; |
| ——– | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>3.3 Engineering numerical features</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/19-5.png?w=856" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/20-5.png?w=1009" alt="" /></li>
</ul>

<p><strong>3.3.1 Engineering numerical features – taking an average</strong></p>

<p>A good use case for taking an aggregate statistic to create a new feature is to take the mean of columns. Here, you have a DataFrame of running times named <code class="language-plaintext highlighter-rouge">running_times_5k</code>. For each <code class="language-plaintext highlighter-rouge">name</code> in the dataset, take the mean of their 5 run times.</p>

<p>| 123456789 | &lt;p&gt;<code># Create a list of the columns to average</code><br />&lt;/p&gt;&lt;p&gt;<code>run_columns = ['run1', 'run2', 'run3', 'run4', 'run5']</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Use apply to create a mean column</code><br />&lt;/p&gt;&lt;p&gt;<code># axis=1 = row wise</code><br />&lt;/p&gt;&lt;p&gt;<code>running_times_5k["mean"] = running_times_5k.apply(lambda row: row[run_columns].mean(), axis=1)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Take a look at the results</code><br />&lt;/p&gt;&lt;p&gt;<code>print(running_times_5k)</code>&lt;/p&gt; |
| ——— | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p>| 1234567 | &lt;p&gt;<code>name run1 run2 run3 run4 run5 mean</code><br />&lt;/p&gt;&lt;p&gt;<code>0 Sue 20.1 18.5 19.6 20.3 18.3 19.36</code><br />&lt;/p&gt;&lt;p&gt;<code>1 Mark 16.5 17.1 16.9 17.6 17.3 17.08</code><br />&lt;/p&gt;&lt;p&gt;<code>2 Sean 23.5 25.1 25.2 24.6 23.9 24.46</code><br />&lt;/p&gt;&lt;p&gt;<code>3 Erin 21.7 21.1 20.9 22.1 22.2 21.60</code><br />&lt;/p&gt;&lt;p&gt;<code>4 Jenny 25.8 27.1 26.1 26.7 26.9 26.52</code><br />&lt;/p&gt;&lt;p&gt;<code>5 Russell 30.9 29.6 31.4 30.4 29.9 30.44</code>&lt;/p&gt; |
| ——- | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>3.3.2 Engineering numerical features – datetime</strong></p>

<p>There are several columns in the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset comprised of datetimes. Let’s take a look at the <code class="language-plaintext highlighter-rouge">start_date_date</code> column and extract just the month to use as a feature for modeling.</p>

<p>| 12345678 | &lt;p&gt;<code># First, convert string column to date column</code><br />&lt;/p&gt;&lt;p&gt;<code>volunteer["start_date_converted"] = pd.to_datetime(volunteer["start_date_date"])</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Extract just the month from the converted column</code><br />&lt;/p&gt;&lt;p&gt;<code>volunteer["start_date_month"] = volunteer["start_date_converted"].apply(lambda row: row.month)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Take a look at the converted and new month columns</code><br />&lt;/p&gt;&lt;p&gt;<code>print(volunteer[['start_date_converted', 'start_date_month']].head())</code>&lt;/p&gt; |
| ——– | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p>| 123456 | &lt;p&gt;<code>start_date_converted start_date_month</code><br />&lt;/p&gt;&lt;p&gt;<code>0 2011-07-30 7</code><br />&lt;/p&gt;&lt;p&gt;<code>1 2011-02-01 2</code><br />&lt;/p&gt;&lt;p&gt;<code>2 2011-01-29 1</code><br />&lt;/p&gt;&lt;p&gt;<code>3 2011-02-14 2</code><br />&lt;/p&gt;&lt;p&gt;<code>4 2011-02-05 2</code>&lt;/p&gt; |
| —— | ——————————————————————————————————————————————————————————————————————————————————- |</p>

<p><strong>3.4 Text classification</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/21-5.png?w=662" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/24-5.png?w=540" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/22-5.png?w=1005" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/23-5.png?w=718" alt="" /></li>
</ul>

<p><strong>3.4.1 Engineering features from strings – extraction</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">Length</code> column in the <code class="language-plaintext highlighter-rouge">hiking</code> dataset is a column of strings, but contained in the column is the mileage for the hike. We’re going to extract this mileage using regular expressions, and then use a lambda in Pandas to apply the extraction to the DataFrame.</p>

<p>| 1234567891011121314 | &lt;p&gt;<code># Write a pattern to extract numbers and decimals</code><br />&lt;/p&gt;&lt;p&gt;<code>def return_mileage(length):</code><br />&lt;/p&gt;&lt;p&gt;<code>pattern = re.compile(r"\d+\.\d+")</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Search the text for matches</code><br />&lt;/p&gt;&lt;p&gt;<code>mile = re.match(pattern, length)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># If a value is returned, use group(0) to return the found value</code><br />&lt;/p&gt;&lt;p&gt;<code>if mile is not None:</code><br />&lt;/p&gt;&lt;p&gt;<code>return float(mile.group(0))</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Apply the function to the Length column and take a look at both columns</code><br />&lt;/p&gt;&lt;p&gt;<code>hiking["Length_num"] = hiking['Length'].apply(lambda row: return_mileage(row))</code><br />&lt;/p&gt;&lt;p&gt;<code>print(hiking[["Length", "Length_num"]].head())</code>&lt;/p&gt; |
| ——————- | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p>| 123456 | &lt;p&gt;<code>Length Length_num</code><br />&lt;/p&gt;&lt;p&gt;<code>0 0.8 miles 0.80</code><br />&lt;/p&gt;&lt;p&gt;<code>1 1.0 mile 1.00</code><br />&lt;/p&gt;&lt;p&gt;<code>2 0.75 miles 0.75</code><br />&lt;/p&gt;&lt;p&gt;<code>3 0.5 miles 0.50</code><br />&lt;/p&gt;&lt;p&gt;<code>4 0.5 miles 0.50</code>&lt;/p&gt; |
| —— | ——————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>3.4.2 Engineering features from strings – tf/idf</strong></p>

<p>Let’s transform the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset’s <code class="language-plaintext highlighter-rouge">title</code> column into a text vector, to use in a prediction task in the next exercise.</p>

<p>| 12345678 | &lt;p&gt;<code># Take the title text</code><br />&lt;/p&gt;&lt;p&gt;<code>title_text = volunteer['title']</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Create the vectorizer method</code><br />&lt;/p&gt;&lt;p&gt;<code>tfidf_vec = TfidfVectorizer()</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Transform the text into tf-idf vectors</code><br />&lt;/p&gt;&lt;p&gt;<code>text_tfidf = tfidf_vec.fit_transform(title_text)</code>&lt;/p&gt; |
| ——– | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p>| 123 | &lt;p&gt;<code>text_tfidf</code><br />&lt;/p&gt;&lt;p&gt;<code>&#x3C;665x1136 sparse matrix of type '&#x3C;class 'numpy.float64'&gt;'</code><br />&lt;/p&gt;&lt;p&gt;<code>with 3397 stored elements in Compressed Sparse Row format&gt;</code>&lt;/p&gt; |
| — | ———————————————————————————————————————————————————————————————————– |</p>

<p><strong>3.4.3 Text classification using tf/idf vectors</strong></p>

<p>Now that we’ve encoded the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset’s <code class="language-plaintext highlighter-rouge">title</code> column into tf/idf vectors, let’s use those vectors to try to predict the <code class="language-plaintext highlighter-rouge">category_desc</code> column.</p>

<p>| 12345678910111213141516171819 | &lt;p&gt;<code>text_tfidf.toarray()</code><br />&lt;/p&gt;&lt;p&gt;<code>array([[0., 0., 0., ..., 0., 0., 0.],</code><br />&lt;/p&gt;&lt;p&gt;<code>[0., 0., 0., ..., 0., 0., 0.],</code><br />&lt;/p&gt;&lt;p&gt;<code>[0., 0., 0., ..., 0., 0., 0.],</code><br />&lt;/p&gt;&lt;p&gt;<code>...,</code><br />&lt;/p&gt;&lt;p&gt;<code>[0., 0., 0., ..., 0., 0., 0.],</code><br />&lt;/p&gt;&lt;p&gt;<code>[0., 0., 0., ..., 0., 0., 0.],</code><br />&lt;/p&gt;&lt;p&gt;<code>[0., 0., 0., ..., 0., 0., 0.]])</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code>text_tfidf.toarray().shape</code><br />&lt;/p&gt;&lt;p&gt;<code># (617, 1089)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code>volunteer["category_desc"].head()</code><br />&lt;/p&gt;&lt;p&gt;<code>1 Strengthening Communities</code><br />&lt;/p&gt;&lt;p&gt;<code>2 Strengthening Communities</code><br />&lt;/p&gt;&lt;p&gt;<code>3 Strengthening Communities</code><br />&lt;/p&gt;&lt;p&gt;<code>4 Environment</code><br />&lt;/p&gt;&lt;p&gt;<code>5 Environment</code><br />&lt;/p&gt;&lt;p&gt;<code>Name: category_desc, dtype: object</code>&lt;/p&gt; |
| —————————– | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– |</p>

<p>| 12345678910 | &lt;p&gt;<code># Split the dataset according to the class distribution of category_desc</code><br />&lt;/p&gt;&lt;p&gt;<code>y = volunteer["category_desc"]</code><br />&lt;/p&gt;&lt;p&gt;<code>X_train, X_test, y_train, y_test = train_test_split(text_tfidf.toarray(), y, stratify=y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Fit the model to the training data</code><br />&lt;/p&gt;&lt;p&gt;<code>nb.fit(X_train, y_train)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Print out the model's accuracy</code><br />&lt;/p&gt;&lt;p&gt;<code>print(nb.score(X_test, y_test))</code><br />&lt;/p&gt;&lt;p&gt;<code># 0.567741935483871</code>&lt;/p&gt; |
| ———– | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– |</p>

<p>Notice that the model doesn’t score very well. We’ll work on selecting the best features for modeling in the next chapter.</p>

<h4 id="4-selecting-features-for-modeling"><strong>4. Selecting features for modeling</strong></h4>

<p><strong>4.1 Feature selection</strong></p>

<p><img src="https://datascience103579984.files.wordpress.com/2019/12/1-12.png?w=770" alt="" /></p>

<p><strong>4.1.1 Identifying areas for feature selection</strong></p>

<p>Take an exploratory look at the post-feature engineering <code class="language-plaintext highlighter-rouge">hiking</code> dataset. Which of the following columns is a good candidate for feature selection?</p>

<p>| 123456 | &lt;p&gt;<code>hiking.columns</code><br />&lt;/p&gt;&lt;p&gt;<code>Index(['Accessible', 'Difficulty', 'Length', 'Limited_Access', 'Location',</code><br />&lt;/p&gt;&lt;p&gt;<code>'Name', 'Other_Details', 'Park_Name', 'Prop_ID', 'lat', 'lon',</code><br />&lt;/p&gt;&lt;p&gt;<code>'Length_extract', 'accessible_enc', '', 'Easy', 'Easy ',</code><br />&lt;/p&gt;&lt;p&gt;<code>'Easy/Moderate', 'Moderate', 'Moderate/Difficult', 'Various'],</code><br />&lt;/p&gt;&lt;p&gt;<code>dtype='object')</code>&lt;/p&gt; |
| —— | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<ul>
  <li>Length</li>
  <li>Difficulty</li>
  <li>Accessible</li>
</ul>

<p>All three of these columns are good candidates for feature selection.</p>

<p><strong>4.2 Removing redundant features</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/2-13.png?w=596" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/3-13.png?w=912" alt="" /></li>
</ul>

<p><strong>4.2.1 Selecting relevant features</strong></p>

<p>Now let’s identify the redundant columns in the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset and perform feature selection on the dataset to return a DataFrame of the relevant features.</p>

<p>For example, if you explore the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset in the console, you’ll see three features which are related to location: <code class="language-plaintext highlighter-rouge">locality</code>, <code class="language-plaintext highlighter-rouge">region</code>, and <code class="language-plaintext highlighter-rouge">postalcode</code>. They contain repeated information, so it would make sense to keep only one of the features.</p>

<p>There are also features that have gone through the feature engineering process: columns like <code class="language-plaintext highlighter-rouge">Education</code> and <code class="language-plaintext highlighter-rouge">Emergency Preparedness</code> are a product of encoding the categorical variable <code class="language-plaintext highlighter-rouge">category_desc</code>, so <code class="language-plaintext highlighter-rouge">category_desc</code> itself is redundant now.</p>

<p>Take a moment to examine the features of <code class="language-plaintext highlighter-rouge">volunteer</code> in the console, and try to identify the redundant features.</p>

<p>| 12345678 | &lt;p&gt;<code># Create a list of redundant column names to drop</code><br />&lt;/p&gt;&lt;p&gt;<code>to_drop = ["locality", "region", "category_desc", "created_date", "vol_requests"]</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Drop those columns from the dataset</code><br />&lt;/p&gt;&lt;p&gt;<code>volunteer_subset = volunteer.drop(to_drop, axis=1)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Print out the head of the new dataset</code><br />&lt;/p&gt;&lt;p&gt;<code>print(volunteer_subset.head())</code>&lt;/p&gt; |
| ——– | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p>| 12345 | &lt;p&gt;<code>volunteer_subset.columns</code><br />&lt;/p&gt;&lt;p&gt;<code>Index(['title', 'hits', 'postalcode', 'vol_requests_lognorm', 'created_month',</code><br />&lt;/p&gt;&lt;p&gt;<code>'Education', 'Emergency Preparedness', 'Environment', 'Health',</code><br />&lt;/p&gt;&lt;p&gt;<code>'Helping Neighbors in Need', 'Strengthening Communities'],</code><br />&lt;/p&gt;&lt;p&gt;<code>dtype='object')</code>&lt;/p&gt; |
| —– | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>4.2.2 Checking for correlated features</strong></p>

<p>Let’s take a look at the <code class="language-plaintext highlighter-rouge">wine</code> dataset again, which is made up of continuous, numerical features. Run Pearson’s correlation coefficient on the dataset to determine which columns are good candidates for eliminating. Then, remove those columns from the DataFrame.</p>

<p>| 12345678 | &lt;p&gt;<code># Print out the column correlations of the wine dataset</code><br />&lt;/p&gt;&lt;p&gt;<code>print(wine.corr())</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Take a minute to find the column where the correlation value is greater than 0.75 at least twice</code><br />&lt;/p&gt;&lt;p&gt;<code>to_drop = "Flavanoids"</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Drop that column from the DataFrame</code><br />&lt;/p&gt;&lt;p&gt;<code>wine = wine.drop(to_drop, axis=1)</code>&lt;/p&gt; |
| ——– | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– |</p>

<p>| 1234567 | &lt;p&gt;<code>print(wine.corr())</code><br />&lt;/p&gt;&lt;p&gt;<code>Flavanoids Total phenols Malic acid OD280/OD315 of diluted wines Hue</code><br />&lt;/p&gt;&lt;p&gt;<code>Flavanoids 1.000000 0.864564 -0.411007 0.787194 0.543479</code><br />&lt;/p&gt;&lt;p&gt;<code>Total phenols 0.864564 1.000000 -0.335167 0.699949 0.433681</code><br />&lt;/p&gt;&lt;p&gt;<code>Malic acid -0.411007 -0.335167 1.000000 -0.368710 -0.561296</code><br />&lt;/p&gt;&lt;p&gt;<code>OD280/OD315 of diluted wines 0.787194 0.699949 -0.368710 1.000000 0.565468</code><br />&lt;/p&gt;&lt;p&gt;<code>Hue 0.543479 0.433681 -0.561296 0.565468 1.000000</code><br />&lt;/p&gt;&lt;p&gt;&#x3C;code&gt;&#x3C;/code&gt;&lt;/p&gt; |
| ——- | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– |</p>

<p><strong>4.3 Selecting features using text vectors</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/4-13.png?w=985" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/5-13.png?w=997" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/6-13.png?w=945" alt="" /></li>
</ul>

<p><strong>4.3.1 Exploring text vectors, part 1</strong></p>

<p>Let’s expand on the text vector exploration method we just learned about, using the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset’s <code class="language-plaintext highlighter-rouge">title</code> tf/idf vectors. In this first part of text vector exploration, we’re going to add to that function we learned about in the slides. We’ll return a list of numbers with the function. In the next exercise, we’ll write another function to collect the top words across all documents, extract them, and then use that list to filter down our <code class="language-plaintext highlighter-rouge">text_tfidf</code> vector.</p>

<p>|   | &lt;p&gt;<code>vocab</code><br />&lt;/p&gt;&lt;p&gt;<code>{1048: 'web',</code><br />&lt;/p&gt;&lt;p&gt;<code>278: 'designer',</code><br />&lt;/p&gt;&lt;p&gt;<code>1017: 'urban',</code><br />&lt;/p&gt;&lt;p&gt;<code>...}</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code>tfidf_vec</code><br />&lt;/p&gt;&lt;p&gt;<code>TfidfVectorizer(analyzer='word', binary=False, decode_error='strict',</code><br />&lt;/p&gt;&lt;p&gt;<code>dtype=&#x3C;class 'numpy.int64'&gt;, encoding='utf-8', input='content',</code><br />&lt;/p&gt;&lt;p&gt;<code>lowercase=True, max_df=1.0, max_features=None, min_df=1,</code><br />&lt;/p&gt;&lt;p&gt;<code>ngram_range=(1, 1), norm='l2', preprocessor=None, smooth_idf=True,</code><br />&lt;/p&gt;&lt;p&gt;<code>stop_words=None, strip_accents=None, sublinear_tf=False,</code><br />&lt;/p&gt;&lt;p&gt;<code>token_pattern='(?u)\\b\\w\\w+\\b', tokenizer=None, use_idf=True,</code><br />&lt;/p&gt;&lt;p&gt;<code>vocabulary=None)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code>tfidf_vec.vocabulary_</code><br />&lt;/p&gt;&lt;p&gt;<code>{'web': 1048,</code><br />&lt;/p&gt;&lt;p&gt;<code>'designer': 278,</code><br />&lt;/p&gt;&lt;p&gt;<code>'urban': 1017,</code><br />&lt;/p&gt;&lt;p&gt;<code>...}</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code>text_tfidf</code><br />&lt;/p&gt;&lt;p&gt;<code>&#x3C;617x1089 sparse matrix of type '&#x3C;class 'numpy.float64'&gt;'</code><br />&lt;/p&gt;&lt;p&gt;<code>with 3172 stored elements in Compressed Sparse Row format&gt;</code>&lt;/p&gt; |
| - | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p>|   | &lt;p&gt;<code># Add in the rest of the parameters</code><br />&lt;/p&gt;&lt;p&gt;<code>def return_weights(vocab, original_vocab, vector, vector_index, top_n):</code><br />&lt;/p&gt;&lt;p&gt;<code>zipped = dict(zip(vector[vector_index].indices, vector[vector_index].data))</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Let's transform that zipped dict into a series</code><br />&lt;/p&gt;&lt;p&gt;<code>zipped_series = pd.Series({vocab[i]:zipped[i] for i in vector[vector_index].indices})</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Let's sort the series to pull out the top n weighted words</code><br />&lt;/p&gt;&lt;p&gt;<code>zipped_index = zipped_series.sort_values(ascending=False)[:top_n].index</code><br />&lt;/p&gt;&lt;p&gt;<code>return [original_vocab[i] for i in zipped_index]</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Print out the weighted words</code><br />&lt;/p&gt;&lt;p&gt;<code>print(return_weights(vocab, tfidf_vec.vocabulary_, text_tfidf, vector_index=8, top_n=3))</code><br />&lt;/p&gt;&lt;p&gt;<code># [189, 942, 466]</code>&lt;/p&gt; |
| - | ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>4.3.2 Exploring text vectors, part 2</strong></p>

<p>Using the function we wrote in the previous exercise, we’re going to extract the top words from each document in the text vector, return a list of the word indices, and use that list to filter the text vector down to those top words.</p>

<p>|   | &lt;p&gt;<code>def words_to_filter(vocab, original_vocab, vector, top_n):</code><br />&lt;/p&gt;&lt;p&gt;<code>filter_list = []</code><br />&lt;/p&gt;&lt;p&gt;<code>for i in range(0, vector.shape[0]):</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Here we'll call the function from the previous exercise, and extend the list we're creating</code><br />&lt;/p&gt;&lt;p&gt;<code>filtered = return_weights(vocab, original_vocab, vector, i, top_n)</code><br />&lt;/p&gt;&lt;p&gt;<code>filter_list.extend(filtered)</code><br />&lt;/p&gt;&lt;p&gt;<code># Return the list in a set, so we don't get duplicate word indices</code><br />&lt;/p&gt;&lt;p&gt;<code>return set(filter_list)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Call the function to get the list of word indices</code><br />&lt;/p&gt;&lt;p&gt;<code>filtered_words = words_to_filter(vocab, tfidf_vec.vocabulary_, text_tfidf, 3)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># By converting filtered_words back to a list, we can use it to filter the columns in the text vector</code><br />&lt;/p&gt;&lt;p&gt;<code>filtered_text = text_tfidf[:, list(filtered_words)]</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code>filtered_text</code><br />&lt;/p&gt;&lt;p&gt;<code>&#x3C;617x1008 sparse matrix of type '&#x3C;class 'numpy.float64'&gt;'</code><br />&lt;/p&gt;&lt;p&gt;<code>with 2948 stored elements in Compressed Sparse Row format&gt;</code>&lt;/p&gt; |
| - | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>4.3.3 Training Naive Bayes with feature selection</strong></p>

<p>Let’s re-run the Naive Bayes text classification model we ran at the end of chapter 3, with our selection choices from the previous exercise, on the <code class="language-plaintext highlighter-rouge">volunteer</code> dataset’s <code class="language-plaintext highlighter-rouge">title</code> and <code class="language-plaintext highlighter-rouge">category_desc</code> columns.</p>

<p>|   | &lt;p&gt;<code># Split the dataset according to the class distribution of category_desc, using the filtered_text vector</code><br />&lt;/p&gt;&lt;p&gt;<code>train_X, test_X, train_y, test_y = train_test_split(filtered_text.toarray(), y, stratify=y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Fit the model to the training data</code><br />&lt;/p&gt;&lt;p&gt;<code>nb.fit(train_X, train_y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Print out the model's accuracy</code><br />&lt;/p&gt;&lt;p&gt;<code>print(nb.score(test_X,test_y))</code><br />&lt;/p&gt;&lt;p&gt;<code># 0.567741935483871</code>&lt;/p&gt; |
| - | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p>You can see that our accuracy score wasn’t that different from the score at the end of chapter 3. That’s okay; the <code class="language-plaintext highlighter-rouge">title</code> field is a very small text field, appropriate for demonstrating how filtering vectors works.</p>

<p><strong>4.4 Dimensionality reduction</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/7-13.png?w=830" alt="" /></li>
</ul>

<p><strong>4.4.1 Using PCA</strong></p>

<p>Let’s apply PCA to the <code class="language-plaintext highlighter-rouge">wine</code> dataset, to see if we can get an increase in our model’s accuracy.</p>

<p>|   | &lt;p&gt;<code>from sklearn.decomposition import PCA</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Set up PCA and the X vector for diminsionality reduction</code><br />&lt;/p&gt;&lt;p&gt;<code>pca = PCA()</code><br />&lt;/p&gt;&lt;p&gt;<code>wine_X = wine.drop("Type", axis=1)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Apply PCA to the wine dataset X vector</code><br />&lt;/p&gt;&lt;p&gt;<code>transformed_X = pca.fit_transform(wine_X)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Look at the percentage of variance explained by the different components</code><br />&lt;/p&gt;&lt;p&gt;<code>print(pca.explained_variance_ratio_)</code>&lt;/p&gt; |
| - | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p>|   | &lt;p&gt;<code>[9.98091230e-01 1.73591562e-03 9.49589576e-05 5.02173562e-05</code><br />&lt;/p&gt;&lt;p&gt;<code>1.23636847e-05 8.46213034e-06 2.80681456e-06 1.52308053e-06</code><br />&lt;/p&gt;&lt;p&gt;<code>1.12783044e-06 7.21415811e-07 3.78060267e-07 2.12013755e-07</code><br />&lt;/p&gt;&lt;p&gt;<code>8.25392788e-08]</code>&lt;/p&gt; |
| - | ——————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>4.4.2 Training a model with PCA</strong></p>

<p>Now that we have run PCA on the <code class="language-plaintext highlighter-rouge">wine</code> dataset, let’s try training a model with it.</p>

<p>|   | &lt;p&gt;<code># Split the transformed X and the y labels into training and test sets</code><br />&lt;/p&gt;&lt;p&gt;<code>X_wine_train, X_wine_test, y_wine_train, y_wine_test = train_test_split(transformed_X,y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Fit knn to the training data</code><br />&lt;/p&gt;&lt;p&gt;<code>knn.fit(X_wine_train,y_wine_train)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Score knn on the test data and print it out</code><br />&lt;/p&gt;&lt;p&gt;<code>knn.score(X_wine_test,y_wine_test)</code><br />&lt;/p&gt;&lt;p&gt;<code># 0.6444444444444445</code>&lt;/p&gt; |
| - | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<h4 id="5-putting-it-all-together"><strong>5. Putting it all together</strong></h4>

<p><strong>5.1 UFOs and preprocessing</strong></p>

<p>|   | &lt;p&gt;<code>ufo.head()</code><br />&lt;/p&gt;&lt;p&gt;<code>date city state country type seconds \</code><br />&lt;/p&gt;&lt;p&gt;<code>2 2002-11-21 05:45:00 clemmons nc us triangle 300.0</code><br />&lt;/p&gt;&lt;p&gt;<code>4 2012-06-16 23:00:00 san diego ca us light 600.0</code><br />&lt;/p&gt;&lt;p&gt;<code>7 2013-06-09 00:00:00 oakville (canada) on ca light 120.0</code><br />&lt;/p&gt;&lt;p&gt;<code>8 2013-04-26 23:27:00 lacey wa us light 120.0</code><br />&lt;/p&gt;&lt;p&gt;<code>9 2013-09-13 20:30:00 ben avon pa us sphere 300.0</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code>length_of_time desc \</code><br />&lt;/p&gt;&lt;p&gt;<code>2 about 5 minutes It was a large, triangular shaped flying ob...</code><br />&lt;/p&gt;&lt;p&gt;<code>4 10 minutes Dancing lights that would fly around and then ...</code><br />&lt;/p&gt;&lt;p&gt;<code>7 2 minutes Brilliant orange light or chinese lantern at o...</code><br />&lt;/p&gt;&lt;p&gt;<code>8 2 minutes Bright red light moving north to north west fr...</code><br />&lt;/p&gt;&lt;p&gt;<code>9 5 minutes North-east moving south-west. First 7 or so li...</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code>recorded lat long</code><br />&lt;/p&gt;&lt;p&gt;<code>2 12/23/2002 36.021389 -80.382222</code><br />&lt;/p&gt;&lt;p&gt;<code>4 7/4/2012 32.715278 -117.156389</code><br />&lt;/p&gt;&lt;p&gt;<code>7 7/3/2013 43.433333 -79.666667</code><br />&lt;/p&gt;&lt;p&gt;<code>8 5/15/2013 47.034444 -122.821944</code><br />&lt;/p&gt;&lt;p&gt;<code>9 9/30/2013 40.508056 -80.083333</code>&lt;/p&gt; |
| - | ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><img src="https://datascience103579984.files.wordpress.com/2019/12/8-12.png?w=977" alt="" /></p>

<p><strong>5.1.1 Checking column types</strong></p>

<p>Take a look at the UFO dataset’s column types using the <code class="language-plaintext highlighter-rouge">dtypes</code> attribute. Two columns jump out for transformation: the seconds column, which is a numeric column but is being read in as <code class="language-plaintext highlighter-rouge">object</code>, and the <code class="language-plaintext highlighter-rouge">date</code> column, which can be transformed into the <code class="language-plaintext highlighter-rouge">datetime</code> type. That will make our feature engineering efforts easier later on.</p>

<p>|   | &lt;p&gt;<code># Check the column types</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo.dtypes)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Change the type of seconds to float</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo["seconds"] = ufo.seconds.astype('float')</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Change the date column to type datetime</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo["date"] = pd.to_datetime(ufo['date'])</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Check the column types</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo[['seconds','date']].dtypes)</code>&lt;/p&gt; |
| - | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p>|   | &lt;p&gt;<code>date object</code><br />&lt;/p&gt;&lt;p&gt;<code>city object</code><br />&lt;/p&gt;&lt;p&gt;<code>state object</code><br />&lt;/p&gt;&lt;p&gt;<code>country object</code><br />&lt;/p&gt;&lt;p&gt;<code>type object</code><br />&lt;/p&gt;&lt;p&gt;<code>seconds object</code><br />&lt;/p&gt;&lt;p&gt;<code>length_of_time object</code><br />&lt;/p&gt;&lt;p&gt;<code>desc object</code><br />&lt;/p&gt;&lt;p&gt;<code>recorded object</code><br />&lt;/p&gt;&lt;p&gt;<code>lat object</code><br />&lt;/p&gt;&lt;p&gt;<code>long float64</code><br />&lt;/p&gt;&lt;p&gt;<code>dtype: object</code><br />&lt;/p&gt;&lt;p&gt;<code>seconds float64</code><br />&lt;/p&gt;&lt;p&gt;<code>date datetime64[ns]</code><br />&lt;/p&gt;&lt;p&gt;<code>dtype: object</code>&lt;/p&gt; |
| - | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>5.1.2 Dropping missing data</strong></p>

<p>Let’s remove some of the rows where certain columns have missing values. We’re going to look at the <code class="language-plaintext highlighter-rouge">length_of_time</code> column, the <code class="language-plaintext highlighter-rouge">state</code> column, and the <code class="language-plaintext highlighter-rouge">type</code> column. If any of the values in these columns are missing, we’re going to drop the rows.</p>

<p>| 12345678910 | &lt;p&gt;<code># Check how many values are missing in the length_of_time, state, and type columns</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo[['length_of_time', 'state', 'type']].isnull().sum())</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Keep only rows where length_of_time, state, and type are not null</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo_no_missing = ufo[ufo['length_of_time'].notnull() &#x26;</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo['state'].notnull() &#x26;</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo['type'].notnull()]</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Print out the shape of the new dataset</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo_no_missing.shape)</code>&lt;/p&gt; |
| ———– | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p>| 12345 | &lt;p&gt;<code>length_of_time 143</code><br />&lt;/p&gt;&lt;p&gt;<code>state 419</code><br />&lt;/p&gt;&lt;p&gt;<code>type 159</code><br />&lt;/p&gt;&lt;p&gt;<code>dtype: int64</code><br />&lt;/p&gt;&lt;p&gt;<code>(4283, 4)</code>&lt;/p&gt; |
| —– | —————————————————————————————————————————————————————————- |</p>

<p><strong>5.2 Categorical variables and standardization</strong></p>

<ul>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/9-12.png?w=731" alt="" /></li>
  <li><img src="https://datascience103579984.files.wordpress.com/2019/12/10-12.png?w=486" alt="" /></li>
</ul>

<p><strong>5.2.1 Extracting numbers from strings</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">length_of_time</code> field in the UFO dataset is a text field that has the number of minutes within the string. Here, you’ll extract that number from that text field using regular expressions.</p>

<p>| 123456789101112131415 | &lt;p&gt;<code>def return_minutes(time_string):</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Use \d+ to grab digits</code><br />&lt;/p&gt;&lt;p&gt;<code>pattern = re.compile(r"\d+")</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Use match on the pattern and column</code><br />&lt;/p&gt;&lt;p&gt;<code>num = re.match(pattern, time_string)</code><br />&lt;/p&gt;&lt;p&gt;<code>if num is not None:</code><br />&lt;/p&gt;&lt;p&gt;<code>return int(num.group(0))</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Apply the extraction to the length_of_time column</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo["minutes"] = ufo["length_of_time"].apply(return_minutes)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Take a look at the head of both of the columns</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo[['length_of_time','minutes']].head())</code>&lt;/p&gt; |
| ——————— | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– |</p>

<p>| 123456 | &lt;p&gt;<code>length_of_time minutes</code><br />&lt;/p&gt;&lt;p&gt;<code>2 about 5 minutes NaN</code><br />&lt;/p&gt;&lt;p&gt;<code>4 10 minutes 10.0</code><br />&lt;/p&gt;&lt;p&gt;<code>7 2 minutes 2.0</code><br />&lt;/p&gt;&lt;p&gt;<code>8 2 minutes 2.0</code><br />&lt;/p&gt;&lt;p&gt;<code>9 5 minutes 5.0</code>&lt;/p&gt; |
| —— | —————————————————————————————————————————————————————————————————————————————————– |</p>

<p><strong>5.2.2 Identifying features for standardization</strong></p>

<p>In this section, you’ll investigate the variance of columns in the UFO dataset to determine which features should be standardized. After taking a look at the variances of the <code class="language-plaintext highlighter-rouge">seconds</code> and <code class="language-plaintext highlighter-rouge">minutes</code> column, you’ll see that the variance of the <code class="language-plaintext highlighter-rouge">seconds</code> column is extremely high. Because <code class="language-plaintext highlighter-rouge">seconds</code> and <code class="language-plaintext highlighter-rouge">minutes</code> are related to each other (an issue we’ll deal with when we select features for modeling), let’s log normlize the <code class="language-plaintext highlighter-rouge">seconds</code> column.</p>

<p>| 12345678 | &lt;p&gt;<code># Check the variance of the seconds and minutes columns</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo[['seconds','minutes']].var())</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Log normalize the seconds column</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo["seconds_log"] = np.log(ufo[['seconds']])</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Print out the variance of just the seconds_log column</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo["seconds_log"].var())</code>&lt;/p&gt; |
| ——– | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p>| 1234 | &lt;p&gt;<code>seconds 424087.417474</code><br />&lt;/p&gt;&lt;p&gt;<code>minutes 117.546372</code><br />&lt;/p&gt;&lt;p&gt;<code>dtype: float64</code><br />&lt;/p&gt;&lt;p&gt;<code>1.1223923881183004</code>&lt;/p&gt; |
| —- | ——————————————————————————————————————————————————————- |</p>

<p><strong>5.3 Engineering new features</strong></p>

<p><img src="https://datascience103579984.files.wordpress.com/2019/12/11-11.png?w=995" alt="" /></p>

<p><strong>5.3.1 Encoding categorical variables</strong></p>

<p>There are couple of columns in the UFO dataset that need to be encoded before they can be modeled through scikit-learn. You’ll do that transformation here, using both binary and one-hot encoding methods.</p>

<p>| 123456789101112 | &lt;p&gt;<code># Use Pandas to encode us values as 1 and others as 0</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo["country_enc"] = ufo["country"].apply(lambda x: 1 if x=='us' else 0)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Print the number of unique type values</code><br />&lt;/p&gt;&lt;p&gt;<code>print(len(ufo['type'].unique()))</code><br />&lt;/p&gt;&lt;p&gt;<code># 21</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Create a one-hot encoded set of the type values</code><br />&lt;/p&gt;&lt;p&gt;<code>type_set = pd.get_dummies(ufo['type'])</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Concatenate this set back to the ufo DataFrame</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo = pd.concat([ufo, type_set], axis=1)</code>&lt;/p&gt; |
| ————— | ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>5.3.2 Features from dates</strong></p>

<p>Another feature engineering task to perform is month and year extraction. Perform this task on the <code class="language-plaintext highlighter-rouge">date</code> column of the <code class="language-plaintext highlighter-rouge">ufo</code> dataset.</p>

<p>|   | &lt;p&gt;<code># Look at the first 5 rows of the date column</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo['date'].head())</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Extract the month from the date column</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo["month"] = ufo["date"].apply(lambda x:x.month)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Extract the year from the date column</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo["year"] = ufo["date"].apply(lambda x:x.year)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Take a look at the head of all three columns</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo[['date','month','year']].head())</code>&lt;/p&gt; |
| - | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p>|   | &lt;p&gt;<code>0 2002-11-21 05:45:00</code><br />&lt;/p&gt;&lt;p&gt;<code>1 2012-06-16 23:00:00</code><br />&lt;/p&gt;&lt;p&gt;<code>2 2013-06-09 00:00:00</code><br />&lt;/p&gt;&lt;p&gt;<code>3 2013-04-26 23:27:00</code><br />&lt;/p&gt;&lt;p&gt;<code>4 2013-09-13 20:30:00</code><br />&lt;/p&gt;&lt;p&gt;<code>Name: date, dtype: datetime64[ns]</code><br />&lt;/p&gt;&lt;p&gt;<code>date month year</code><br />&lt;/p&gt;&lt;p&gt;<code>0 2002-11-21 05:45:00 11 2002</code><br />&lt;/p&gt;&lt;p&gt;<code>1 2012-06-16 23:00:00 6 2012</code><br />&lt;/p&gt;&lt;p&gt;<code>2 2013-06-09 00:00:00 6 2013</code><br />&lt;/p&gt;&lt;p&gt;<code>3 2013-04-26 23:27:00 4 2013</code><br />&lt;/p&gt;&lt;p&gt;<code>4 2013-09-13 20:30:00 9 2013</code>&lt;/p&gt; |
| - | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– |</p>

<p><strong>5.3.3 Text vectorization</strong></p>

<p>Let’s transform the <code class="language-plaintext highlighter-rouge">desc</code> column in the UFO dataset into tf/idf vectors, since there’s likely something we can learn from this field.</p>

<p>|   | &lt;p&gt;<code># Take a look at the head of the desc field</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo["desc"].head())</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Create the tfidf vectorizer object</code><br />&lt;/p&gt;&lt;p&gt;<code>vec = TfidfVectorizer()</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Use vec's fit_transform method on the desc field</code><br />&lt;/p&gt;&lt;p&gt;<code>desc_tfidf = vec.fit_transform(ufo["desc"])</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Look at the number of columns this creates</code><br />&lt;/p&gt;&lt;p&gt;<code>print(desc_tfidf.shape)</code>&lt;/p&gt; |
| - | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p>|   | &lt;p&gt;<code>0 It was a large, triangular shaped flying ob...</code><br />&lt;/p&gt;&lt;p&gt;<code>1 Dancing lights that would fly around and then ...</code><br />&lt;/p&gt;&lt;p&gt;<code>2 Brilliant orange light or chinese lantern at o...</code><br />&lt;/p&gt;&lt;p&gt;<code>3 Bright red light moving north to north west fr...</code><br />&lt;/p&gt;&lt;p&gt;<code>4 North-east moving south-west. First 7 or so li...</code><br />&lt;/p&gt;&lt;p&gt;<code>Name: desc, dtype: object</code><br />&lt;/p&gt;&lt;p&gt;<code>(1866, 3422)</code>&lt;/p&gt; |
| - | ——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>5.4 Feature selection and modeling</strong></p>

<p><img src="https://datascience103579984.files.wordpress.com/2019/12/12-12.png?w=925" alt="" /></p>

<p><strong>5.4.1 Selecting the ideal dataset</strong></p>

<p>Let’s get rid of some of the unnecessary features. Because we have an encoded country column, <code class="language-plaintext highlighter-rouge">country_enc</code>, keep it and drop other columns related to location: <code class="language-plaintext highlighter-rouge">city</code>, <code class="language-plaintext highlighter-rouge">country</code>, <code class="language-plaintext highlighter-rouge">lat</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">state</code>.</p>

<p>We have columns related to <code class="language-plaintext highlighter-rouge">month</code> and <code class="language-plaintext highlighter-rouge">year</code>, so we don’t need the <code class="language-plaintext highlighter-rouge">date</code> or <code class="language-plaintext highlighter-rouge">recorded</code> columns.</p>

<p>We vectorized <code class="language-plaintext highlighter-rouge">desc</code>, so we don’t need it anymore. For now we’ll keep <code class="language-plaintext highlighter-rouge">type</code>.</p>

<p>We’ll keep <code class="language-plaintext highlighter-rouge">seconds_log</code> and drop <code class="language-plaintext highlighter-rouge">seconds</code> and <code class="language-plaintext highlighter-rouge">minutes</code>.</p>

<p>Let’s also get rid of the <code class="language-plaintext highlighter-rouge">length_of_time</code> column, which is unnecessary after extracting <code class="language-plaintext highlighter-rouge">minutes</code>.</p>

<p>|   | &lt;p&gt;<code># Check the correlation between the seconds, seconds_log, and minutes columns</code><br />&lt;/p&gt;&lt;p&gt;<code>print(ufo[['seconds','seconds_log','minutes']].corr())</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Make a list of features to drop</code><br />&lt;/p&gt;&lt;p&gt;<code>to_drop = ['city', 'country', 'date', 'desc', 'lat', 'length_of_time', 'long', 'minutes', 'recorded', 'seconds', 'state']</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Drop those features</code><br />&lt;/p&gt;&lt;p&gt;<code>ufo_dropped = ufo.drop(to_drop,axis=1)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Let's also filter some words out of the text vector we created</code><br />&lt;/p&gt;&lt;p&gt;<code>filtered_words = words_to_filter(vocab, vec.vocabulary_, desc_tfidf, 4)</code>&lt;/p&gt; |
| - | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p>|   | &lt;p&gt;<code>seconds seconds_log minutes</code><br />&lt;/p&gt;&lt;p&gt;<code>seconds 1.000000 0.853371 0.980341</code><br />&lt;/p&gt;&lt;p&gt;<code>seconds_log 0.853371 1.000000 0.824493</code><br />&lt;/p&gt;&lt;p&gt;<code>minutes 0.980341 0.824493 1.000000</code>&lt;/p&gt; |
| - | ——————————————————————————————————————————————————————————————————————————— |</p>

<p><strong>5.4.2 Modeling the UFO dataset, part 1</strong></p>

<p>In this exercise, we’re going to build a k-nearest neighbor model to predict which country the UFO sighting took place in. Our <code class="language-plaintext highlighter-rouge">X</code> dataset has the log-normalized seconds column, the one-hot encoded type columns, as well as the month and year when the sighting took place. The <code class="language-plaintext highlighter-rouge">y</code> labels are the encoded country column, where 1 is <code class="language-plaintext highlighter-rouge">us</code> and 0 is <code class="language-plaintext highlighter-rouge">ca</code>.</p>

<p>|   | &lt;p&gt;<code># Take a look at the features in the X set of data</code><br />&lt;/p&gt;&lt;p&gt;<code>print(X.columns)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Split the X and y sets using train_test_split, setting stratify=y</code><br />&lt;/p&gt;&lt;p&gt;<code>train_X, test_X, train_y, test_y = train_test_split(X,y,stratify=y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Fit knn to the training sets</code><br />&lt;/p&gt;&lt;p&gt;<code>knn.fit(train_X,train_y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Print the score of knn on the test sets</code><br />&lt;/p&gt;&lt;p&gt;<code>print(knn.score(test_X,test_y))</code><br />&lt;/p&gt;&lt;p&gt;<code># 0.8693790149892934</code>&lt;/p&gt; |
| - | ————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p>|   | &lt;p&gt;<code>Index(['seconds_log', 'changing', 'chevron', 'cigar', 'circle', 'cone',</code><br />&lt;/p&gt;&lt;p&gt;<code>'cross', 'cylinder', 'diamond', 'disk', 'egg', 'fireball', 'flash',</code><br />&lt;/p&gt;&lt;p&gt;<code>'formation', 'light', 'other', 'oval', 'rectangle', 'sphere',</code><br />&lt;/p&gt;&lt;p&gt;<code>'teardrop', 'triangle', 'unknown', 'month', 'year'],</code><br />&lt;/p&gt;&lt;p&gt;<code>dtype='object')</code>&lt;/p&gt; |
| - | ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |</p>

<p><strong>5.4.3 Modeling the UFO dataset, part 2</strong></p>

<p>Finally, let’s build a model using the text vector we created, <code class="language-plaintext highlighter-rouge">desc_tfidf</code>, using the <code class="language-plaintext highlighter-rouge">filtered_words</code> list to create a filtered text vector. Let’s see if we can predict the <code class="language-plaintext highlighter-rouge">type</code> of the sighting based on the text. We’ll use a Naive Bayes model for this.</p>

<p>| 123456789101112 | &lt;p&gt;<code># Use the list of filtered words we created to filter the text vector</code><br />&lt;/p&gt;&lt;p&gt;<code>filtered_text = desc_tfidf[:, list(filtered_words)]</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Split the X and y sets using train_test_split, setting stratify=y</code><br />&lt;/p&gt;&lt;p&gt;<code>train_X, test_X, train_y, test_y = train_test_split(filtered_text.toarray(), y, stratify=y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Fit nb to the training sets</code><br />&lt;/p&gt;&lt;p&gt;<code>nb.fit(train_X,train_y)</code><br />&lt;/p&gt;&lt;p&gt;<br />&lt;/p&gt;&lt;p&gt;<code># Print the score of nb on the test sets</code><br />&lt;/p&gt;&lt;p&gt;<code>print(nb.score(test_X,test_y))</code><br />&lt;/p&gt;&lt;p&gt;<code># 0.16274089935760172</code>&lt;/p&gt; |
| ————— | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————— |</p>

<p>As you can see, this model performs very poorly on this text data. This is a clear case where iteration would be necessary to figure out what subset of text improves the model, and if perhaps any of the other features are useful in predicting <code class="language-plaintext highlighter-rouge">type</code>.</p>

<p>Thank you for reading and hope you’ve learned a lot.</p>
