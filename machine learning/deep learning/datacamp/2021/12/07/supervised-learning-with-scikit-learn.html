<h1 id="supervised-learning-with-scikit-learn">Supervised Learning with scikit-learn</h1>

<p>This is the memo of the 21th course of ‘Data Scientist with Python’ track.</p>

<p><strong>You can find the original course
 <a href="https://www.datacamp.com/courses/supervised-learning-with-scikit-learn">HERE</a></strong>
 .</p>

<hr />

<ol>
  <li>
    <h2 id="classification">Classification</h2>
  </li>
</ol>

<p>###
<strong>Machine learning introduction</strong></p>

<p><strong>What is machine learning?</strong>
 Giving computers the ability to learn to make decisions from data without being explicitly programmed</p>

<p><strong>Examples of machine learning:</strong>
 Learning to predict whether an email is spam or not (supervised)</p>

<p>Clustering Wikipedia entries into different categories (unsupervised)</p>

<p>####
<strong>Types of Machine Learning</strong></p>

<ul>
  <li>supervised learning</li>
  <li>unsupervised learning</li>
  <li>reinforcement learning</li>
</ul>

<p><strong>Supervised learning:</strong></p>

<p>Predictor variables/
 <strong>features</strong>
 and a
 <strong>target variable</strong></p>

<p>Aim: Predict the target variable, given the predictor variables</p>

<p>Classification: Target variable consists of categories</p>

<p>Regression: Target variable is continuous</p>

<p><strong>Unsupervised learning:</strong></p>

<p>Uncovering hidden patterns from unlabeled data</p>

<p>Example of unsupervised learning:</p>

<p>Grouping customers into distinct categories (Clustering)</p>

<p><strong>Reinforcement learning:</strong>
 Software agents interact with an environment</p>

<p>Learn how to optimize their behavior</p>

<p>Given a system of rewards and punishments</p>

<p>Applications</p>

<p>Economics</p>

<p>Genetics</p>

<p>Game playing (AlphaGo)</p>

<p>####
 Naming conventions</p>

<ul>
  <li>Features = predictor variables = independent variables</li>
  <li>Target variable = dependent variable = response variable</li>
</ul>

<hr />

<p>####
 Features of
 <strong>Supervised learning</strong></p>

<ul>
  <li>Automate time-consuming or expensive manual tasks (ex. Doctor’s diagnosis)</li>
  <li>Make predictions about the future (ex. Will a customer click on an ad or not)</li>
  <li>Need labeled data (Historical data with labels etc.)</li>
</ul>

<p>####
<strong>Popular libraries</strong></p>

<ul>
  <li>scikit-learning (basic)</li>
  <li>TensorFlow</li>
  <li>keras</li>
</ul>

<hr />

<p>###
<strong>Exploratory data analysis</strong></p>

<p>####
<strong>Numerical EDA</strong></p>

<p>In this chapter, you’ll be working with a dataset obtained from the
 <a href="https://archive.ics.uci.edu/ml/datasets/Congressional+Voting+Records">UCI Machine Learning Repository</a>
 consisting of votes made by US House of Representatives Congressmen.</p>

<p>Your goal will be to predict their party affiliation (‘Democrat’ or ‘Republican’) based on how they voted on certain key issues.</p>

<p>Here, it’s worth noting that we have preprocessed this dataset to deal with missing values. This is so that your focus can be directed towards understanding how to train and evaluate supervised learning models.</p>

<p>Once you have mastered these fundamentals, you will be introduced to preprocessing techniques in Chapter 4 and have the chance to apply them there yourself – including on this very same dataset!</p>

<p>Before thinking about what supervised learning models you can apply to this, however, you need to perform Exploratory data analysis (EDA) in order to understand the structure of the data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
        party  infants  water  budget  physician  salvador  religious  \
0  republican        0      1       0          1         1          1
1  republican        0      1       0          1         1          1
2    democrat        0      1       1          0         1          1
3    democrat        0      1       1          0         1          1
4    democrat        1      1       1          0         1          1

   satellite  aid  missile  immigration  synfuels  education  superfund  \
0          0    0        0            1         0          1          1
1          0    0        0            0         0          1          1
2          0    0        0            0         1          0          1
3          0    0        0            0         1          0          1
4          0    0        0            0         1          0          1

   crime  duty_free_exports  eaa_rsa
0      1                  0        1
1      1                  0        1
2      1                  0        0
3      0                  0        1
4      1                  1        1

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 435 entries, 0 to 434
Data columns (total 17 columns):
party                435 non-null object
infants              435 non-null int64
water                435 non-null int64
budget               435 non-null int64
physician            435 non-null int64
salvador             435 non-null int64
religious            435 non-null int64
satellite            435 non-null int64
aid                  435 non-null int64
missile              435 non-null int64
immigration          435 non-null int64
synfuels             435 non-null int64
education            435 non-null int64
superfund            435 non-null int64
crime                435 non-null int64
duty_free_exports    435 non-null int64
eaa_rsa              435 non-null int64
dtypes: int64(16), object(1)
memory usage: 57.9+ KB

</code></pre></div></div>

<p>###
<strong>Visual EDA</strong></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture-21.png" alt="Desktop View" /></p>

<p>Above is a
 <code class="language-plaintext highlighter-rouge">countplot</code>
 of the
 <code class="language-plaintext highlighter-rouge">'education'</code>
 bill, generated from the following code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.figure()
sns.countplot(x='education', hue='party', data=df, palette='RdBu')
plt.xticks([0,1], ['No', 'Yes'])
plt.show()

</code></pre></div></div>

<p>In
 <code class="language-plaintext highlighter-rouge">sns.countplot()</code>
 , we specify the x-axis data to be
 <code class="language-plaintext highlighter-rouge">'education'</code>
 , and hue to be
 <code class="language-plaintext highlighter-rouge">'party'</code>
 . Recall that
 <code class="language-plaintext highlighter-rouge">'party'</code>
 is also our target variable. So the resulting plot shows the difference in voting behavior between the two parties for the
 <code class="language-plaintext highlighter-rouge">'education'</code>
 bill, with each party colored differently. We manually specified the color to be
 <code class="language-plaintext highlighter-rouge">'RdBu'</code>
 , as the Republican party has been traditionally associated with red, and the Democratic party with blue.</p>

<p>It seems like Democrats voted resoundingly
 <em>against</em>
 this bill, compared to Republicans.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.figure()
sns.countplot(x='missile', hue='party', data=df, palette='RdBu')
plt.xticks([0,1], ['No', 'Yes'])
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture1-20.png" alt="Desktop View" /></p>

<p>Democrats vote resoundingly in
 <em>favor</em>
 of missile, compared to Republicans.</p>

<hr />

<p>###
<strong>The classification challenge</strong></p>

<p>####
<strong>k-Nearest Neighbors: Fit</strong></p>

<p><a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">k-nearest neighbors algorithm</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import KNeighborsClassifier from sklearn.neighbors
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="c1"># Create arrays for the features and the response variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'party'</span><span class="p">].</span><span class="n">values</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">'party'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>

<span class="c1"># Create a k-NN classifier with 6 neighbors
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

</code></pre></div></div>

<p>####
<strong>k-Nearest Neighbors: Predict</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import KNeighborsClassifier from sklearn.neighbors
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="c1"># Create arrays for the features and the response variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'party'</span><span class="p">]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">'party'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>

<span class="c1"># Create a k-NN classifier with 6 neighbors: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Predict the labels for the training data X
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># Predict and print the label for the new data point X_new
</span><span class="n">new_prediction</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Prediction: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">new_prediction</span><span class="p">))</span>

<span class="c1"># Prediction: ['democrat']
</span>
</code></pre></div></div>

<p>How sure can you be of its predictions? In other words, how can you measure its performance?</p>

<hr />

<p>###
<strong>Measuring model performance</strong></p>

<p>####
<strong>The digits recognition dataset: MNIST</strong></p>

<p>In the following exercises, you’ll be working with the
 <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>
 digits recognition dataset, which has 10 classes, the digits 0 through 9! A reduced version of the MNIST dataset is one of scikit-learn’s included datasets, and that is the one we will use in this exercise.</p>

<p>Each sample in this scikit-learn dataset is an 8×8 image representing a handwritten digit. Each pixel is represented by an integer in the range 0 to 16, indicating varying levels of black.</p>

<p>It is a famous dataset in machine learning and computer vision, and frequently used as a benchmark to evaluate the performance of a new model.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Load the digits dataset: digits
</span><span class="n">digits</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">.</span><span class="n">load_digits</span><span class="p">()</span>

<span class="c1"># Print the keys and DESCR of the dataset
</span><span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
<span class="c1">#dict_keys(['data', 'target', 'target_names', 'images', 'DESCR'])
</span>
<span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">DESCR</span><span class="p">)</span>
<span class="o">/*</span>
<span class="n">Optical</span> <span class="n">Recognition</span> <span class="n">of</span> <span class="n">Handwritten</span> <span class="n">Digits</span> <span class="n">Data</span> <span class="n">Set</span>
<span class="o">===================================================</span>

<span class="n">Notes</span>
<span class="o">-----</span>
<span class="n">Data</span> <span class="n">Set</span> <span class="n">Characteristics</span><span class="p">:</span>
    <span class="p">:</span><span class="n">Number</span> <span class="n">of</span> <span class="n">Instances</span><span class="p">:</span> <span class="mi">5620</span>
    <span class="p">:</span><span class="n">Number</span> <span class="n">of</span> <span class="n">Attributes</span><span class="p">:</span> <span class="mi">64</span>
    <span class="p">:</span><span class="n">Attribute</span> <span class="n">Information</span><span class="p">:</span> <span class="mi">8</span><span class="n">x8</span> <span class="n">image</span> <span class="n">of</span> <span class="n">integer</span> <span class="n">pixels</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">range</span> <span class="mf">0.</span><span class="p">.</span><span class="mf">16.</span>
    <span class="p">:</span><span class="n">Missing</span> <span class="n">Attribute</span> <span class="n">Values</span><span class="p">:</span> <span class="bp">None</span>
    <span class="p">:</span><span class="n">Creator</span><span class="p">:</span> <span class="n">E</span><span class="p">.</span> <span class="n">Alpaydin</span> <span class="p">(</span><span class="n">alpaydin</span> <span class="s">'@'</span> <span class="n">boun</span><span class="p">.</span><span class="n">edu</span><span class="p">.</span><span class="n">tr</span><span class="p">)</span>
    <span class="p">:</span><span class="n">Date</span><span class="p">:</span> <span class="n">July</span><span class="p">;</span> <span class="mi">1998</span>
<span class="p">...</span>
<span class="o">*/</span>

<span class="c1"># Print the shape of the images and data keys
</span><span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">images</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

<span class="c1"># Display digit 1010
</span><span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">images</span><span class="p">[</span><span class="mi">1010</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">gray_r</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">'nearest'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture2-19.png" alt="Desktop View" /></p>

<p>####
<strong>Train/Test Split + Fit/Predict/Accuracy</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Create feature and target arrays
</span><span class="n">X</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">data</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">target</span>

<span class="c1"># Split into training and test set
#  Stratify the split according to the labels so that they are distributed in the training and test sets as they are in the original dataset.
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

<span class="c1"># Create a k-NN classifier with 7 neighbors: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Print the accuracy
</span><span class="k">print</span><span class="p">(</span><span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
<span class="c1"># 0.983333333333
</span>
</code></pre></div></div>

<p>Incredibly, this out of the box k-NN classifier with 7 neighbors has learned from the training data and predicted the labels of the images in the test set with 98% accuracy, and it did so in less than a second! This is one illustration of how incredibly useful machine learning techniques can be.</p>

<hr />

<p>####
<strong>Overfitting and underfitting</strong></p>

<p>In this exercise, you will compute and plot the training and testing accuracy scores for a variety of different neighbor values. By observing how the accuracy scores differ for the training and testing sets with different values of k, you will develop your intuition for overfitting and underfitting.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup arrays to store train and test accuracies
</span><span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">train_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>
<span class="n">test_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>

<span class="c1"># Loop over different values of k
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
    <span class="c1"># Setup a k-NN Classifier with k neighbors: knn
</span>    <span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># Fit the classifier to the training data
</span>    <span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1">#Compute accuracy on the training set
</span>    <span class="n">train_accuracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1">#Compute accuracy on the testing set
</span>    <span class="n">test_accuracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

<span class="c1"># Generate plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'k-NN: Varying Number of Neighbors'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">test_accuracy</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Testing Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">train_accuracy</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Training Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Number of Neighbors'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture3-18.png" alt="Desktop View" /></p>

<p>It looks like the test accuracy is highest when using 3 and 5 neighbors. Using 8 neighbors or more seems to result in a simple model that underfits the data.</p>

<hr />

<h1 id="2-regression"><strong>2. Regression</strong></h1>
<hr />

<p>###
<strong>Introduction to regression</strong></p>

<p>####
<strong>Importing data for supervised learning</strong></p>

<p>In this chapter, you will work with
 <a href="https://www.gapminder.org/data/">Gapminder</a>
 data that we have consolidated into one CSV file available in the workspace as
 <code class="language-plaintext highlighter-rouge">'gapminder.csv'</code>
 . Specifically, your goal will be to use this data to predict the life expectancy in a given country based on features such as the country’s GDP, fertility rate, and population.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import numpy and pandas
</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Read the CSV file into a DataFrame: df
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'gapminder.csv'</span><span class="p">)</span>

<span class="c1"># Create arrays for features and target variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'life'</span><span class="p">].</span><span class="n">values</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'fertility'</span><span class="p">].</span><span class="n">values</span>

<span class="c1"># Print the dimensions of X and y before reshaping
</span><span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of y before reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of X before reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Dimensions of y before reshaping: (139,)
# Dimensions of X before reshaping: (139,)
</span>

<span class="c1"># Reshape X and y
</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the dimensions of X and y after reshaping
</span><span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of y after reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of X after reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Dimensions of y after reshaping: (139, 1)
# Dimensions of X after reshaping: (139, 1)
</span>
</code></pre></div></div>

<p>####
<strong>Exploring the Gapminder data</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 139 entries, 0 to 138
Data columns (total 9 columns):
population         139 non-null float64
fertility          139 non-null float64
HIV                139 non-null float64
CO2                139 non-null float64
BMI_male           139 non-null float64
GDP                139 non-null float64
BMI_female         139 non-null float64
life               139 non-null float64
child_mortality    139 non-null float64
dtypes: float64(9)
memory usage: 9.9 KB

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
sns.heatmap(df.corr(), square=True, cmap='RdYlGn')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture4-17.png" alt="Desktop View" /></p>

<p>###
<strong>The basics of linear regression</strong></p>

<p>We suppose that y and x have a linear relationship that can be model by</p>

<p>y = ax + b</p>

<p>An linear regression is to find a, b that minimize the sum of the squared residual (= Ordinary Least Squares, OLS)</p>

<p>Why squared residual?</p>

<p>Residuals may be positive and negative.</p>

<p>They cancel each other. square residual can solve this problem.</p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture6-11.png" alt="Desktop View" /></p>

<p>green lines are residuals</p>

<p>When we have n variables of x,</p>

<p>y = a1<em>x1 + a2</em>x2 + … an*xn + b</p>

<p>we find a1, a2, … an, b that minimize the sum of the squared residual.</p>

<p>####
<strong>Fit &amp; predict for regression</strong></p>

<p>In this exercise, you will use the
 <code class="language-plaintext highlighter-rouge">'fertility'</code>
 feature of the Gapminder dataset. Since the goal is to predict life expectancy, the target variable here is
 <code class="language-plaintext highlighter-rouge">'life'</code>
 .</p>

<p>You will also compute and print the R2 score using sckit-learn’s
 <code class="language-plaintext highlighter-rouge">.score()</code>
 method.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import LinearRegression
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="c1"># Create the regressor: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Create the prediction space
</span><span class="n">prediction_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">)).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Fit the model to the data
</span><span class="n">reg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Compute predictions over the prediction space: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">prediction_space</span><span class="p">)</span>

<span class="c1"># Print R^2
</span><span class="k">print</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="mf">0.619244216774</span>

<span class="c1"># Plot regression line
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">prediction_space</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'black'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture7-12.png" alt="Desktop View" /></p>

<p>####
<strong>Train/test split for regression</strong></p>

<p>In this exercise, you will split the Gapminder dataset into training and testing sets, and then fit and predict a linear regression over
 <strong>all</strong>
 features. In addition to computing the R2 score, you will also compute the Root Mean Squared Error (RMSE), which is another commonly used metric to evaluate regression models.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the regressor: reg_all
</span><span class="n">reg_all</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Fit the regressor to the training data
</span><span class="n">reg_all</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict on the test data: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg_all</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print R^2 and RMSE
</span><span class="k">print</span><span class="p">(</span><span class="s">"R^2: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">reg_all</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="c1"># R^2: 0.838046873142936
</span>

<span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Root Mean Squared Error: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">rmse</span><span class="p">))</span>
<span class="c1"># Root Mean Squared Error: 3.2476010800377213
</span>

</code></pre></div></div>

<p>###
<strong>Cross-validation</strong></p>

<p>What is cross validation?</p>

<p><a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)">https://en.wikipedia.org/wiki/Cross-validation_(statistics)</a></p>

<p>####
<strong>5-fold cross-validation</strong></p>

<p>In this exercise, you will practice 5-fold cross validation on the Gapminder data. By default, scikit-learn’s
 <code class="language-plaintext highlighter-rouge">cross_val_score()</code>
 function uses R2R2 as the metric of choice for regression.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Create a linear regression object: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Compute 5-fold cross-validation scores: cv_scores
</span><span class="n">cv_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Print the 5-fold cross-validation scores
</span><span class="k">print</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)</span>
<span class="c1"># [ 0.81720569  0.82917058  0.90214134  0.80633989  0.94495637]
</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Average 5-Fold CV Score: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)))</span>
<span class="c1"># Average 5-Fold CV Score: 0.8599627722793232
</span>
</code></pre></div></div>

<p>####
<strong>K-Fold CV comparison</strong></p>

<p>Cross validation is essential but do not forget that the more folds you use, the more computationally expensive cross-validation becomes. In this exercise, you will explore this for yourself. Your job is to perform 3-fold cross-validation and then 10-fold cross-validation on the Gapminder dataset.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Create a linear regression object: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Perform 3-fold CV
</span><span class="n">cvscores_3</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvscores_3</span><span class="p">))</span>
<span class="c1"># 0.871871278262
</span>
<span class="c1"># Perform 10-fold CV
</span><span class="n">cvscores_10</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvscores_10</span><span class="p">))</span>
<span class="c1"># 0.843612862013
</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
%timeit cross_val_score(reg, X, y, cv=3)
100 loops, best of 3: 8.73 ms per loop

%timeit cross_val_score(reg, X, y, cv=10)
10 loops, best of 3: 27.5 ms per loop

</code></pre></div></div>

<hr />

<p>###
<strong>Regularized regression</strong></p>

<p>####
<strong><a href="https://en.wikipedia.org/wiki/Lasso_(statistics)">Regularization I: Lasso</a></strong></p>

<p>In this exercise, you will fit a lasso regression to the Gapminder data you have been working with and plot the coefficients. Just as with the Boston data, you will find that the coefficients of some features are shrunk to 0, with only the most important ones remaining.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.columns
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality'],
      dtype='object')

X: ['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'child_mortality']
y: life

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import Lasso
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Lasso</span>

<span class="c1"># Instantiate a lasso regressor: lasso
</span><span class="n">lasso</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Fit the regressor to the data
</span><span class="n">lasso</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Compute and print the coefficients
</span><span class="n">lasso_coef</span> <span class="o">=</span> <span class="n">lasso</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">).</span><span class="n">coef_</span>
<span class="k">print</span><span class="p">(</span><span class="n">lasso_coef</span><span class="p">)</span>
<span class="c1">#  [-0.         -0.         -0.          0.          0.          0.         -0.
</span>     <span class="o">-</span><span class="mf">0.07087587</span><span class="p">]</span>


<span class="c1"># Plot the coefficients
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_columns</span><span class="p">)),</span> <span class="n">lasso_coef</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_columns</span><span class="p">)),</span> <span class="n">df_columns</span><span class="p">.</span><span class="n">values</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture8-9.png" alt="Desktop View" /></p>

<p>According to the lasso algorithm, it seems like
 <code class="language-plaintext highlighter-rouge">'child_mortality'</code>
 is the most important feature when predicting life expectancy.</p>

<p>####
<strong>Regularization II: Ridge</strong></p>

<p>Lasso is great for feature selection, but when building regression models, Ridge regression should be your first choice.</p>

<p>Recall that lasso performs regularization by adding to the loss function a penalty term of the
 <em>absolute</em>
 value of each coefficient multiplied by some alpha. This is also known as L1L1 regularization because the regularization term is the L1L1 norm of the coefficients. This is not the only way to regularize, however.</p>

<p>If instead you took the sum of the
 <em>squared</em>
 values of the coefficients multiplied by some alpha – like in Ridge regression – you would be computing the L2L2norm. In this exercise, you will practice fitting ridge regression models over a range of different alphas, and plot cross-validated R2R2 scores for each, using this function that we have defined for you, which plots the R2R2 score as well as standard error for each alpha:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def display_plot(cv_scores, cv_scores_std):
    fig = plt.figure()
    ax = fig.add_subplot(1,1,1)
    ax.plot(alpha_space, cv_scores)

    std_error = cv_scores_std / np.sqrt(10)

    ax.fill_between(alpha_space, cv_scores + std_error, cv_scores - std_error, alpha=0.2)
    ax.set_ylabel('CV Score +/- Std Error')
    ax.set_xlabel('Alpha')
    ax.axhline(np.max(cv_scores), linestyle='--', color='.5')
    ax.set_xlim([alpha_space[0], alpha_space[-1]])
    ax.set_xscale('log')
    plt.show()


</code></pre></div></div>

<p>Don’t worry about the specifics of the above function works. The motivation behind this exercise is for you to see how the R2R2 score varies with different alphas, and to understand the importance of selecting the right value for alpha. You’ll learn how to tune alpha in the next chapter.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Setup the array of alphas and lists to store scores
</span><span class="n">alpha_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">ridge_scores</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ridge_scores_std</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Create a ridge regressor: ridge
</span><span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Compute scores over range of alphas
</span><span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">alpha_space</span><span class="p">:</span>

    <span class="c1"># Specify the alpha value to use: ridge.alpha
</span>    <span class="n">ridge</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="c1"># Perform 10-fold CV: ridge_cv_scores
</span>    <span class="n">ridge_cv_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="c1"># Append the mean of ridge_cv_scores to ridge_scores
</span>    <span class="n">ridge_scores</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ridge_cv_scores</span><span class="p">))</span>

    <span class="c1"># Append the std of ridge_cv_scores to ridge_scores_std
</span>    <span class="n">ridge_scores_std</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">ridge_cv_scores</span><span class="p">))</span>

<span class="c1"># Display the plot
</span><span class="n">display_plot</span><span class="p">(</span><span class="n">ridge_scores</span><span class="p">,</span> <span class="n">ridge_scores_std</span><span class="p">)</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture9-8.png" alt="Desktop View" /></p>

<p>Notice how the cross-validation scores change with different alphas.</p>

<hr />

<h1 id="3-fine-tuning-your-model"><strong>3. Fine-tuning your model</strong></h1>
<hr />

<p>###
<strong>confusion matrix</strong></p>

<p>What is confusion matrix</p>

<p><a href="https://en.wikipedia.org/wiki/Confusion_matrix">https://en.wikipedia.org/wiki/Confusion_matrix</a></p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f02ea353bf60bfdd9557d2c98fe18c34cd8db835" alt="{\displaystyle \mathrm {TPR} ={\frac {\mathrm {TP} }{\mathrm {P} }}={\frac {\mathrm {TP} }{\mathrm {TP} +\mathrm {FN} }}=1-\mathrm {FNR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">sensitivity</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Precision_and_recall#Recall">recall</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Hit_rate">hit rate</a>
 , or
 <a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">true positive rate</a>
 (TPR)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8f2c867f0641e498ec8a59de63697a3a45d66b07" alt="{\displaystyle \mathrm {TNR} ={\frac {\mathrm {TN} }{\mathrm {N} }}={\frac {\mathrm {TN} }{\mathrm {TN} +\mathrm {FP} }}=1-\mathrm {FPR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Specificity_(tests)">specificity</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Specificity_(tests)">selectivity</a>
 or
 <a href="https://en.wikipedia.org/wiki/Specificity_(tests)">true negative rate</a>
 (TNR)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d854b1544fc77735d575ce0d30e34d7f1eacf707" alt="{\displaystyle \mathrm {PPV} ={\frac {\mathrm {TP} }{\mathrm {TP} +\mathrm {FP} }}=1-\mathrm {FDR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision">precision</a>
 or
 <a href="https://en.wikipedia.org/wiki/Positive_predictive_value">positive predictive value</a>
 (PPV)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47deb47eb7ac214423d0a6afd05ec0af362fef9b" alt="{\displaystyle \mathrm {ACC} ={\frac {\mathrm {TP} +\mathrm {TN} }{\mathrm {P} +\mathrm {N} }}={\frac {\mathrm {TP} +\mathrm {TN} }{\mathrm {TP} +\mathrm {TN} +\mathrm {FP} +\mathrm {FN} }}}" /></p>

<p><a href="https://en.wikipedia.org/wiki/Accuracy">accuracy</a>
 (ACC)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0e5f071c6418f444fadc9f5f9b0358beed3e094c" alt="{\displaystyle \mathrm {F} _{1}=2\cdot {\frac {\mathrm {PPV} \cdot \mathrm {TPR} }{\mathrm {PPV} +\mathrm {TPR} }}={\frac {2\mathrm {TP} }{2\mathrm {TP} +\mathrm {FP} +\mathrm {FN} }}}" /></p>

<p><a href="https://en.wikipedia.org/wiki/F1_score">F1 score</a>
 is the
 <a href="https://en.wikipedia.org/wiki/Harmonic_mean#Harmonic_mean_of_two_numbers">harmonic mean</a>
 of
 <a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision">precision</a>
 and
 <a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">sensitivity</a></p>

<p>####
<strong>illustration for TPR, TNR and PPV</strong></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/metric_example.png?w=1024" alt="Desktop View" /></p>

<p><a href="http://corysimon.github.io/articles/classification-metrics/">source</a></p>

<p>####
<strong>Metrics for classification</strong></p>

<p>In this exercise, you will dive more deeply into evaluating the performance of binary classifiers by computing a confusion matrix and generating a classification report.</p>

<p>Here, you’ll work with the
 <a href="https://www.kaggle.com/uciml/pima-indians-diabetes-database">PIMA Indians</a>
 dataset obtained from the UCI Machine Learning Repository. The goal is to predict whether or not a given female patient will contract diabetes based on features such as BMI, age, and number of pregnancies.</p>

<p>Therefore, it is a binary classification problem. A target value of
 <code class="language-plaintext highlighter-rouge">0</code>
 indicates that the patient does
 <em>not</em>
 have diabetes, while a value of
 <code class="language-plaintext highlighter-rouge">1</code>
 indicates that the patient
 <em>does</em>
 have diabetes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 768 entries, 0 to 767
Data columns (total 9 columns):
pregnancies    768 non-null int64
glucose        768 non-null int64
diastolic      768 non-null int64
triceps        768 non-null float64
insulin        768 non-null float64
bmi            768 non-null float64
dpf            768 non-null float64
age            768 non-null int64
diabetes       768 non-null int64
dtypes: float64(4), int64(5)
memory usage: 54.1 KB

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>

<span class="c1"># Create training and test set
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Instantiate a k-NN classifier: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test data: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Generate the confusion matrix and classification report
</span><span class="k">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[[176  30]
 [ 52  50]]

             precision    recall  f1-score   support

          0       0.77      0.85      0.81       206
          1       0.62      0.49      0.55       102

avg / total       0.72      0.73      0.72       308

</code></pre></div></div>

<hr />

<p>###
<strong>Logistic regression and the ROC curve</strong></p>

<p>What is logistic regression?</p>

<p><a href="https://en.wikipedia.org/wiki/Logistic_regression">https://en.wikipedia.org/wiki/Logistic_regression</a></p>

<p>What is ROC?</p>

<p><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">Receiver operating characteristic</a></p>

<p>Further Reading:
 <a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.html#sphx-glr-auto-examples-model-selection-plot-roc-py">scikit-learn document</a></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/roc_space-2.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Building a logistic regression model</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
X.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 768 entries, 0 to 767
Data columns (total 8 columns):
pregnancies    768 non-null int64
glucose        768 non-null int64
diastolic      768 non-null int64
triceps        768 non-null float64
insulin        768 non-null float64
bmi            768 non-null float64
dpf            768 non-null float64
age            768 non-null int64
dtypes: float64(4), int64(4)
memory usage: 48.1 KB


y
0      1
1      0
2      1
      ..

765    0
766    1
767    0
Name: diabetes, dtype: int64

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span><span class="p">,</span> <span class="n">confusion_matrix</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">logreg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print the confusion matrix and classification report
</span><span class="k">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[[176  30]
 [ 35  67]]

             precision    recall  f1-score   support

          0       0.83      0.85      0.84       206
          1       0.69      0.66      0.67       102

avg / total       0.79      0.79      0.79       308

</code></pre></div></div>

<p>####
<strong>Plotting an ROC curve</strong></p>

<p><strong>.predict_proba()</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>

<span class="c1"># Compute predicted probabilities: y_pred_prob
</span><span class="n">y_pred_prob</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Generate ROC curve values: fpr, tpr, thresholds
</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_prob</span><span class="p">)</span>

<span class="c1"># Plot ROC curve
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s">'k--'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'False Positive Rate'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'True Positive Rate'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'ROC Curve'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
logreg.predict_proba(X_test)
# False, True
# 0, 1
# Negative, Positive
array([[ 0.60409835,  0.39590165],
       [ 0.76042394,  0.23957606],
       [ 0.79670177,  0.20329823],
       ...
       [ 0.84686912,  0.15313088],
       [ 0.97617225,  0.02382775],
       [ 0.40380502,  0.59619498]])

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture1-21.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Precision-recall Curve</strong></p>

<p>There are other ways to visually evaluate model performance. One such way is the precision-recall curve, which is generated by plotting the precision and recall for different thresholds.</p>

<p>Note that here, the class is positive (1) if the individual
 <em>has</em>
 diabetes.</p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture2-20.png?w=1024" alt="Desktop View" /></p>

<ul>
  <li>A recall of 1 corresponds to a classifier with a low threshold in which
 <em>all</em>
 females who contract diabetes were correctly classified as such, at the expense of many misclassifications of those who did
 <em>not</em>
 have diabetes.</li>
  <li>Precision is undefined for a classifier which makes
 <em>no</em>
 positive predictions, that is, classifies
 <em>everyone</em>
 as
 <em>not</em>
 having diabetes.</li>
  <li>When the threshold is very close to 1, precision is also 1, because the classifier is absolutely certain about its predictions.</li>
</ul>

<p>recall or sensitivity, TPR = 1 means all true positive are detected. We can predict all to positive to get a recall of 1.</p>

<p>precision, PPV = 1 means no false positive are detected. We can predict less positive to get a higher precision.</p>

<p>####
<strong>Area under the ROC curve</strong></p>

<p>####
<strong>AUC(</strong>
 Area Under the Curve
 <strong>) computation</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span><span class="n">df</span><span class="p">.</span><span class="n">head</span><span class="p">()</span>
   <span class="n">pregnancies</span>  <span class="n">glucose</span>  <span class="n">diastolic</span>   <span class="n">triceps</span>     <span class="n">insulin</span>   <span class="n">bmi</span>    <span class="n">dpf</span>  <span class="n">age</span>  \
<span class="mi">0</span>            <span class="mi">6</span>      <span class="mi">148</span>         <span class="mi">72</span>  <span class="mf">35.00000</span>  <span class="mf">155.548223</span>  <span class="mf">33.6</span>  <span class="mf">0.627</span>   <span class="mi">50</span>
<span class="mi">1</span>            <span class="mi">1</span>       <span class="mi">85</span>         <span class="mi">66</span>  <span class="mf">29.00000</span>  <span class="mf">155.548223</span>  <span class="mf">26.6</span>  <span class="mf">0.351</span>   <span class="mi">31</span>
<span class="mi">2</span>            <span class="mi">8</span>      <span class="mi">183</span>         <span class="mi">64</span>  <span class="mf">29.15342</span>  <span class="mf">155.548223</span>  <span class="mf">23.3</span>  <span class="mf">0.672</span>   <span class="mi">32</span>
<span class="mi">3</span>            <span class="mi">1</span>       <span class="mi">89</span>         <span class="mi">66</span>  <span class="mf">23.00000</span>   <span class="mf">94.000000</span>  <span class="mf">28.1</span>  <span class="mf">0.167</span>   <span class="mi">21</span>
<span class="mi">4</span>            <span class="mi">0</span>      <span class="mi">137</span>         <span class="mi">40</span>  <span class="mf">35.00000</span>  <span class="mf">168.000000</span>  <span class="mf">43.1</span>  <span class="mf">2.288</span>   <span class="mi">33</span>

   <span class="n">diabetes</span>
<span class="mi">0</span>         <span class="mi">1</span>
<span class="mi">1</span>         <span class="mi">0</span>
<span class="mi">2</span>         <span class="mi">1</span>
<span class="mi">3</span>         <span class="mi">0</span>
<span class="mi">4</span>         <span class="mi">1</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Compute predicted probabilities: y_pred_prob
</span><span class="n">y_pred_prob</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Compute and print AUC score
</span><span class="k">print</span><span class="p">(</span><span class="s">"AUC: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_prob</span><span class="p">)))</span>

<span class="c1"># Compute cross-validated AUC scores: cv_auc
</span><span class="n">cv_auc</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'roc_auc'</span><span class="p">)</span>

<span class="c1"># Print list of AUC scores
</span><span class="k">print</span><span class="p">(</span><span class="s">"AUC scores computed using 5-fold cross-validation: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv_auc</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
AUC: 0.8254806777079764

AUC scores computed using 5-fold cross-validation:
[ 0.80148148  0.8062963   0.81481481  0.86245283  0.8554717 ]

</code></pre></div></div>

<hr />

<p>###
<strong>Hyperparameter tuning</strong></p>

<p>####
<strong>Hyperparameter tuning with GridSearchCV</strong></p>

<p>You will now practice this yourself, but by using logistic regression on the diabetes dataset.</p>

<p>Like the alpha parameter of lasso and ridge regularization that you saw earlier, logistic regression also has a regularization parameter: CC. CC controls the
 <em>inverse</em>
 of the regularization strength, and this is what you will tune in this exercise. A large CC can lead to an
 <em>overfit</em>
 model, while a small CC can lead to an
 <em>underfit</em>
 model.</p>

<p>The hyperparameter space for CC has been setup for you. Your job is to use GridSearchCV and logistic regression to find the optimal CC in this hyperparameter space.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="c1"># Setup the hyperparameter grid
</span><span class="n">c_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'C'</span><span class="p">:</span> <span class="n">c_space</span><span class="p">}</span>

<span class="c1"># Instantiate a logistic regression classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Instantiate the GridSearchCV object: logreg_cv
</span><span class="n">logreg_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the data
</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Print the tuned parameters and score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Best score is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Logistic Regression Parameters: {'C': 3.7275937203149381}
Best score is 0.7708333333333334

</code></pre></div></div>

<p>####
<strong>Hyperparameter tuning with RandomizedSearchCV</strong></p>

<p>GridSearchCV can be computationally expensive, especially if you are searching over a large hyperparameter space and dealing with multiple hyperparameters. A solution to this is to use
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 , in which not all hyperparameter values are tried out. Instead, a fixed number of hyperparameter settings is sampled from specified probability distributions. You’ll practice using
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 in this exercise and see how this works.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">RandomizedSearchCV</span>

<span class="c1"># Setup the parameters and distributions to sample from: param_dist
</span><span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s">"max_depth"</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
              <span class="s">"max_features"</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="s">"min_samples_leaf"</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="s">"criterion"</span><span class="p">:</span> <span class="p">[</span><span class="s">"gini"</span><span class="p">,</span> <span class="s">"entropy"</span><span class="p">]}</span>

<span class="c1"># Instantiate a Decision Tree classifier: tree
</span><span class="n">tree</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">()</span>

<span class="c1"># Instantiate the RandomizedSearchCV object: tree_cv
</span><span class="n">tree_cv</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">param_dist</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the data
</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Print the tuned parameters and score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Decision Tree Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Best score is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Decision Tree Parameters: {'criterion': 'entropy', 'max_depth': 3, 'max_features': 7, 'min_samples_leaf': 1}
Best score is 0.7317708333333334

</code></pre></div></div>

<p>Note that
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 will never outperform
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 . Instead, it is valuable because it saves on computation time.</p>

<p>###
<strong>Hold-out set for final evaluation</strong></p>

<p>####
<strong>Hold-out set in practice I: Classification</strong></p>

<p>In addition to CC, logistic regression has a
 <code class="language-plaintext highlighter-rouge">'penalty'</code>
 hyperparameter which specifies whether to use
 <code class="language-plaintext highlighter-rouge">'l1'</code>
 or
 <code class="language-plaintext highlighter-rouge">'l2'</code>
 regularization. Your job in this exercise is to create a hold-out set, tune the
 <code class="language-plaintext highlighter-rouge">'C'</code>
 and
 <code class="language-plaintext highlighter-rouge">'penalty'</code>
 hyperparameters of a logistic regression classifier using
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 on the training set.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="c1"># Create the hyperparameter grid
</span><span class="n">c_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'C'</span><span class="p">:</span> <span class="n">c_space</span><span class="p">,</span> <span class="s">'penalty'</span><span class="p">:</span> <span class="p">[</span><span class="s">'l1'</span><span class="p">,</span> <span class="s">'l2'</span><span class="p">]}</span>

<span class="c1"># Instantiate the logistic regression classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Instantiate the GridSearchCV object: logreg_cv
</span><span class="n">logreg_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the training data
</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Print the optimal parameters and best score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Parameter: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Accuracy: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Logistic Regression Parameter: {'C': 0.43939705607607948, 'penalty': 'l1'}
Tuned Logistic Regression Accuracy: 0.7652173913043478

</code></pre></div></div>

<p>####
<strong>Hold-out set in practice II: Regression</strong></p>

<p>Remember lasso and ridge regression from the previous chapter? Lasso used the L1 penalty to regularize, while ridge used the L2 penalty. There is another type of regularized regression known as the elastic net. In elastic net regularization, the penalty term is a linear combination of the L1 and L2 penalties:</p>

<p><strong>a∗L1+b∗L2</strong></p>

<p>In scikit-learn, this term is represented by the
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 parameter: An
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 of
 <code class="language-plaintext highlighter-rouge">1</code>
 corresponds to an L1L1 penalty, and anything lower is a combination of L1L1 and L2L2.</p>

<p>In this exercise, you will
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 to tune the
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 of an elastic net model trained on the Gapminder data. As in the previous exercise, use a hold-out set to evaluate your model’s performance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5
3   2975029.0       1.40  0.1   1.804106  25.35542   7383.0    132.8108  72.5
4  21370348.0       1.96  0.1  18.016313  27.56373  41312.0    117.3755  81.5

   child_mortality
0             29.5
1            192.0
2             15.4
3             20.0
4              5.2


</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">ElasticNet</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">train_test_split</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the hyperparameter grid
</span><span class="n">l1_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'l1_ratio'</span><span class="p">:</span> <span class="n">l1_space</span><span class="p">}</span>

<span class="c1"># Instantiate the ElasticNet regressor: elastic_net
</span><span class="n">elastic_net</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">()</span>

<span class="c1"># Setup the GridSearchCV object: gm_cv
</span><span class="n">gm_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">elastic_net</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the training data
</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict on the test set and compute metrics
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">r2</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="n">mse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet l1 ratio: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet R squared: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet MSE: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">mse</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned ElasticNet l1 ratio: {'l1_ratio': 0.20689655172413793}
Tuned ElasticNet R squared: 0.8668305372460283
Tuned ElasticNet MSE: 10.05791413339844

</code></pre></div></div>

<hr />

<h2 id="preprocessing-and-pipelines"><strong>Preprocessing and pipelines</strong></h2>

<p>###
<strong>Preprocessing data</strong></p>

<p>####
<strong>Exploring categorical features</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5
3   2975029.0       1.40  0.1   1.804106  25.35542   7383.0    132.8108  72.5
4  21370348.0       1.96  0.1  18.016313  27.56373  41312.0    117.3755  81.5

   child_mortality                      Region
0             29.5  Middle East &amp; North Africa
1            192.0          Sub-Saharan Africa
2             15.4                     America
3             20.0       Europe &amp; Central Asia
4              5.2         East Asia &amp; Pacific

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import pandas
</span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Read 'gapminder.csv' into a DataFrame: df
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'gapminder.csv'</span><span class="p">)</span>

<span class="c1"># Create a boxplot of life expectancy per region
</span><span class="n">df</span><span class="p">.</span><span class="n">boxplot</span><span class="p">(</span><span class="s">'life'</span><span class="p">,</span> <span class="s">'Region'</span><span class="p">,</span> <span class="n">rot</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture3-19.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Creating dummy variables</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create dummy variables: df_region
</span><span class="n">df_region</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Print the columns of df_region
</span><span class="k">print</span><span class="p">(</span><span class="n">df_region</span><span class="p">.</span><span class="n">columns</span><span class="p">)</span>

<span class="c1"># Create dummy variables with drop_first=True: df_region
</span><span class="n">df_region</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">drop_first</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Print the new columns of df_region
</span><span class="k">print</span><span class="p">(</span><span class="n">df_region</span><span class="p">.</span><span class="n">columns</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality', 'Region_America',
       'Region_East Asia &amp; Pacific', 'Region_Europe &amp; Central Asia',
       'Region_Middle East &amp; North Africa', 'Region_South Asia',
       'Region_Sub-Saharan Africa'],
      dtype='object')

# Region_America has been dropped
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality', 'Region_East Asia &amp; Pacific',
       'Region_Europe &amp; Central Asia', 'Region_Middle East &amp; North Africa',
       'Region_South Asia', 'Region_Sub-Saharan Africa'],
      dtype='object')


df_region.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5

   child_mortality  Region_East Asia &amp; Pacific  Region_Europe &amp; Central Asia  \
0             29.5                           0                             0
1            192.0                           0                             0
2             15.4                           0                             0

   Region_Middle East &amp; North Africa  Region_South Asia  \
0                                  1                  0
1                                  0                  0
2                                  0                  0

   Region_Sub-Saharan Africa
0                          0
1                          1
2                          0

</code></pre></div></div>

<p>####
<strong>Regression with categorical features</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Instantiate a ridge regressor: ridge
</span><span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Perform 5-fold cross-validation: ridge_cv
</span><span class="n">ridge_cv</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Print the cross-validated scores
</span><span class="k">print</span><span class="p">(</span><span class="n">ridge_cv</span><span class="p">)</span>
<span class="p">[</span> <span class="mf">0.86808336</span>  <span class="mf">0.80623545</span>  <span class="mf">0.84004203</span>  <span class="mf">0.7754344</span>   <span class="mf">0.87503712</span><span class="p">]</span>

</code></pre></div></div>

<hr />

<p>###
<strong>Handling missing data</strong></p>

<p>####
<strong>Dropping missing data</strong></p>

<p>Now, it’s time for you to take care of these yourself!</p>

<p>The unprocessed dataset has been loaded into a DataFrame
 <code class="language-plaintext highlighter-rouge">df</code>
 . Explore it in the IPython Shell with the
 <code class="language-plaintext highlighter-rouge">.head()</code>
 method. You will see that there are certain data points labeled with a
 <code class="language-plaintext highlighter-rouge">'?'</code>
 . These denote missing values. As you saw in the video, different datasets encode missing values in different ways. Sometimes it may be a
 <code class="language-plaintext highlighter-rouge">'9999'</code>
 , other times a
 <code class="language-plaintext highlighter-rouge">0</code>
 – real-world data can be very messy! If you’re lucky, the missing values will already be encoded as
 <code class="language-plaintext highlighter-rouge">NaN</code>
 . We use
 <code class="language-plaintext highlighter-rouge">NaN</code>
 because it is an efficient and simplified way of internally representing missing data, and it lets us take advantage of pandas methods such as
 <code class="language-plaintext highlighter-rouge">.dropna()</code>
 and
 <code class="language-plaintext highlighter-rouge">.fillna()</code>
 , as well as scikit-learn’s Imputation transformer
 <code class="language-plaintext highlighter-rouge">Imputer()</code>
 .</p>

<p>In this exercise, your job is to convert the
 <code class="language-plaintext highlighter-rouge">'?'</code>
 s to NaNs, and then drop the rows that contain them from the DataFrame.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head(3)
        party infants water budget physician salvador religious satellite aid  \
0  republican       0     1      0         1        1         1         0   0
1  republican       0     1      0         1        1         1         0   0
2    democrat       ?     1      1         ?        1         1         0   0

  missile immigration synfuels education superfund crime duty_free_exports  \
0       0           1        ?         1         1     1                 0
1       0           0        0         1         1     1                 0
2       0           0        1         0         1     1                 0

  eaa_rsa
0       1
1       ?
2       0

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Convert '?' to NaN
</span><span class="n">df</span><span class="p">[</span><span class="n">df</span> <span class="o">==</span> <span class="s">'?'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">nan</span>

<span class="c1"># Print the number of NaNs
</span><span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">isnull</span><span class="p">().</span><span class="nb">sum</span><span class="p">())</span>

<span class="c1"># Print shape of original DataFrame
</span><span class="k">print</span><span class="p">(</span><span class="s">"Shape of Original DataFrame: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Drop missing values and print shape of new DataFrame
</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">dropna</span><span class="p">()</span>

<span class="c1"># Print shape of new DataFrame
</span><span class="k">print</span><span class="p">(</span><span class="s">"Shape of DataFrame After Dropping All Rows with Missing Values: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
party                  0
infants               12
water                 48
budget                11
physician             11
salvador              15
religious             11
satellite             14
aid                   15
missile               22
immigration            7
synfuels              21
education             31
superfund             25
crime                 17
duty_free_exports     28
eaa_rsa              104
dtype: int64
Shape of Original DataFrame: (435, 17)


Shape of DataFrame After Dropping All Rows with Missing Values: (232, 17)

</code></pre></div></div>

<p>When many values in your dataset are missing, if you drop them, you may end up throwing away valuable information along with the missing data. It’s better instead to develop an imputation strategy. This is where domain knowledge is useful, but in the absence of it, you can impute missing values with the mean or the median of the row or column that the missing value is in.</p>

<p>####
<strong>Imputing missing data in a ML Pipeline I</strong></p>

<p>As you’ve come to appreciate, there are many steps to building a model, from creating training and test sets, to fitting a classifier or regressor, to tuning its parameters, to evaluating its performance on new data. Imputation can be seen as the first step of this machine learning process, the entirety of which can be viewed within the context of a pipeline. Scikit-learn provides a pipeline constructor that allows you to piece together these steps into one process and thereby simplify your workflow.</p>

<p>You’ll now practice setting up a pipeline with two steps: the imputation step, followed by the instantiation of a classifier. You’ve seen three classifiers in this course so far: k-NN, logistic regression, and the decision tree. You will now be introduced to a fourth one – the Support Vector Machine, or
 <a href="http://scikit-learn.org/stable/modules/svm.html">SVM</a>
 .</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the Imputer module
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Imputer</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Setup the Imputation transformer: imp
# axis=0 for column
</span><span class="n">imp</span> <span class="o">=</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'most_frequent'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Instantiate the SVC classifier: clf
</span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">()</span>

<span class="c1"># Setup the pipeline with the required steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">imp</span><span class="p">),</span>
        <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">clf</span><span class="p">)]</span>

</code></pre></div></div>

<p>####
<strong>Imputing missing data in a ML Pipeline II</strong></p>

<p>Having setup the steps of the pipeline in the previous exercise, you will now use it on the voting dataset to classify a Congressman’s party affiliation.</p>

<p>What makes pipelines so incredibly useful is the simple interface that they provide. You can use the
 <code class="language-plaintext highlighter-rouge">.fit()</code>
 and
 <code class="language-plaintext highlighter-rouge">.predict()</code>
 methods on pipelines just as you did with your classifiers and regressors!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Imputer</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'most_frequent'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Fit the pipeline to the train set
</span><span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute metrics
</span><span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
             precision    recall  f1-score   support

   democrat       0.99      0.96      0.98        85
 republican       0.94      0.98      0.96        46

avg / total       0.97      0.97      0.97       131

</code></pre></div></div>

<p>###
<strong>Centering and scaling</strong></p>

<p>####
<strong>Centering and scaling your data</strong></p>

<p>You will now explore scaling for yourself on a new dataset –
 <a href="https://archive.ics.uci.edu/ml/datasets/Wine+Quality">White Wine Quality</a>
 !</p>

<p>We have used the
 <code class="language-plaintext highlighter-rouge">'quality'</code>
 feature of the wine to create a binary target variable: If
 <code class="language-plaintext highlighter-rouge">'quality'</code>
 is less than
 <code class="language-plaintext highlighter-rouge">5</code>
 , the target variable is
 <code class="language-plaintext highlighter-rouge">1</code>
 , and otherwise, it is
 <code class="language-plaintext highlighter-rouge">0</code>
 .</p>

<p>Notice how some features seem to have different units of measurement.
 <code class="language-plaintext highlighter-rouge">'density'</code>
 , for instance, takes values between 0.98 and 1.04, while
 <code class="language-plaintext highlighter-rouge">'total sulfur dioxide'</code>
 ranges from 9 to 440. As a result, it may be worth scaling the features here. Your job in this exercise is to scale the features and compute the mean and standard deviation of the unscaled features compared to the scaled features.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># white wine quality data set
</span><span class="n">df</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">fixed</span> <span class="n">acidity</span>  <span class="n">volatile</span> <span class="n">acidity</span>  <span class="n">citric</span> <span class="n">acid</span>  <span class="n">residual</span> <span class="n">sugar</span>  <span class="n">chlorides</span>  \
<span class="mi">0</span>            <span class="mf">7.0</span>              <span class="mf">0.27</span>         <span class="mf">0.36</span>            <span class="mf">20.7</span>      <span class="mf">0.045</span>
<span class="mi">1</span>            <span class="mf">6.3</span>              <span class="mf">0.30</span>         <span class="mf">0.34</span>             <span class="mf">1.6</span>      <span class="mf">0.049</span>
<span class="mi">2</span>            <span class="mf">8.1</span>              <span class="mf">0.28</span>         <span class="mf">0.40</span>             <span class="mf">6.9</span>      <span class="mf">0.050</span>

   <span class="n">free</span> <span class="n">sulfur</span> <span class="n">dioxide</span>  <span class="n">total</span> <span class="n">sulfur</span> <span class="n">dioxide</span>  <span class="n">density</span>    <span class="n">pH</span>  <span class="n">sulphates</span>  \
<span class="mi">0</span>                 <span class="mf">45.0</span>                 <span class="mf">170.0</span>   <span class="mf">1.0010</span>  <span class="mf">3.00</span>       <span class="mf">0.45</span>
<span class="mi">1</span>                 <span class="mf">14.0</span>                 <span class="mf">132.0</span>   <span class="mf">0.9940</span>  <span class="mf">3.30</span>       <span class="mf">0.49</span>
<span class="mi">2</span>                 <span class="mf">30.0</span>                  <span class="mf">97.0</span>   <span class="mf">0.9951</span>  <span class="mf">3.26</span>       <span class="mf">0.44</span>

   <span class="n">alcohol</span>  <span class="n">quality</span>
<span class="mi">0</span>      <span class="mf">8.8</span>        <span class="mi">6</span>
<span class="mi">1</span>      <span class="mf">9.5</span>        <span class="mi">6</span>
<span class="mi">2</span>     <span class="mf">10.1</span>        <span class="mi">6</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import scale
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>

<span class="c1"># Scale the features: X_scaled
</span><span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># Print the mean and standard deviation of the unscaled features
</span><span class="k">print</span><span class="p">(</span><span class="s">"Mean of Unscaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Standard Deviation of Unscaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>

<span class="c1"># Print the mean and standard deviation of the scaled features
</span><span class="k">print</span><span class="p">(</span><span class="s">"Mean of Scaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Standard Deviation of Scaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Mean of Unscaled Features: 18.432687072460002
Standard Deviation of Unscaled Features: 41.54494764094571

Mean of Scaled Features: 2.7314972981668206e-15
Standard Deviation of Scaled Features: 0.9999999999999999

</code></pre></div></div>

<p>####
<strong>Centering and scaling in a pipeline</strong></p>

<p>With regard to whether or not scaling is effective, the proof is in the pudding! See for yourself whether or not scaling the features of the White Wine Quality dataset has any impact on its performance.</p>

<p>You will use a k-NN classifier as part of a pipeline that includes scaling, and for the purposes of comparison, a k-NN classifier trained on the unscaled data has been provided.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>

<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
        <span class="p">(</span><span class="s">'knn'</span><span class="p">,</span> <span class="n">KNeighborsClassifier</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Fit the pipeline to the training set: knn_scaled
</span><span class="n">knn_scaled</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Instantiate and fit a k-NN classifier to the unscaled data
</span><span class="n">knn_unscaled</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">().</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Compute and print metrics
</span><span class="k">print</span><span class="p">(</span><span class="s">'Accuracy with Scaling: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">knn_scaled</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Accuracy without Scaling: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">knn_unscaled</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>

<span class="n">Accuracy</span> <span class="k">with</span> <span class="n">Scaling</span><span class="p">:</span> <span class="mf">0.7700680272108843</span>
<span class="n">Accuracy</span> <span class="n">without</span> <span class="n">Scaling</span><span class="p">:</span> <span class="mf">0.6979591836734694</span>

</code></pre></div></div>

<p>It looks like scaling has significantly improved model performance!</p>

<hr />

<p>####
<strong>Bringing it all together I: Pipeline for classification</strong></p>

<p>It is time now to piece together everything you have learned so far into a pipeline for classification! Your job in this exercise is to build a pipeline that includes scaling and hyperparameter tuning to classify wine quality.</p>

<p>You’ll return to using the SVM classifier you were briefly introduced to earlier in this chapter. The hyperparameters you will tune are C and gamma. C controls the regularization strength. It is analogous to the C you tuned for logistic regression in Chapter 3, while gamma controls the kernel coefficient:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup the pipeline
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
         <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Specify the hyperparameter space
</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">'SVM__C'</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
              <span class="s">'SVM__gamma'</span><span class="p">:[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]}</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>

<span class="c1"># Instantiate the GridSearchCV object: cv
</span><span class="n">cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="c1"># Fit to the training set
</span><span class="n">cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print metrics
</span><span class="k">print</span><span class="p">(</span><span class="s">"Accuracy: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned Model Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Accuracy: 0.7795918367346939
             precision    recall  f1-score   support

      False       0.83      0.85      0.84       662
       True       0.67      0.63      0.65       318

avg / total       0.78      0.78      0.78       980

Tuned Model Parameters: {'SVM__C': 10, 'SVM__gamma': 0.1}

</code></pre></div></div>

<p>####
<strong>Bringing it all together II: Pipeline for regression</strong></p>

<p>Your job is to build a pipeline that imputes the missing data, scales the features, and fits an ElasticNet to the Gapminder data. You will then tune the
 <code class="language-plaintext highlighter-rouge">l1_ratio</code>
 of your ElasticNet using GridSearchCV.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'mean'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
         <span class="p">(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
         <span class="p">(</span><span class="s">'elasticnet'</span><span class="p">,</span> <span class="n">ElasticNet</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Specify the hyperparameter space
</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">'elasticnet__l1_ratio'</span><span class="p">:</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">30</span><span class="p">)}</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the GridSearchCV object: gm_cv
</span><span class="n">gm_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="c1"># Fit to the training set
</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Compute and print the metrics
</span><span class="n">r2</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet Alpha: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet R squared: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span>

<span class="c1">#    Tuned ElasticNet Alpha: {'elasticnet__l1_ratio': 1.0}
#    Tuned ElasticNet R squared: 0.8862016570888217
</span>
</code></pre></div></div>

<p>The End.</p>

<p>Thank you for reading.</p>

<hr />

<ol>
  <li>
    <h2 id="classification-1">Classification</h2>
  </li>
</ol>

<p>###
<strong>Machine learning introduction</strong></p>

<p><strong>What is machine learning?</strong>
 Giving computers the ability to learn to make decisions from data without being explicitly programmed</p>

<p><strong>Examples of machine learning:</strong>
 Learning to predict whether an email is spam or not (supervised)</p>

<p>Clustering Wikipedia entries into different categories (unsupervised)</p>

<p>####
<strong>Types of Machine Learning</strong></p>

<ul>
  <li>supervised learning</li>
  <li>unsupervised learning</li>
  <li>reinforcement learning</li>
</ul>

<p><strong>Supervised learning:</strong></p>

<p>Predictor variables/
 <strong>features</strong>
 and a
 <strong>target variable</strong></p>

<p>Aim: Predict the target variable, given the predictor variables</p>

<p>Classification: Target variable consists of categories</p>

<p>Regression: Target variable is continuous</p>

<p><strong>Unsupervised learning:</strong></p>

<p>Uncovering hidden patterns from unlabeled data</p>

<p>Example of unsupervised learning:</p>

<p>Grouping customers into distinct categories (Clustering)</p>

<p><strong>Reinforcement learning:</strong>
 Software agents interact with an environment</p>

<p>Learn how to optimize their behavior</p>

<p>Given a system of rewards and punishments</p>

<p>Applications</p>

<p>Economics</p>

<p>Genetics</p>

<p>Game playing (AlphaGo)</p>

<p>####
 Naming conventions</p>

<ul>
  <li>Features = predictor variables = independent variables</li>
  <li>Target variable = dependent variable = response variable</li>
</ul>

<hr />

<p>####
 Features of
 <strong>Supervised learning</strong></p>

<ul>
  <li>Automate time-consuming or expensive manual tasks (ex. Doctor’s diagnosis)</li>
  <li>Make predictions about the future (ex. Will a customer click on an ad or not)</li>
  <li>Need labeled data (Historical data with labels etc.)</li>
</ul>

<p>####
<strong>Popular libraries</strong></p>

<ul>
  <li>scikit-learning (basic)</li>
  <li>TensorFlow</li>
  <li>keras</li>
</ul>

<hr />

<p>###
<strong>Exploratory data analysis</strong></p>

<p>####
<strong>Numerical EDA</strong></p>

<p>In this chapter, you’ll be working with a dataset obtained from the
 <a href="https://archive.ics.uci.edu/ml/datasets/Congressional+Voting+Records">UCI Machine Learning Repository</a>
 consisting of votes made by US House of Representatives Congressmen.</p>

<p>Your goal will be to predict their party affiliation (‘Democrat’ or ‘Republican’) based on how they voted on certain key issues.</p>

<p>Here, it’s worth noting that we have preprocessed this dataset to deal with missing values. This is so that your focus can be directed towards understanding how to train and evaluate supervised learning models.</p>

<p>Once you have mastered these fundamentals, you will be introduced to preprocessing techniques in Chapter 4 and have the chance to apply them there yourself – including on this very same dataset!</p>

<p>Before thinking about what supervised learning models you can apply to this, however, you need to perform Exploratory data analysis (EDA) in order to understand the structure of the data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
        party  infants  water  budget  physician  salvador  religious  \
0  republican        0      1       0          1         1          1
1  republican        0      1       0          1         1          1
2    democrat        0      1       1          0         1          1
3    democrat        0      1       1          0         1          1
4    democrat        1      1       1          0         1          1

   satellite  aid  missile  immigration  synfuels  education  superfund  \
0          0    0        0            1         0          1          1
1          0    0        0            0         0          1          1
2          0    0        0            0         1          0          1
3          0    0        0            0         1          0          1
4          0    0        0            0         1          0          1

   crime  duty_free_exports  eaa_rsa
0      1                  0        1
1      1                  0        1
2      1                  0        0
3      0                  0        1
4      1                  1        1

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 435 entries, 0 to 434
Data columns (total 17 columns):
party                435 non-null object
infants              435 non-null int64
water                435 non-null int64
budget               435 non-null int64
physician            435 non-null int64
salvador             435 non-null int64
religious            435 non-null int64
satellite            435 non-null int64
aid                  435 non-null int64
missile              435 non-null int64
immigration          435 non-null int64
synfuels             435 non-null int64
education            435 non-null int64
superfund            435 non-null int64
crime                435 non-null int64
duty_free_exports    435 non-null int64
eaa_rsa              435 non-null int64
dtypes: int64(16), object(1)
memory usage: 57.9+ KB

</code></pre></div></div>

<p>###
<strong>Visual EDA</strong></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture-21.png" alt="Desktop View" /></p>

<p>Above is a
 <code class="language-plaintext highlighter-rouge">countplot</code>
 of the
 <code class="language-plaintext highlighter-rouge">'education'</code>
 bill, generated from the following code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.figure()
sns.countplot(x='education', hue='party', data=df, palette='RdBu')
plt.xticks([0,1], ['No', 'Yes'])
plt.show()

</code></pre></div></div>

<p>In
 <code class="language-plaintext highlighter-rouge">sns.countplot()</code>
 , we specify the x-axis data to be
 <code class="language-plaintext highlighter-rouge">'education'</code>
 , and hue to be
 <code class="language-plaintext highlighter-rouge">'party'</code>
 . Recall that
 <code class="language-plaintext highlighter-rouge">'party'</code>
 is also our target variable. So the resulting plot shows the difference in voting behavior between the two parties for the
 <code class="language-plaintext highlighter-rouge">'education'</code>
 bill, with each party colored differently. We manually specified the color to be
 <code class="language-plaintext highlighter-rouge">'RdBu'</code>
 , as the Republican party has been traditionally associated with red, and the Democratic party with blue.</p>

<p>It seems like Democrats voted resoundingly
 <em>against</em>
 this bill, compared to Republicans.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.figure()
sns.countplot(x='missile', hue='party', data=df, palette='RdBu')
plt.xticks([0,1], ['No', 'Yes'])
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture1-20.png" alt="Desktop View" /></p>

<p>Democrats vote resoundingly in
 <em>favor</em>
 of missile, compared to Republicans.</p>

<hr />

<p>###
<strong>The classification challenge</strong></p>

<p>####
<strong>k-Nearest Neighbors: Fit</strong></p>

<p><a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">k-nearest neighbors algorithm</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import KNeighborsClassifier from sklearn.neighbors
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="c1"># Create arrays for the features and the response variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'party'</span><span class="p">].</span><span class="n">values</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">'party'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>

<span class="c1"># Create a k-NN classifier with 6 neighbors
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

</code></pre></div></div>

<p>####
<strong>k-Nearest Neighbors: Predict</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import KNeighborsClassifier from sklearn.neighbors
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="c1"># Create arrays for the features and the response variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'party'</span><span class="p">]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">'party'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>

<span class="c1"># Create a k-NN classifier with 6 neighbors: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Predict the labels for the training data X
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># Predict and print the label for the new data point X_new
</span><span class="n">new_prediction</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Prediction: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">new_prediction</span><span class="p">))</span>

<span class="c1"># Prediction: ['democrat']
</span>
</code></pre></div></div>

<p>How sure can you be of its predictions? In other words, how can you measure its performance?</p>

<hr />

<p>###
<strong>Measuring model performance</strong></p>

<p>####
<strong>The digits recognition dataset: MNIST</strong></p>

<p>In the following exercises, you’ll be working with the
 <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>
 digits recognition dataset, which has 10 classes, the digits 0 through 9! A reduced version of the MNIST dataset is one of scikit-learn’s included datasets, and that is the one we will use in this exercise.</p>

<p>Each sample in this scikit-learn dataset is an 8×8 image representing a handwritten digit. Each pixel is represented by an integer in the range 0 to 16, indicating varying levels of black.</p>

<p>It is a famous dataset in machine learning and computer vision, and frequently used as a benchmark to evaluate the performance of a new model.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Load the digits dataset: digits
</span><span class="n">digits</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">.</span><span class="n">load_digits</span><span class="p">()</span>

<span class="c1"># Print the keys and DESCR of the dataset
</span><span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
<span class="c1">#dict_keys(['data', 'target', 'target_names', 'images', 'DESCR'])
</span>
<span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">DESCR</span><span class="p">)</span>
<span class="o">/*</span>
<span class="n">Optical</span> <span class="n">Recognition</span> <span class="n">of</span> <span class="n">Handwritten</span> <span class="n">Digits</span> <span class="n">Data</span> <span class="n">Set</span>
<span class="o">===================================================</span>

<span class="n">Notes</span>
<span class="o">-----</span>
<span class="n">Data</span> <span class="n">Set</span> <span class="n">Characteristics</span><span class="p">:</span>
    <span class="p">:</span><span class="n">Number</span> <span class="n">of</span> <span class="n">Instances</span><span class="p">:</span> <span class="mi">5620</span>
    <span class="p">:</span><span class="n">Number</span> <span class="n">of</span> <span class="n">Attributes</span><span class="p">:</span> <span class="mi">64</span>
    <span class="p">:</span><span class="n">Attribute</span> <span class="n">Information</span><span class="p">:</span> <span class="mi">8</span><span class="n">x8</span> <span class="n">image</span> <span class="n">of</span> <span class="n">integer</span> <span class="n">pixels</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">range</span> <span class="mf">0.</span><span class="p">.</span><span class="mf">16.</span>
    <span class="p">:</span><span class="n">Missing</span> <span class="n">Attribute</span> <span class="n">Values</span><span class="p">:</span> <span class="bp">None</span>
    <span class="p">:</span><span class="n">Creator</span><span class="p">:</span> <span class="n">E</span><span class="p">.</span> <span class="n">Alpaydin</span> <span class="p">(</span><span class="n">alpaydin</span> <span class="s">'@'</span> <span class="n">boun</span><span class="p">.</span><span class="n">edu</span><span class="p">.</span><span class="n">tr</span><span class="p">)</span>
    <span class="p">:</span><span class="n">Date</span><span class="p">:</span> <span class="n">July</span><span class="p">;</span> <span class="mi">1998</span>
<span class="p">...</span>
<span class="o">*/</span>

<span class="c1"># Print the shape of the images and data keys
</span><span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">images</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

<span class="c1"># Display digit 1010
</span><span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">images</span><span class="p">[</span><span class="mi">1010</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">gray_r</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">'nearest'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture2-19.png" alt="Desktop View" /></p>

<p>####
<strong>Train/Test Split + Fit/Predict/Accuracy</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Create feature and target arrays
</span><span class="n">X</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">data</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">target</span>

<span class="c1"># Split into training and test set
#  Stratify the split according to the labels so that they are distributed in the training and test sets as they are in the original dataset.
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

<span class="c1"># Create a k-NN classifier with 7 neighbors: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Print the accuracy
</span><span class="k">print</span><span class="p">(</span><span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
<span class="c1"># 0.983333333333
</span>
</code></pre></div></div>

<p>Incredibly, this out of the box k-NN classifier with 7 neighbors has learned from the training data and predicted the labels of the images in the test set with 98% accuracy, and it did so in less than a second! This is one illustration of how incredibly useful machine learning techniques can be.</p>

<hr />

<p>####
<strong>Overfitting and underfitting</strong></p>

<p>In this exercise, you will compute and plot the training and testing accuracy scores for a variety of different neighbor values. By observing how the accuracy scores differ for the training and testing sets with different values of k, you will develop your intuition for overfitting and underfitting.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup arrays to store train and test accuracies
</span><span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">train_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>
<span class="n">test_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>

<span class="c1"># Loop over different values of k
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
    <span class="c1"># Setup a k-NN Classifier with k neighbors: knn
</span>    <span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># Fit the classifier to the training data
</span>    <span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1">#Compute accuracy on the training set
</span>    <span class="n">train_accuracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1">#Compute accuracy on the testing set
</span>    <span class="n">test_accuracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

<span class="c1"># Generate plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'k-NN: Varying Number of Neighbors'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">test_accuracy</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Testing Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">train_accuracy</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Training Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Number of Neighbors'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture3-18.png" alt="Desktop View" /></p>

<p>It looks like the test accuracy is highest when using 3 and 5 neighbors. Using 8 neighbors or more seems to result in a simple model that underfits the data.</p>

<hr />

<h1 id="2-regression-1"><strong>2. Regression</strong></h1>
<hr />

<p>###
<strong>Introduction to regression</strong></p>

<p>####
<strong>Importing data for supervised learning</strong></p>

<p>In this chapter, you will work with
 <a href="https://www.gapminder.org/data/">Gapminder</a>
 data that we have consolidated into one CSV file available in the workspace as
 <code class="language-plaintext highlighter-rouge">'gapminder.csv'</code>
 . Specifically, your goal will be to use this data to predict the life expectancy in a given country based on features such as the country’s GDP, fertility rate, and population.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import numpy and pandas
</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Read the CSV file into a DataFrame: df
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'gapminder.csv'</span><span class="p">)</span>

<span class="c1"># Create arrays for features and target variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'life'</span><span class="p">].</span><span class="n">values</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'fertility'</span><span class="p">].</span><span class="n">values</span>

<span class="c1"># Print the dimensions of X and y before reshaping
</span><span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of y before reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of X before reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Dimensions of y before reshaping: (139,)
# Dimensions of X before reshaping: (139,)
</span>

<span class="c1"># Reshape X and y
</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the dimensions of X and y after reshaping
</span><span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of y after reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of X after reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Dimensions of y after reshaping: (139, 1)
# Dimensions of X after reshaping: (139, 1)
</span>
</code></pre></div></div>

<p>####
<strong>Exploring the Gapminder data</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 139 entries, 0 to 138
Data columns (total 9 columns):
population         139 non-null float64
fertility          139 non-null float64
HIV                139 non-null float64
CO2                139 non-null float64
BMI_male           139 non-null float64
GDP                139 non-null float64
BMI_female         139 non-null float64
life               139 non-null float64
child_mortality    139 non-null float64
dtypes: float64(9)
memory usage: 9.9 KB

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
sns.heatmap(df.corr(), square=True, cmap='RdYlGn')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture4-17.png" alt="Desktop View" /></p>

<p>###
<strong>The basics of linear regression</strong></p>

<p>We suppose that y and x have a linear relationship that can be model by</p>

<p>y = ax + b</p>

<p>An linear regression is to find a, b that minimize the sum of the squared residual (= Ordinary Least Squares, OLS)</p>

<p>Why squared residual?</p>

<p>Residuals may be positive and negative.</p>

<p>They cancel each other. square residual can solve this problem.</p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture6-11.png" alt="Desktop View" /></p>

<p>green lines are residuals</p>

<p>When we have n variables of x,</p>

<p>y = a1<em>x1 + a2</em>x2 + … an*xn + b</p>

<p>we find a1, a2, … an, b that minimize the sum of the squared residual.</p>

<p>####
<strong>Fit &amp; predict for regression</strong></p>

<p>In this exercise, you will use the
 <code class="language-plaintext highlighter-rouge">'fertility'</code>
 feature of the Gapminder dataset. Since the goal is to predict life expectancy, the target variable here is
 <code class="language-plaintext highlighter-rouge">'life'</code>
 .</p>

<p>You will also compute and print the R2 score using sckit-learn’s
 <code class="language-plaintext highlighter-rouge">.score()</code>
 method.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import LinearRegression
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="c1"># Create the regressor: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Create the prediction space
</span><span class="n">prediction_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">)).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Fit the model to the data
</span><span class="n">reg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Compute predictions over the prediction space: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">prediction_space</span><span class="p">)</span>

<span class="c1"># Print R^2
</span><span class="k">print</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="mf">0.619244216774</span>

<span class="c1"># Plot regression line
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">prediction_space</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'black'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture7-12.png" alt="Desktop View" /></p>

<p>####
<strong>Train/test split for regression</strong></p>

<p>In this exercise, you will split the Gapminder dataset into training and testing sets, and then fit and predict a linear regression over
 <strong>all</strong>
 features. In addition to computing the R2 score, you will also compute the Root Mean Squared Error (RMSE), which is another commonly used metric to evaluate regression models.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the regressor: reg_all
</span><span class="n">reg_all</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Fit the regressor to the training data
</span><span class="n">reg_all</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict on the test data: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg_all</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print R^2 and RMSE
</span><span class="k">print</span><span class="p">(</span><span class="s">"R^2: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">reg_all</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="c1"># R^2: 0.838046873142936
</span>

<span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Root Mean Squared Error: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">rmse</span><span class="p">))</span>
<span class="c1"># Root Mean Squared Error: 3.2476010800377213
</span>

</code></pre></div></div>

<p>###
<strong>Cross-validation</strong></p>

<p>What is cross validation?</p>

<p><a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)">https://en.wikipedia.org/wiki/Cross-validation_(statistics)</a></p>

<p>####
<strong>5-fold cross-validation</strong></p>

<p>In this exercise, you will practice 5-fold cross validation on the Gapminder data. By default, scikit-learn’s
 <code class="language-plaintext highlighter-rouge">cross_val_score()</code>
 function uses R2R2 as the metric of choice for regression.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Create a linear regression object: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Compute 5-fold cross-validation scores: cv_scores
</span><span class="n">cv_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Print the 5-fold cross-validation scores
</span><span class="k">print</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)</span>
<span class="c1"># [ 0.81720569  0.82917058  0.90214134  0.80633989  0.94495637]
</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Average 5-Fold CV Score: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)))</span>
<span class="c1"># Average 5-Fold CV Score: 0.8599627722793232
</span>
</code></pre></div></div>

<p>####
<strong>K-Fold CV comparison</strong></p>

<p>Cross validation is essential but do not forget that the more folds you use, the more computationally expensive cross-validation becomes. In this exercise, you will explore this for yourself. Your job is to perform 3-fold cross-validation and then 10-fold cross-validation on the Gapminder dataset.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Create a linear regression object: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Perform 3-fold CV
</span><span class="n">cvscores_3</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvscores_3</span><span class="p">))</span>
<span class="c1"># 0.871871278262
</span>
<span class="c1"># Perform 10-fold CV
</span><span class="n">cvscores_10</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvscores_10</span><span class="p">))</span>
<span class="c1"># 0.843612862013
</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
%timeit cross_val_score(reg, X, y, cv=3)
100 loops, best of 3: 8.73 ms per loop

%timeit cross_val_score(reg, X, y, cv=10)
10 loops, best of 3: 27.5 ms per loop

</code></pre></div></div>

<hr />

<p>###
<strong>Regularized regression</strong></p>

<p>####
<strong><a href="https://en.wikipedia.org/wiki/Lasso_(statistics)">Regularization I: Lasso</a></strong></p>

<p>In this exercise, you will fit a lasso regression to the Gapminder data you have been working with and plot the coefficients. Just as with the Boston data, you will find that the coefficients of some features are shrunk to 0, with only the most important ones remaining.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.columns
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality'],
      dtype='object')

X: ['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'child_mortality']
y: life

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import Lasso
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Lasso</span>

<span class="c1"># Instantiate a lasso regressor: lasso
</span><span class="n">lasso</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Fit the regressor to the data
</span><span class="n">lasso</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Compute and print the coefficients
</span><span class="n">lasso_coef</span> <span class="o">=</span> <span class="n">lasso</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">).</span><span class="n">coef_</span>
<span class="k">print</span><span class="p">(</span><span class="n">lasso_coef</span><span class="p">)</span>
<span class="c1">#  [-0.         -0.         -0.          0.          0.          0.         -0.
</span>     <span class="o">-</span><span class="mf">0.07087587</span><span class="p">]</span>


<span class="c1"># Plot the coefficients
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_columns</span><span class="p">)),</span> <span class="n">lasso_coef</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_columns</span><span class="p">)),</span> <span class="n">df_columns</span><span class="p">.</span><span class="n">values</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture8-9.png" alt="Desktop View" /></p>

<p>According to the lasso algorithm, it seems like
 <code class="language-plaintext highlighter-rouge">'child_mortality'</code>
 is the most important feature when predicting life expectancy.</p>

<p>####
<strong>Regularization II: Ridge</strong></p>

<p>Lasso is great for feature selection, but when building regression models, Ridge regression should be your first choice.</p>

<p>Recall that lasso performs regularization by adding to the loss function a penalty term of the
 <em>absolute</em>
 value of each coefficient multiplied by some alpha. This is also known as L1L1 regularization because the regularization term is the L1L1 norm of the coefficients. This is not the only way to regularize, however.</p>

<p>If instead you took the sum of the
 <em>squared</em>
 values of the coefficients multiplied by some alpha – like in Ridge regression – you would be computing the L2L2norm. In this exercise, you will practice fitting ridge regression models over a range of different alphas, and plot cross-validated R2R2 scores for each, using this function that we have defined for you, which plots the R2R2 score as well as standard error for each alpha:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def display_plot(cv_scores, cv_scores_std):
    fig = plt.figure()
    ax = fig.add_subplot(1,1,1)
    ax.plot(alpha_space, cv_scores)

    std_error = cv_scores_std / np.sqrt(10)

    ax.fill_between(alpha_space, cv_scores + std_error, cv_scores - std_error, alpha=0.2)
    ax.set_ylabel('CV Score +/- Std Error')
    ax.set_xlabel('Alpha')
    ax.axhline(np.max(cv_scores), linestyle='--', color='.5')
    ax.set_xlim([alpha_space[0], alpha_space[-1]])
    ax.set_xscale('log')
    plt.show()


</code></pre></div></div>

<p>Don’t worry about the specifics of the above function works. The motivation behind this exercise is for you to see how the R2R2 score varies with different alphas, and to understand the importance of selecting the right value for alpha. You’ll learn how to tune alpha in the next chapter.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Setup the array of alphas and lists to store scores
</span><span class="n">alpha_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">ridge_scores</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ridge_scores_std</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Create a ridge regressor: ridge
</span><span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Compute scores over range of alphas
</span><span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">alpha_space</span><span class="p">:</span>

    <span class="c1"># Specify the alpha value to use: ridge.alpha
</span>    <span class="n">ridge</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="c1"># Perform 10-fold CV: ridge_cv_scores
</span>    <span class="n">ridge_cv_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="c1"># Append the mean of ridge_cv_scores to ridge_scores
</span>    <span class="n">ridge_scores</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ridge_cv_scores</span><span class="p">))</span>

    <span class="c1"># Append the std of ridge_cv_scores to ridge_scores_std
</span>    <span class="n">ridge_scores_std</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">ridge_cv_scores</span><span class="p">))</span>

<span class="c1"># Display the plot
</span><span class="n">display_plot</span><span class="p">(</span><span class="n">ridge_scores</span><span class="p">,</span> <span class="n">ridge_scores_std</span><span class="p">)</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture9-8.png" alt="Desktop View" /></p>

<p>Notice how the cross-validation scores change with different alphas.</p>

<hr />

<h1 id="3-fine-tuning-your-model-1"><strong>3. Fine-tuning your model</strong></h1>
<hr />

<p>###
<strong>confusion matrix</strong></p>

<p>What is confusion matrix</p>

<p><a href="https://en.wikipedia.org/wiki/Confusion_matrix">https://en.wikipedia.org/wiki/Confusion_matrix</a></p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f02ea353bf60bfdd9557d2c98fe18c34cd8db835" alt="{\displaystyle \mathrm {TPR} ={\frac {\mathrm {TP} }{\mathrm {P} }}={\frac {\mathrm {TP} }{\mathrm {TP} +\mathrm {FN} }}=1-\mathrm {FNR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">sensitivity</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Precision_and_recall#Recall">recall</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Hit_rate">hit rate</a>
 , or
 <a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">true positive rate</a>
 (TPR)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8f2c867f0641e498ec8a59de63697a3a45d66b07" alt="{\displaystyle \mathrm {TNR} ={\frac {\mathrm {TN} }{\mathrm {N} }}={\frac {\mathrm {TN} }{\mathrm {TN} +\mathrm {FP} }}=1-\mathrm {FPR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Specificity_(tests)">specificity</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Specificity_(tests)">selectivity</a>
 or
 <a href="https://en.wikipedia.org/wiki/Specificity_(tests)">true negative rate</a>
 (TNR)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d854b1544fc77735d575ce0d30e34d7f1eacf707" alt="{\displaystyle \mathrm {PPV} ={\frac {\mathrm {TP} }{\mathrm {TP} +\mathrm {FP} }}=1-\mathrm {FDR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision">precision</a>
 or
 <a href="https://en.wikipedia.org/wiki/Positive_predictive_value">positive predictive value</a>
 (PPV)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47deb47eb7ac214423d0a6afd05ec0af362fef9b" alt="{\displaystyle \mathrm {ACC} ={\frac {\mathrm {TP} +\mathrm {TN} }{\mathrm {P} +\mathrm {N} }}={\frac {\mathrm {TP} +\mathrm {TN} }{\mathrm {TP} +\mathrm {TN} +\mathrm {FP} +\mathrm {FN} }}}" /></p>

<p><a href="https://en.wikipedia.org/wiki/Accuracy">accuracy</a>
 (ACC)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0e5f071c6418f444fadc9f5f9b0358beed3e094c" alt="{\displaystyle \mathrm {F} _{1}=2\cdot {\frac {\mathrm {PPV} \cdot \mathrm {TPR} }{\mathrm {PPV} +\mathrm {TPR} }}={\frac {2\mathrm {TP} }{2\mathrm {TP} +\mathrm {FP} +\mathrm {FN} }}}" /></p>

<p><a href="https://en.wikipedia.org/wiki/F1_score">F1 score</a>
 is the
 <a href="https://en.wikipedia.org/wiki/Harmonic_mean#Harmonic_mean_of_two_numbers">harmonic mean</a>
 of
 <a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision">precision</a>
 and
 <a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">sensitivity</a></p>

<p>####
<strong>illustration for TPR, TNR and PPV</strong></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/metric_example.png?w=1024" alt="Desktop View" /></p>

<p><a href="http://corysimon.github.io/articles/classification-metrics/">source</a></p>

<p>####
<strong>Metrics for classification</strong></p>

<p>In this exercise, you will dive more deeply into evaluating the performance of binary classifiers by computing a confusion matrix and generating a classification report.</p>

<p>Here, you’ll work with the
 <a href="https://www.kaggle.com/uciml/pima-indians-diabetes-database">PIMA Indians</a>
 dataset obtained from the UCI Machine Learning Repository. The goal is to predict whether or not a given female patient will contract diabetes based on features such as BMI, age, and number of pregnancies.</p>

<p>Therefore, it is a binary classification problem. A target value of
 <code class="language-plaintext highlighter-rouge">0</code>
 indicates that the patient does
 <em>not</em>
 have diabetes, while a value of
 <code class="language-plaintext highlighter-rouge">1</code>
 indicates that the patient
 <em>does</em>
 have diabetes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 768 entries, 0 to 767
Data columns (total 9 columns):
pregnancies    768 non-null int64
glucose        768 non-null int64
diastolic      768 non-null int64
triceps        768 non-null float64
insulin        768 non-null float64
bmi            768 non-null float64
dpf            768 non-null float64
age            768 non-null int64
diabetes       768 non-null int64
dtypes: float64(4), int64(5)
memory usage: 54.1 KB

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>

<span class="c1"># Create training and test set
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Instantiate a k-NN classifier: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test data: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Generate the confusion matrix and classification report
</span><span class="k">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[[176  30]
 [ 52  50]]

             precision    recall  f1-score   support

          0       0.77      0.85      0.81       206
          1       0.62      0.49      0.55       102

avg / total       0.72      0.73      0.72       308

</code></pre></div></div>

<hr />

<p>###
<strong>Logistic regression and the ROC curve</strong></p>

<p>What is logistic regression?</p>

<p><a href="https://en.wikipedia.org/wiki/Logistic_regression">https://en.wikipedia.org/wiki/Logistic_regression</a></p>

<p>What is ROC?</p>

<p><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">Receiver operating characteristic</a></p>

<p>Further Reading:
 <a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.html#sphx-glr-auto-examples-model-selection-plot-roc-py">scikit-learn document</a></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/roc_space-2.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Building a logistic regression model</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
X.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 768 entries, 0 to 767
Data columns (total 8 columns):
pregnancies    768 non-null int64
glucose        768 non-null int64
diastolic      768 non-null int64
triceps        768 non-null float64
insulin        768 non-null float64
bmi            768 non-null float64
dpf            768 non-null float64
age            768 non-null int64
dtypes: float64(4), int64(4)
memory usage: 48.1 KB


y
0      1
1      0
2      1
      ..

765    0
766    1
767    0
Name: diabetes, dtype: int64

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span><span class="p">,</span> <span class="n">confusion_matrix</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">logreg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print the confusion matrix and classification report
</span><span class="k">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[[176  30]
 [ 35  67]]

             precision    recall  f1-score   support

          0       0.83      0.85      0.84       206
          1       0.69      0.66      0.67       102

avg / total       0.79      0.79      0.79       308

</code></pre></div></div>

<p>####
<strong>Plotting an ROC curve</strong></p>

<p><strong>.predict_proba()</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>

<span class="c1"># Compute predicted probabilities: y_pred_prob
</span><span class="n">y_pred_prob</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Generate ROC curve values: fpr, tpr, thresholds
</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_prob</span><span class="p">)</span>

<span class="c1"># Plot ROC curve
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s">'k--'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'False Positive Rate'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'True Positive Rate'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'ROC Curve'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
logreg.predict_proba(X_test)
# False, True
# 0, 1
# Negative, Positive
array([[ 0.60409835,  0.39590165],
       [ 0.76042394,  0.23957606],
       [ 0.79670177,  0.20329823],
       ...
       [ 0.84686912,  0.15313088],
       [ 0.97617225,  0.02382775],
       [ 0.40380502,  0.59619498]])

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture1-21.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Precision-recall Curve</strong></p>

<p>There are other ways to visually evaluate model performance. One such way is the precision-recall curve, which is generated by plotting the precision and recall for different thresholds.</p>

<p>Note that here, the class is positive (1) if the individual
 <em>has</em>
 diabetes.</p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture2-20.png?w=1024" alt="Desktop View" /></p>

<ul>
  <li>A recall of 1 corresponds to a classifier with a low threshold in which
 <em>all</em>
 females who contract diabetes were correctly classified as such, at the expense of many misclassifications of those who did
 <em>not</em>
 have diabetes.</li>
  <li>Precision is undefined for a classifier which makes
 <em>no</em>
 positive predictions, that is, classifies
 <em>everyone</em>
 as
 <em>not</em>
 having diabetes.</li>
  <li>When the threshold is very close to 1, precision is also 1, because the classifier is absolutely certain about its predictions.</li>
</ul>

<p>recall or sensitivity, TPR = 1 means all true positive are detected. We can predict all to positive to get a recall of 1.</p>

<p>precision, PPV = 1 means no false positive are detected. We can predict less positive to get a higher precision.</p>

<p>####
<strong>Area under the ROC curve</strong></p>

<p>####
<strong>AUC(</strong>
 Area Under the Curve
 <strong>) computation</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span><span class="n">df</span><span class="p">.</span><span class="n">head</span><span class="p">()</span>
   <span class="n">pregnancies</span>  <span class="n">glucose</span>  <span class="n">diastolic</span>   <span class="n">triceps</span>     <span class="n">insulin</span>   <span class="n">bmi</span>    <span class="n">dpf</span>  <span class="n">age</span>  \
<span class="mi">0</span>            <span class="mi">6</span>      <span class="mi">148</span>         <span class="mi">72</span>  <span class="mf">35.00000</span>  <span class="mf">155.548223</span>  <span class="mf">33.6</span>  <span class="mf">0.627</span>   <span class="mi">50</span>
<span class="mi">1</span>            <span class="mi">1</span>       <span class="mi">85</span>         <span class="mi">66</span>  <span class="mf">29.00000</span>  <span class="mf">155.548223</span>  <span class="mf">26.6</span>  <span class="mf">0.351</span>   <span class="mi">31</span>
<span class="mi">2</span>            <span class="mi">8</span>      <span class="mi">183</span>         <span class="mi">64</span>  <span class="mf">29.15342</span>  <span class="mf">155.548223</span>  <span class="mf">23.3</span>  <span class="mf">0.672</span>   <span class="mi">32</span>
<span class="mi">3</span>            <span class="mi">1</span>       <span class="mi">89</span>         <span class="mi">66</span>  <span class="mf">23.00000</span>   <span class="mf">94.000000</span>  <span class="mf">28.1</span>  <span class="mf">0.167</span>   <span class="mi">21</span>
<span class="mi">4</span>            <span class="mi">0</span>      <span class="mi">137</span>         <span class="mi">40</span>  <span class="mf">35.00000</span>  <span class="mf">168.000000</span>  <span class="mf">43.1</span>  <span class="mf">2.288</span>   <span class="mi">33</span>

   <span class="n">diabetes</span>
<span class="mi">0</span>         <span class="mi">1</span>
<span class="mi">1</span>         <span class="mi">0</span>
<span class="mi">2</span>         <span class="mi">1</span>
<span class="mi">3</span>         <span class="mi">0</span>
<span class="mi">4</span>         <span class="mi">1</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Compute predicted probabilities: y_pred_prob
</span><span class="n">y_pred_prob</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Compute and print AUC score
</span><span class="k">print</span><span class="p">(</span><span class="s">"AUC: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_prob</span><span class="p">)))</span>

<span class="c1"># Compute cross-validated AUC scores: cv_auc
</span><span class="n">cv_auc</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'roc_auc'</span><span class="p">)</span>

<span class="c1"># Print list of AUC scores
</span><span class="k">print</span><span class="p">(</span><span class="s">"AUC scores computed using 5-fold cross-validation: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv_auc</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
AUC: 0.8254806777079764

AUC scores computed using 5-fold cross-validation:
[ 0.80148148  0.8062963   0.81481481  0.86245283  0.8554717 ]

</code></pre></div></div>

<hr />

<p>###
<strong>Hyperparameter tuning</strong></p>

<p>####
<strong>Hyperparameter tuning with GridSearchCV</strong></p>

<p>You will now practice this yourself, but by using logistic regression on the diabetes dataset.</p>

<p>Like the alpha parameter of lasso and ridge regularization that you saw earlier, logistic regression also has a regularization parameter: CC. CC controls the
 <em>inverse</em>
 of the regularization strength, and this is what you will tune in this exercise. A large CC can lead to an
 <em>overfit</em>
 model, while a small CC can lead to an
 <em>underfit</em>
 model.</p>

<p>The hyperparameter space for CC has been setup for you. Your job is to use GridSearchCV and logistic regression to find the optimal CC in this hyperparameter space.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="c1"># Setup the hyperparameter grid
</span><span class="n">c_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'C'</span><span class="p">:</span> <span class="n">c_space</span><span class="p">}</span>

<span class="c1"># Instantiate a logistic regression classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Instantiate the GridSearchCV object: logreg_cv
</span><span class="n">logreg_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the data
</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Print the tuned parameters and score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Best score is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Logistic Regression Parameters: {'C': 3.7275937203149381}
Best score is 0.7708333333333334

</code></pre></div></div>

<p>####
<strong>Hyperparameter tuning with RandomizedSearchCV</strong></p>

<p>GridSearchCV can be computationally expensive, especially if you are searching over a large hyperparameter space and dealing with multiple hyperparameters. A solution to this is to use
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 , in which not all hyperparameter values are tried out. Instead, a fixed number of hyperparameter settings is sampled from specified probability distributions. You’ll practice using
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 in this exercise and see how this works.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">RandomizedSearchCV</span>

<span class="c1"># Setup the parameters and distributions to sample from: param_dist
</span><span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s">"max_depth"</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
              <span class="s">"max_features"</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="s">"min_samples_leaf"</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="s">"criterion"</span><span class="p">:</span> <span class="p">[</span><span class="s">"gini"</span><span class="p">,</span> <span class="s">"entropy"</span><span class="p">]}</span>

<span class="c1"># Instantiate a Decision Tree classifier: tree
</span><span class="n">tree</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">()</span>

<span class="c1"># Instantiate the RandomizedSearchCV object: tree_cv
</span><span class="n">tree_cv</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">param_dist</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the data
</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Print the tuned parameters and score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Decision Tree Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Best score is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Decision Tree Parameters: {'criterion': 'entropy', 'max_depth': 3, 'max_features': 7, 'min_samples_leaf': 1}
Best score is 0.7317708333333334

</code></pre></div></div>

<p>Note that
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 will never outperform
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 . Instead, it is valuable because it saves on computation time.</p>

<p>###
<strong>Hold-out set for final evaluation</strong></p>

<p>####
<strong>Hold-out set in practice I: Classification</strong></p>

<p>In addition to CC, logistic regression has a
 <code class="language-plaintext highlighter-rouge">'penalty'</code>
 hyperparameter which specifies whether to use
 <code class="language-plaintext highlighter-rouge">'l1'</code>
 or
 <code class="language-plaintext highlighter-rouge">'l2'</code>
 regularization. Your job in this exercise is to create a hold-out set, tune the
 <code class="language-plaintext highlighter-rouge">'C'</code>
 and
 <code class="language-plaintext highlighter-rouge">'penalty'</code>
 hyperparameters of a logistic regression classifier using
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 on the training set.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="c1"># Create the hyperparameter grid
</span><span class="n">c_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'C'</span><span class="p">:</span> <span class="n">c_space</span><span class="p">,</span> <span class="s">'penalty'</span><span class="p">:</span> <span class="p">[</span><span class="s">'l1'</span><span class="p">,</span> <span class="s">'l2'</span><span class="p">]}</span>

<span class="c1"># Instantiate the logistic regression classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Instantiate the GridSearchCV object: logreg_cv
</span><span class="n">logreg_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the training data
</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Print the optimal parameters and best score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Parameter: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Accuracy: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Logistic Regression Parameter: {'C': 0.43939705607607948, 'penalty': 'l1'}
Tuned Logistic Regression Accuracy: 0.7652173913043478

</code></pre></div></div>

<p>####
<strong>Hold-out set in practice II: Regression</strong></p>

<p>Remember lasso and ridge regression from the previous chapter? Lasso used the L1 penalty to regularize, while ridge used the L2 penalty. There is another type of regularized regression known as the elastic net. In elastic net regularization, the penalty term is a linear combination of the L1 and L2 penalties:</p>

<p><strong>a∗L1+b∗L2</strong></p>

<p>In scikit-learn, this term is represented by the
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 parameter: An
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 of
 <code class="language-plaintext highlighter-rouge">1</code>
 corresponds to an L1L1 penalty, and anything lower is a combination of L1L1 and L2L2.</p>

<p>In this exercise, you will
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 to tune the
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 of an elastic net model trained on the Gapminder data. As in the previous exercise, use a hold-out set to evaluate your model’s performance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5
3   2975029.0       1.40  0.1   1.804106  25.35542   7383.0    132.8108  72.5
4  21370348.0       1.96  0.1  18.016313  27.56373  41312.0    117.3755  81.5

   child_mortality
0             29.5
1            192.0
2             15.4
3             20.0
4              5.2


</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">ElasticNet</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">train_test_split</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the hyperparameter grid
</span><span class="n">l1_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'l1_ratio'</span><span class="p">:</span> <span class="n">l1_space</span><span class="p">}</span>

<span class="c1"># Instantiate the ElasticNet regressor: elastic_net
</span><span class="n">elastic_net</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">()</span>

<span class="c1"># Setup the GridSearchCV object: gm_cv
</span><span class="n">gm_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">elastic_net</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the training data
</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict on the test set and compute metrics
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">r2</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="n">mse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet l1 ratio: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet R squared: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet MSE: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">mse</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned ElasticNet l1 ratio: {'l1_ratio': 0.20689655172413793}
Tuned ElasticNet R squared: 0.8668305372460283
Tuned ElasticNet MSE: 10.05791413339844

</code></pre></div></div>

<hr />

<h2 id="preprocessing-and-pipelines-1"><strong>Preprocessing and pipelines</strong></h2>

<p>###
<strong>Preprocessing data</strong></p>

<p>####
<strong>Exploring categorical features</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5
3   2975029.0       1.40  0.1   1.804106  25.35542   7383.0    132.8108  72.5
4  21370348.0       1.96  0.1  18.016313  27.56373  41312.0    117.3755  81.5

   child_mortality                      Region
0             29.5  Middle East &amp; North Africa
1            192.0          Sub-Saharan Africa
2             15.4                     America
3             20.0       Europe &amp; Central Asia
4              5.2         East Asia &amp; Pacific

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import pandas
</span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Read 'gapminder.csv' into a DataFrame: df
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'gapminder.csv'</span><span class="p">)</span>

<span class="c1"># Create a boxplot of life expectancy per region
</span><span class="n">df</span><span class="p">.</span><span class="n">boxplot</span><span class="p">(</span><span class="s">'life'</span><span class="p">,</span> <span class="s">'Region'</span><span class="p">,</span> <span class="n">rot</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture3-19.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Creating dummy variables</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create dummy variables: df_region
</span><span class="n">df_region</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Print the columns of df_region
</span><span class="k">print</span><span class="p">(</span><span class="n">df_region</span><span class="p">.</span><span class="n">columns</span><span class="p">)</span>

<span class="c1"># Create dummy variables with drop_first=True: df_region
</span><span class="n">df_region</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">drop_first</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Print the new columns of df_region
</span><span class="k">print</span><span class="p">(</span><span class="n">df_region</span><span class="p">.</span><span class="n">columns</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality', 'Region_America',
       'Region_East Asia &amp; Pacific', 'Region_Europe &amp; Central Asia',
       'Region_Middle East &amp; North Africa', 'Region_South Asia',
       'Region_Sub-Saharan Africa'],
      dtype='object')

# Region_America has been dropped
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality', 'Region_East Asia &amp; Pacific',
       'Region_Europe &amp; Central Asia', 'Region_Middle East &amp; North Africa',
       'Region_South Asia', 'Region_Sub-Saharan Africa'],
      dtype='object')


df_region.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5

   child_mortality  Region_East Asia &amp; Pacific  Region_Europe &amp; Central Asia  \
0             29.5                           0                             0
1            192.0                           0                             0
2             15.4                           0                             0

   Region_Middle East &amp; North Africa  Region_South Asia  \
0                                  1                  0
1                                  0                  0
2                                  0                  0

   Region_Sub-Saharan Africa
0                          0
1                          1
2                          0

</code></pre></div></div>

<p>####
<strong>Regression with categorical features</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Instantiate a ridge regressor: ridge
</span><span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Perform 5-fold cross-validation: ridge_cv
</span><span class="n">ridge_cv</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Print the cross-validated scores
</span><span class="k">print</span><span class="p">(</span><span class="n">ridge_cv</span><span class="p">)</span>
<span class="p">[</span> <span class="mf">0.86808336</span>  <span class="mf">0.80623545</span>  <span class="mf">0.84004203</span>  <span class="mf">0.7754344</span>   <span class="mf">0.87503712</span><span class="p">]</span>

</code></pre></div></div>

<hr />

<p>###
<strong>Handling missing data</strong></p>

<p>####
<strong>Dropping missing data</strong></p>

<p>Now, it’s time for you to take care of these yourself!</p>

<p>The unprocessed dataset has been loaded into a DataFrame
 <code class="language-plaintext highlighter-rouge">df</code>
 . Explore it in the IPython Shell with the
 <code class="language-plaintext highlighter-rouge">.head()</code>
 method. You will see that there are certain data points labeled with a
 <code class="language-plaintext highlighter-rouge">'?'</code>
 . These denote missing values. As you saw in the video, different datasets encode missing values in different ways. Sometimes it may be a
 <code class="language-plaintext highlighter-rouge">'9999'</code>
 , other times a
 <code class="language-plaintext highlighter-rouge">0</code>
 – real-world data can be very messy! If you’re lucky, the missing values will already be encoded as
 <code class="language-plaintext highlighter-rouge">NaN</code>
 . We use
 <code class="language-plaintext highlighter-rouge">NaN</code>
 because it is an efficient and simplified way of internally representing missing data, and it lets us take advantage of pandas methods such as
 <code class="language-plaintext highlighter-rouge">.dropna()</code>
 and
 <code class="language-plaintext highlighter-rouge">.fillna()</code>
 , as well as scikit-learn’s Imputation transformer
 <code class="language-plaintext highlighter-rouge">Imputer()</code>
 .</p>

<p>In this exercise, your job is to convert the
 <code class="language-plaintext highlighter-rouge">'?'</code>
 s to NaNs, and then drop the rows that contain them from the DataFrame.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head(3)
        party infants water budget physician salvador religious satellite aid  \
0  republican       0     1      0         1        1         1         0   0
1  republican       0     1      0         1        1         1         0   0
2    democrat       ?     1      1         ?        1         1         0   0

  missile immigration synfuels education superfund crime duty_free_exports  \
0       0           1        ?         1         1     1                 0
1       0           0        0         1         1     1                 0
2       0           0        1         0         1     1                 0

  eaa_rsa
0       1
1       ?
2       0

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Convert '?' to NaN
</span><span class="n">df</span><span class="p">[</span><span class="n">df</span> <span class="o">==</span> <span class="s">'?'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">nan</span>

<span class="c1"># Print the number of NaNs
</span><span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">isnull</span><span class="p">().</span><span class="nb">sum</span><span class="p">())</span>

<span class="c1"># Print shape of original DataFrame
</span><span class="k">print</span><span class="p">(</span><span class="s">"Shape of Original DataFrame: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Drop missing values and print shape of new DataFrame
</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">dropna</span><span class="p">()</span>

<span class="c1"># Print shape of new DataFrame
</span><span class="k">print</span><span class="p">(</span><span class="s">"Shape of DataFrame After Dropping All Rows with Missing Values: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
party                  0
infants               12
water                 48
budget                11
physician             11
salvador              15
religious             11
satellite             14
aid                   15
missile               22
immigration            7
synfuels              21
education             31
superfund             25
crime                 17
duty_free_exports     28
eaa_rsa              104
dtype: int64
Shape of Original DataFrame: (435, 17)


Shape of DataFrame After Dropping All Rows with Missing Values: (232, 17)

</code></pre></div></div>

<p>When many values in your dataset are missing, if you drop them, you may end up throwing away valuable information along with the missing data. It’s better instead to develop an imputation strategy. This is where domain knowledge is useful, but in the absence of it, you can impute missing values with the mean or the median of the row or column that the missing value is in.</p>

<p>####
<strong>Imputing missing data in a ML Pipeline I</strong></p>

<p>As you’ve come to appreciate, there are many steps to building a model, from creating training and test sets, to fitting a classifier or regressor, to tuning its parameters, to evaluating its performance on new data. Imputation can be seen as the first step of this machine learning process, the entirety of which can be viewed within the context of a pipeline. Scikit-learn provides a pipeline constructor that allows you to piece together these steps into one process and thereby simplify your workflow.</p>

<p>You’ll now practice setting up a pipeline with two steps: the imputation step, followed by the instantiation of a classifier. You’ve seen three classifiers in this course so far: k-NN, logistic regression, and the decision tree. You will now be introduced to a fourth one – the Support Vector Machine, or
 <a href="http://scikit-learn.org/stable/modules/svm.html">SVM</a>
 .</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the Imputer module
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Imputer</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Setup the Imputation transformer: imp
# axis=0 for column
</span><span class="n">imp</span> <span class="o">=</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'most_frequent'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Instantiate the SVC classifier: clf
</span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">()</span>

<span class="c1"># Setup the pipeline with the required steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">imp</span><span class="p">),</span>
        <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">clf</span><span class="p">)]</span>

</code></pre></div></div>

<p>####
<strong>Imputing missing data in a ML Pipeline II</strong></p>

<p>Having setup the steps of the pipeline in the previous exercise, you will now use it on the voting dataset to classify a Congressman’s party affiliation.</p>

<p>What makes pipelines so incredibly useful is the simple interface that they provide. You can use the
 <code class="language-plaintext highlighter-rouge">.fit()</code>
 and
 <code class="language-plaintext highlighter-rouge">.predict()</code>
 methods on pipelines just as you did with your classifiers and regressors!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Imputer</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'most_frequent'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Fit the pipeline to the train set
</span><span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute metrics
</span><span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
             precision    recall  f1-score   support

   democrat       0.99      0.96      0.98        85
 republican       0.94      0.98      0.96        46

avg / total       0.97      0.97      0.97       131

</code></pre></div></div>

<p>###
<strong>Centering and scaling</strong></p>

<p>####
<strong>Centering and scaling your data</strong></p>

<p>You will now explore scaling for yourself on a new dataset –
 <a href="https://archive.ics.uci.edu/ml/datasets/Wine+Quality">White Wine Quality</a>
 !</p>

<p>We have used the
 <code class="language-plaintext highlighter-rouge">'quality'</code>
 feature of the wine to create a binary target variable: If
 <code class="language-plaintext highlighter-rouge">'quality'</code>
 is less than
 <code class="language-plaintext highlighter-rouge">5</code>
 , the target variable is
 <code class="language-plaintext highlighter-rouge">1</code>
 , and otherwise, it is
 <code class="language-plaintext highlighter-rouge">0</code>
 .</p>

<p>Notice how some features seem to have different units of measurement.
 <code class="language-plaintext highlighter-rouge">'density'</code>
 , for instance, takes values between 0.98 and 1.04, while
 <code class="language-plaintext highlighter-rouge">'total sulfur dioxide'</code>
 ranges from 9 to 440. As a result, it may be worth scaling the features here. Your job in this exercise is to scale the features and compute the mean and standard deviation of the unscaled features compared to the scaled features.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># white wine quality data set
</span><span class="n">df</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">fixed</span> <span class="n">acidity</span>  <span class="n">volatile</span> <span class="n">acidity</span>  <span class="n">citric</span> <span class="n">acid</span>  <span class="n">residual</span> <span class="n">sugar</span>  <span class="n">chlorides</span>  \
<span class="mi">0</span>            <span class="mf">7.0</span>              <span class="mf">0.27</span>         <span class="mf">0.36</span>            <span class="mf">20.7</span>      <span class="mf">0.045</span>
<span class="mi">1</span>            <span class="mf">6.3</span>              <span class="mf">0.30</span>         <span class="mf">0.34</span>             <span class="mf">1.6</span>      <span class="mf">0.049</span>
<span class="mi">2</span>            <span class="mf">8.1</span>              <span class="mf">0.28</span>         <span class="mf">0.40</span>             <span class="mf">6.9</span>      <span class="mf">0.050</span>

   <span class="n">free</span> <span class="n">sulfur</span> <span class="n">dioxide</span>  <span class="n">total</span> <span class="n">sulfur</span> <span class="n">dioxide</span>  <span class="n">density</span>    <span class="n">pH</span>  <span class="n">sulphates</span>  \
<span class="mi">0</span>                 <span class="mf">45.0</span>                 <span class="mf">170.0</span>   <span class="mf">1.0010</span>  <span class="mf">3.00</span>       <span class="mf">0.45</span>
<span class="mi">1</span>                 <span class="mf">14.0</span>                 <span class="mf">132.0</span>   <span class="mf">0.9940</span>  <span class="mf">3.30</span>       <span class="mf">0.49</span>
<span class="mi">2</span>                 <span class="mf">30.0</span>                  <span class="mf">97.0</span>   <span class="mf">0.9951</span>  <span class="mf">3.26</span>       <span class="mf">0.44</span>

   <span class="n">alcohol</span>  <span class="n">quality</span>
<span class="mi">0</span>      <span class="mf">8.8</span>        <span class="mi">6</span>
<span class="mi">1</span>      <span class="mf">9.5</span>        <span class="mi">6</span>
<span class="mi">2</span>     <span class="mf">10.1</span>        <span class="mi">6</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import scale
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>

<span class="c1"># Scale the features: X_scaled
</span><span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># Print the mean and standard deviation of the unscaled features
</span><span class="k">print</span><span class="p">(</span><span class="s">"Mean of Unscaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Standard Deviation of Unscaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>

<span class="c1"># Print the mean and standard deviation of the scaled features
</span><span class="k">print</span><span class="p">(</span><span class="s">"Mean of Scaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Standard Deviation of Scaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Mean of Unscaled Features: 18.432687072460002
Standard Deviation of Unscaled Features: 41.54494764094571

Mean of Scaled Features: 2.7314972981668206e-15
Standard Deviation of Scaled Features: 0.9999999999999999

</code></pre></div></div>

<p>####
<strong>Centering and scaling in a pipeline</strong></p>

<p>With regard to whether or not scaling is effective, the proof is in the pudding! See for yourself whether or not scaling the features of the White Wine Quality dataset has any impact on its performance.</p>

<p>You will use a k-NN classifier as part of a pipeline that includes scaling, and for the purposes of comparison, a k-NN classifier trained on the unscaled data has been provided.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>

<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
        <span class="p">(</span><span class="s">'knn'</span><span class="p">,</span> <span class="n">KNeighborsClassifier</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Fit the pipeline to the training set: knn_scaled
</span><span class="n">knn_scaled</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Instantiate and fit a k-NN classifier to the unscaled data
</span><span class="n">knn_unscaled</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">().</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Compute and print metrics
</span><span class="k">print</span><span class="p">(</span><span class="s">'Accuracy with Scaling: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">knn_scaled</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Accuracy without Scaling: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">knn_unscaled</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>

<span class="n">Accuracy</span> <span class="k">with</span> <span class="n">Scaling</span><span class="p">:</span> <span class="mf">0.7700680272108843</span>
<span class="n">Accuracy</span> <span class="n">without</span> <span class="n">Scaling</span><span class="p">:</span> <span class="mf">0.6979591836734694</span>

</code></pre></div></div>

<p>It looks like scaling has significantly improved model performance!</p>

<hr />

<p>####
<strong>Bringing it all together I: Pipeline for classification</strong></p>

<p>It is time now to piece together everything you have learned so far into a pipeline for classification! Your job in this exercise is to build a pipeline that includes scaling and hyperparameter tuning to classify wine quality.</p>

<p>You’ll return to using the SVM classifier you were briefly introduced to earlier in this chapter. The hyperparameters you will tune are C and gamma. C controls the regularization strength. It is analogous to the C you tuned for logistic regression in Chapter 3, while gamma controls the kernel coefficient:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup the pipeline
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
         <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Specify the hyperparameter space
</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">'SVM__C'</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
              <span class="s">'SVM__gamma'</span><span class="p">:[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]}</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>

<span class="c1"># Instantiate the GridSearchCV object: cv
</span><span class="n">cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="c1"># Fit to the training set
</span><span class="n">cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print metrics
</span><span class="k">print</span><span class="p">(</span><span class="s">"Accuracy: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned Model Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Accuracy: 0.7795918367346939
             precision    recall  f1-score   support

      False       0.83      0.85      0.84       662
       True       0.67      0.63      0.65       318

avg / total       0.78      0.78      0.78       980

Tuned Model Parameters: {'SVM__C': 10, 'SVM__gamma': 0.1}

</code></pre></div></div>

<p>####
<strong>Bringing it all together II: Pipeline for regression</strong></p>

<p>Your job is to build a pipeline that imputes the missing data, scales the features, and fits an ElasticNet to the Gapminder data. You will then tune the
 <code class="language-plaintext highlighter-rouge">l1_ratio</code>
 of your ElasticNet using GridSearchCV.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'mean'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
         <span class="p">(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
         <span class="p">(</span><span class="s">'elasticnet'</span><span class="p">,</span> <span class="n">ElasticNet</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Specify the hyperparameter space
</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">'elasticnet__l1_ratio'</span><span class="p">:</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">30</span><span class="p">)}</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the GridSearchCV object: gm_cv
</span><span class="n">gm_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="c1"># Fit to the training set
</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Compute and print the metrics
</span><span class="n">r2</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet Alpha: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet R squared: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span>

<span class="c1">#    Tuned ElasticNet Alpha: {'elasticnet__l1_ratio': 1.0}
#    Tuned ElasticNet R squared: 0.8862016570888217
</span>
</code></pre></div></div>

<p>The End.</p>

<p>Thank you for reading.</p>

<hr />

<ol>
  <li>
    <h2 id="classification-2">Classification</h2>
  </li>
</ol>

<p>###
<strong>Machine learning introduction</strong></p>

<p><strong>What is machine learning?</strong>
 Giving computers the ability to learn to make decisions from data without being explicitly programmed</p>

<p><strong>Examples of machine learning:</strong>
 Learning to predict whether an email is spam or not (supervised)</p>

<p>Clustering Wikipedia entries into different categories (unsupervised)</p>

<p>####
<strong>Types of Machine Learning</strong></p>

<ul>
  <li>supervised learning</li>
  <li>unsupervised learning</li>
  <li>reinforcement learning</li>
</ul>

<p><strong>Supervised learning:</strong></p>

<p>Predictor variables/
 <strong>features</strong>
 and a
 <strong>target variable</strong></p>

<p>Aim: Predict the target variable, given the predictor variables</p>

<p>Classification: Target variable consists of categories</p>

<p>Regression: Target variable is continuous</p>

<p><strong>Unsupervised learning:</strong></p>

<p>Uncovering hidden patterns from unlabeled data</p>

<p>Example of unsupervised learning:</p>

<p>Grouping customers into distinct categories (Clustering)</p>

<p><strong>Reinforcement learning:</strong>
 Software agents interact with an environment</p>

<p>Learn how to optimize their behavior</p>

<p>Given a system of rewards and punishments</p>

<p>Applications</p>

<p>Economics</p>

<p>Genetics</p>

<p>Game playing (AlphaGo)</p>

<p>####
 Naming conventions</p>

<ul>
  <li>Features = predictor variables = independent variables</li>
  <li>Target variable = dependent variable = response variable</li>
</ul>

<hr />

<p>####
 Features of
 <strong>Supervised learning</strong></p>

<ul>
  <li>Automate time-consuming or expensive manual tasks (ex. Doctor’s diagnosis)</li>
  <li>Make predictions about the future (ex. Will a customer click on an ad or not)</li>
  <li>Need labeled data (Historical data with labels etc.)</li>
</ul>

<p>####
<strong>Popular libraries</strong></p>

<ul>
  <li>scikit-learning (basic)</li>
  <li>TensorFlow</li>
  <li>keras</li>
</ul>

<hr />

<p>###
<strong>Exploratory data analysis</strong></p>

<p>####
<strong>Numerical EDA</strong></p>

<p>In this chapter, you’ll be working with a dataset obtained from the
 <a href="https://archive.ics.uci.edu/ml/datasets/Congressional+Voting+Records">UCI Machine Learning Repository</a>
 consisting of votes made by US House of Representatives Congressmen.</p>

<p>Your goal will be to predict their party affiliation (‘Democrat’ or ‘Republican’) based on how they voted on certain key issues.</p>

<p>Here, it’s worth noting that we have preprocessed this dataset to deal with missing values. This is so that your focus can be directed towards understanding how to train and evaluate supervised learning models.</p>

<p>Once you have mastered these fundamentals, you will be introduced to preprocessing techniques in Chapter 4 and have the chance to apply them there yourself – including on this very same dataset!</p>

<p>Before thinking about what supervised learning models you can apply to this, however, you need to perform Exploratory data analysis (EDA) in order to understand the structure of the data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
        party  infants  water  budget  physician  salvador  religious  \
0  republican        0      1       0          1         1          1
1  republican        0      1       0          1         1          1
2    democrat        0      1       1          0         1          1
3    democrat        0      1       1          0         1          1
4    democrat        1      1       1          0         1          1

   satellite  aid  missile  immigration  synfuels  education  superfund  \
0          0    0        0            1         0          1          1
1          0    0        0            0         0          1          1
2          0    0        0            0         1          0          1
3          0    0        0            0         1          0          1
4          0    0        0            0         1          0          1

   crime  duty_free_exports  eaa_rsa
0      1                  0        1
1      1                  0        1
2      1                  0        0
3      0                  0        1
4      1                  1        1

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 435 entries, 0 to 434
Data columns (total 17 columns):
party                435 non-null object
infants              435 non-null int64
water                435 non-null int64
budget               435 non-null int64
physician            435 non-null int64
salvador             435 non-null int64
religious            435 non-null int64
satellite            435 non-null int64
aid                  435 non-null int64
missile              435 non-null int64
immigration          435 non-null int64
synfuels             435 non-null int64
education            435 non-null int64
superfund            435 non-null int64
crime                435 non-null int64
duty_free_exports    435 non-null int64
eaa_rsa              435 non-null int64
dtypes: int64(16), object(1)
memory usage: 57.9+ KB

</code></pre></div></div>

<p>###
<strong>Visual EDA</strong></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture-21.png" alt="Desktop View" /></p>

<p>Above is a
 <code class="language-plaintext highlighter-rouge">countplot</code>
 of the
 <code class="language-plaintext highlighter-rouge">'education'</code>
 bill, generated from the following code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.figure()
sns.countplot(x='education', hue='party', data=df, palette='RdBu')
plt.xticks([0,1], ['No', 'Yes'])
plt.show()

</code></pre></div></div>

<p>In
 <code class="language-plaintext highlighter-rouge">sns.countplot()</code>
 , we specify the x-axis data to be
 <code class="language-plaintext highlighter-rouge">'education'</code>
 , and hue to be
 <code class="language-plaintext highlighter-rouge">'party'</code>
 . Recall that
 <code class="language-plaintext highlighter-rouge">'party'</code>
 is also our target variable. So the resulting plot shows the difference in voting behavior between the two parties for the
 <code class="language-plaintext highlighter-rouge">'education'</code>
 bill, with each party colored differently. We manually specified the color to be
 <code class="language-plaintext highlighter-rouge">'RdBu'</code>
 , as the Republican party has been traditionally associated with red, and the Democratic party with blue.</p>

<p>It seems like Democrats voted resoundingly
 <em>against</em>
 this bill, compared to Republicans.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.figure()
sns.countplot(x='missile', hue='party', data=df, palette='RdBu')
plt.xticks([0,1], ['No', 'Yes'])
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture1-20.png" alt="Desktop View" /></p>

<p>Democrats vote resoundingly in
 <em>favor</em>
 of missile, compared to Republicans.</p>

<hr />

<p>###
<strong>The classification challenge</strong></p>

<p>####
<strong>k-Nearest Neighbors: Fit</strong></p>

<p><a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">k-nearest neighbors algorithm</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import KNeighborsClassifier from sklearn.neighbors
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="c1"># Create arrays for the features and the response variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'party'</span><span class="p">].</span><span class="n">values</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">'party'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>

<span class="c1"># Create a k-NN classifier with 6 neighbors
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

</code></pre></div></div>

<p>####
<strong>k-Nearest Neighbors: Predict</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import KNeighborsClassifier from sklearn.neighbors
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="c1"># Create arrays for the features and the response variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'party'</span><span class="p">]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">'party'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>

<span class="c1"># Create a k-NN classifier with 6 neighbors: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Predict the labels for the training data X
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># Predict and print the label for the new data point X_new
</span><span class="n">new_prediction</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Prediction: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">new_prediction</span><span class="p">))</span>

<span class="c1"># Prediction: ['democrat']
</span>
</code></pre></div></div>

<p>How sure can you be of its predictions? In other words, how can you measure its performance?</p>

<hr />

<p>###
<strong>Measuring model performance</strong></p>

<p>####
<strong>The digits recognition dataset: MNIST</strong></p>

<p>In the following exercises, you’ll be working with the
 <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>
 digits recognition dataset, which has 10 classes, the digits 0 through 9! A reduced version of the MNIST dataset is one of scikit-learn’s included datasets, and that is the one we will use in this exercise.</p>

<p>Each sample in this scikit-learn dataset is an 8×8 image representing a handwritten digit. Each pixel is represented by an integer in the range 0 to 16, indicating varying levels of black.</p>

<p>It is a famous dataset in machine learning and computer vision, and frequently used as a benchmark to evaluate the performance of a new model.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Load the digits dataset: digits
</span><span class="n">digits</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">.</span><span class="n">load_digits</span><span class="p">()</span>

<span class="c1"># Print the keys and DESCR of the dataset
</span><span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
<span class="c1">#dict_keys(['data', 'target', 'target_names', 'images', 'DESCR'])
</span>
<span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">DESCR</span><span class="p">)</span>
<span class="o">/*</span>
<span class="n">Optical</span> <span class="n">Recognition</span> <span class="n">of</span> <span class="n">Handwritten</span> <span class="n">Digits</span> <span class="n">Data</span> <span class="n">Set</span>
<span class="o">===================================================</span>

<span class="n">Notes</span>
<span class="o">-----</span>
<span class="n">Data</span> <span class="n">Set</span> <span class="n">Characteristics</span><span class="p">:</span>
    <span class="p">:</span><span class="n">Number</span> <span class="n">of</span> <span class="n">Instances</span><span class="p">:</span> <span class="mi">5620</span>
    <span class="p">:</span><span class="n">Number</span> <span class="n">of</span> <span class="n">Attributes</span><span class="p">:</span> <span class="mi">64</span>
    <span class="p">:</span><span class="n">Attribute</span> <span class="n">Information</span><span class="p">:</span> <span class="mi">8</span><span class="n">x8</span> <span class="n">image</span> <span class="n">of</span> <span class="n">integer</span> <span class="n">pixels</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">range</span> <span class="mf">0.</span><span class="p">.</span><span class="mf">16.</span>
    <span class="p">:</span><span class="n">Missing</span> <span class="n">Attribute</span> <span class="n">Values</span><span class="p">:</span> <span class="bp">None</span>
    <span class="p">:</span><span class="n">Creator</span><span class="p">:</span> <span class="n">E</span><span class="p">.</span> <span class="n">Alpaydin</span> <span class="p">(</span><span class="n">alpaydin</span> <span class="s">'@'</span> <span class="n">boun</span><span class="p">.</span><span class="n">edu</span><span class="p">.</span><span class="n">tr</span><span class="p">)</span>
    <span class="p">:</span><span class="n">Date</span><span class="p">:</span> <span class="n">July</span><span class="p">;</span> <span class="mi">1998</span>
<span class="p">...</span>
<span class="o">*/</span>

<span class="c1"># Print the shape of the images and data keys
</span><span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">images</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

<span class="c1"># Display digit 1010
</span><span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">images</span><span class="p">[</span><span class="mi">1010</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">gray_r</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">'nearest'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture2-19.png" alt="Desktop View" /></p>

<p>####
<strong>Train/Test Split + Fit/Predict/Accuracy</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Create feature and target arrays
</span><span class="n">X</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">data</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">target</span>

<span class="c1"># Split into training and test set
#  Stratify the split according to the labels so that they are distributed in the training and test sets as they are in the original dataset.
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

<span class="c1"># Create a k-NN classifier with 7 neighbors: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Print the accuracy
</span><span class="k">print</span><span class="p">(</span><span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
<span class="c1"># 0.983333333333
</span>
</code></pre></div></div>

<p>Incredibly, this out of the box k-NN classifier with 7 neighbors has learned from the training data and predicted the labels of the images in the test set with 98% accuracy, and it did so in less than a second! This is one illustration of how incredibly useful machine learning techniques can be.</p>

<hr />

<p>####
<strong>Overfitting and underfitting</strong></p>

<p>In this exercise, you will compute and plot the training and testing accuracy scores for a variety of different neighbor values. By observing how the accuracy scores differ for the training and testing sets with different values of k, you will develop your intuition for overfitting and underfitting.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup arrays to store train and test accuracies
</span><span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">train_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>
<span class="n">test_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>

<span class="c1"># Loop over different values of k
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
    <span class="c1"># Setup a k-NN Classifier with k neighbors: knn
</span>    <span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># Fit the classifier to the training data
</span>    <span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1">#Compute accuracy on the training set
</span>    <span class="n">train_accuracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1">#Compute accuracy on the testing set
</span>    <span class="n">test_accuracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

<span class="c1"># Generate plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'k-NN: Varying Number of Neighbors'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">test_accuracy</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Testing Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">train_accuracy</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Training Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Number of Neighbors'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture3-18.png" alt="Desktop View" /></p>

<p>It looks like the test accuracy is highest when using 3 and 5 neighbors. Using 8 neighbors or more seems to result in a simple model that underfits the data.</p>

<hr />

<h1 id="2-regression-2"><strong>2. Regression</strong></h1>
<hr />

<p>###
<strong>Introduction to regression</strong></p>

<p>####
<strong>Importing data for supervised learning</strong></p>

<p>In this chapter, you will work with
 <a href="https://www.gapminder.org/data/">Gapminder</a>
 data that we have consolidated into one CSV file available in the workspace as
 <code class="language-plaintext highlighter-rouge">'gapminder.csv'</code>
 . Specifically, your goal will be to use this data to predict the life expectancy in a given country based on features such as the country’s GDP, fertility rate, and population.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import numpy and pandas
</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Read the CSV file into a DataFrame: df
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'gapminder.csv'</span><span class="p">)</span>

<span class="c1"># Create arrays for features and target variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'life'</span><span class="p">].</span><span class="n">values</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'fertility'</span><span class="p">].</span><span class="n">values</span>

<span class="c1"># Print the dimensions of X and y before reshaping
</span><span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of y before reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of X before reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Dimensions of y before reshaping: (139,)
# Dimensions of X before reshaping: (139,)
</span>

<span class="c1"># Reshape X and y
</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the dimensions of X and y after reshaping
</span><span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of y after reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of X after reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Dimensions of y after reshaping: (139, 1)
# Dimensions of X after reshaping: (139, 1)
</span>
</code></pre></div></div>

<p>####
<strong>Exploring the Gapminder data</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 139 entries, 0 to 138
Data columns (total 9 columns):
population         139 non-null float64
fertility          139 non-null float64
HIV                139 non-null float64
CO2                139 non-null float64
BMI_male           139 non-null float64
GDP                139 non-null float64
BMI_female         139 non-null float64
life               139 non-null float64
child_mortality    139 non-null float64
dtypes: float64(9)
memory usage: 9.9 KB

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
sns.heatmap(df.corr(), square=True, cmap='RdYlGn')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture4-17.png" alt="Desktop View" /></p>

<p>###
<strong>The basics of linear regression</strong></p>

<p>We suppose that y and x have a linear relationship that can be model by</p>

<p>y = ax + b</p>

<p>An linear regression is to find a, b that minimize the sum of the squared residual (= Ordinary Least Squares, OLS)</p>

<p>Why squared residual?</p>

<p>Residuals may be positive and negative.</p>

<p>They cancel each other. square residual can solve this problem.</p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture6-11.png" alt="Desktop View" /></p>

<p>green lines are residuals</p>

<p>When we have n variables of x,</p>

<p>y = a1<em>x1 + a2</em>x2 + … an*xn + b</p>

<p>we find a1, a2, … an, b that minimize the sum of the squared residual.</p>

<p>####
<strong>Fit &amp; predict for regression</strong></p>

<p>In this exercise, you will use the
 <code class="language-plaintext highlighter-rouge">'fertility'</code>
 feature of the Gapminder dataset. Since the goal is to predict life expectancy, the target variable here is
 <code class="language-plaintext highlighter-rouge">'life'</code>
 .</p>

<p>You will also compute and print the R2 score using sckit-learn’s
 <code class="language-plaintext highlighter-rouge">.score()</code>
 method.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import LinearRegression
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="c1"># Create the regressor: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Create the prediction space
</span><span class="n">prediction_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">)).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Fit the model to the data
</span><span class="n">reg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Compute predictions over the prediction space: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">prediction_space</span><span class="p">)</span>

<span class="c1"># Print R^2
</span><span class="k">print</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="mf">0.619244216774</span>

<span class="c1"># Plot regression line
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">prediction_space</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'black'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture7-12.png" alt="Desktop View" /></p>

<p>####
<strong>Train/test split for regression</strong></p>

<p>In this exercise, you will split the Gapminder dataset into training and testing sets, and then fit and predict a linear regression over
 <strong>all</strong>
 features. In addition to computing the R2 score, you will also compute the Root Mean Squared Error (RMSE), which is another commonly used metric to evaluate regression models.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the regressor: reg_all
</span><span class="n">reg_all</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Fit the regressor to the training data
</span><span class="n">reg_all</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict on the test data: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg_all</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print R^2 and RMSE
</span><span class="k">print</span><span class="p">(</span><span class="s">"R^2: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">reg_all</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="c1"># R^2: 0.838046873142936
</span>

<span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Root Mean Squared Error: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">rmse</span><span class="p">))</span>
<span class="c1"># Root Mean Squared Error: 3.2476010800377213
</span>

</code></pre></div></div>

<p>###
<strong>Cross-validation</strong></p>

<p>What is cross validation?</p>

<p><a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)">https://en.wikipedia.org/wiki/Cross-validation_(statistics)</a></p>

<p>####
<strong>5-fold cross-validation</strong></p>

<p>In this exercise, you will practice 5-fold cross validation on the Gapminder data. By default, scikit-learn’s
 <code class="language-plaintext highlighter-rouge">cross_val_score()</code>
 function uses R2R2 as the metric of choice for regression.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Create a linear regression object: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Compute 5-fold cross-validation scores: cv_scores
</span><span class="n">cv_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Print the 5-fold cross-validation scores
</span><span class="k">print</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)</span>
<span class="c1"># [ 0.81720569  0.82917058  0.90214134  0.80633989  0.94495637]
</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Average 5-Fold CV Score: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)))</span>
<span class="c1"># Average 5-Fold CV Score: 0.8599627722793232
</span>
</code></pre></div></div>

<p>####
<strong>K-Fold CV comparison</strong></p>

<p>Cross validation is essential but do not forget that the more folds you use, the more computationally expensive cross-validation becomes. In this exercise, you will explore this for yourself. Your job is to perform 3-fold cross-validation and then 10-fold cross-validation on the Gapminder dataset.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Create a linear regression object: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Perform 3-fold CV
</span><span class="n">cvscores_3</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvscores_3</span><span class="p">))</span>
<span class="c1"># 0.871871278262
</span>
<span class="c1"># Perform 10-fold CV
</span><span class="n">cvscores_10</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvscores_10</span><span class="p">))</span>
<span class="c1"># 0.843612862013
</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
%timeit cross_val_score(reg, X, y, cv=3)
100 loops, best of 3: 8.73 ms per loop

%timeit cross_val_score(reg, X, y, cv=10)
10 loops, best of 3: 27.5 ms per loop

</code></pre></div></div>

<hr />

<p>###
<strong>Regularized regression</strong></p>

<p>####
<strong><a href="https://en.wikipedia.org/wiki/Lasso_(statistics)">Regularization I: Lasso</a></strong></p>

<p>In this exercise, you will fit a lasso regression to the Gapminder data you have been working with and plot the coefficients. Just as with the Boston data, you will find that the coefficients of some features are shrunk to 0, with only the most important ones remaining.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.columns
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality'],
      dtype='object')

X: ['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'child_mortality']
y: life

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import Lasso
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Lasso</span>

<span class="c1"># Instantiate a lasso regressor: lasso
</span><span class="n">lasso</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Fit the regressor to the data
</span><span class="n">lasso</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Compute and print the coefficients
</span><span class="n">lasso_coef</span> <span class="o">=</span> <span class="n">lasso</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">).</span><span class="n">coef_</span>
<span class="k">print</span><span class="p">(</span><span class="n">lasso_coef</span><span class="p">)</span>
<span class="c1">#  [-0.         -0.         -0.          0.          0.          0.         -0.
</span>     <span class="o">-</span><span class="mf">0.07087587</span><span class="p">]</span>


<span class="c1"># Plot the coefficients
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_columns</span><span class="p">)),</span> <span class="n">lasso_coef</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_columns</span><span class="p">)),</span> <span class="n">df_columns</span><span class="p">.</span><span class="n">values</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture8-9.png" alt="Desktop View" /></p>

<p>According to the lasso algorithm, it seems like
 <code class="language-plaintext highlighter-rouge">'child_mortality'</code>
 is the most important feature when predicting life expectancy.</p>

<p>####
<strong>Regularization II: Ridge</strong></p>

<p>Lasso is great for feature selection, but when building regression models, Ridge regression should be your first choice.</p>

<p>Recall that lasso performs regularization by adding to the loss function a penalty term of the
 <em>absolute</em>
 value of each coefficient multiplied by some alpha. This is also known as L1L1 regularization because the regularization term is the L1L1 norm of the coefficients. This is not the only way to regularize, however.</p>

<p>If instead you took the sum of the
 <em>squared</em>
 values of the coefficients multiplied by some alpha – like in Ridge regression – you would be computing the L2L2norm. In this exercise, you will practice fitting ridge regression models over a range of different alphas, and plot cross-validated R2R2 scores for each, using this function that we have defined for you, which plots the R2R2 score as well as standard error for each alpha:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def display_plot(cv_scores, cv_scores_std):
    fig = plt.figure()
    ax = fig.add_subplot(1,1,1)
    ax.plot(alpha_space, cv_scores)

    std_error = cv_scores_std / np.sqrt(10)

    ax.fill_between(alpha_space, cv_scores + std_error, cv_scores - std_error, alpha=0.2)
    ax.set_ylabel('CV Score +/- Std Error')
    ax.set_xlabel('Alpha')
    ax.axhline(np.max(cv_scores), linestyle='--', color='.5')
    ax.set_xlim([alpha_space[0], alpha_space[-1]])
    ax.set_xscale('log')
    plt.show()


</code></pre></div></div>

<p>Don’t worry about the specifics of the above function works. The motivation behind this exercise is for you to see how the R2R2 score varies with different alphas, and to understand the importance of selecting the right value for alpha. You’ll learn how to tune alpha in the next chapter.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Setup the array of alphas and lists to store scores
</span><span class="n">alpha_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">ridge_scores</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ridge_scores_std</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Create a ridge regressor: ridge
</span><span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Compute scores over range of alphas
</span><span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">alpha_space</span><span class="p">:</span>

    <span class="c1"># Specify the alpha value to use: ridge.alpha
</span>    <span class="n">ridge</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="c1"># Perform 10-fold CV: ridge_cv_scores
</span>    <span class="n">ridge_cv_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="c1"># Append the mean of ridge_cv_scores to ridge_scores
</span>    <span class="n">ridge_scores</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ridge_cv_scores</span><span class="p">))</span>

    <span class="c1"># Append the std of ridge_cv_scores to ridge_scores_std
</span>    <span class="n">ridge_scores_std</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">ridge_cv_scores</span><span class="p">))</span>

<span class="c1"># Display the plot
</span><span class="n">display_plot</span><span class="p">(</span><span class="n">ridge_scores</span><span class="p">,</span> <span class="n">ridge_scores_std</span><span class="p">)</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture9-8.png" alt="Desktop View" /></p>

<p>Notice how the cross-validation scores change with different alphas.</p>

<hr />

<h1 id="3-fine-tuning-your-model-2"><strong>3. Fine-tuning your model</strong></h1>
<hr />

<p>###
<strong>confusion matrix</strong></p>

<p>What is confusion matrix</p>

<p><a href="https://en.wikipedia.org/wiki/Confusion_matrix">https://en.wikipedia.org/wiki/Confusion_matrix</a></p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f02ea353bf60bfdd9557d2c98fe18c34cd8db835" alt="{\displaystyle \mathrm {TPR} ={\frac {\mathrm {TP} }{\mathrm {P} }}={\frac {\mathrm {TP} }{\mathrm {TP} +\mathrm {FN} }}=1-\mathrm {FNR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">sensitivity</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Precision_and_recall#Recall">recall</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Hit_rate">hit rate</a>
 , or
 <a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">true positive rate</a>
 (TPR)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8f2c867f0641e498ec8a59de63697a3a45d66b07" alt="{\displaystyle \mathrm {TNR} ={\frac {\mathrm {TN} }{\mathrm {N} }}={\frac {\mathrm {TN} }{\mathrm {TN} +\mathrm {FP} }}=1-\mathrm {FPR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Specificity_(tests)">specificity</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Specificity_(tests)">selectivity</a>
 or
 <a href="https://en.wikipedia.org/wiki/Specificity_(tests)">true negative rate</a>
 (TNR)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d854b1544fc77735d575ce0d30e34d7f1eacf707" alt="{\displaystyle \mathrm {PPV} ={\frac {\mathrm {TP} }{\mathrm {TP} +\mathrm {FP} }}=1-\mathrm {FDR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision">precision</a>
 or
 <a href="https://en.wikipedia.org/wiki/Positive_predictive_value">positive predictive value</a>
 (PPV)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47deb47eb7ac214423d0a6afd05ec0af362fef9b" alt="{\displaystyle \mathrm {ACC} ={\frac {\mathrm {TP} +\mathrm {TN} }{\mathrm {P} +\mathrm {N} }}={\frac {\mathrm {TP} +\mathrm {TN} }{\mathrm {TP} +\mathrm {TN} +\mathrm {FP} +\mathrm {FN} }}}" /></p>

<p><a href="https://en.wikipedia.org/wiki/Accuracy">accuracy</a>
 (ACC)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0e5f071c6418f444fadc9f5f9b0358beed3e094c" alt="{\displaystyle \mathrm {F} _{1}=2\cdot {\frac {\mathrm {PPV} \cdot \mathrm {TPR} }{\mathrm {PPV} +\mathrm {TPR} }}={\frac {2\mathrm {TP} }{2\mathrm {TP} +\mathrm {FP} +\mathrm {FN} }}}" /></p>

<p><a href="https://en.wikipedia.org/wiki/F1_score">F1 score</a>
 is the
 <a href="https://en.wikipedia.org/wiki/Harmonic_mean#Harmonic_mean_of_two_numbers">harmonic mean</a>
 of
 <a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision">precision</a>
 and
 <a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">sensitivity</a></p>

<p>####
<strong>illustration for TPR, TNR and PPV</strong></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/metric_example.png?w=1024" alt="Desktop View" /></p>

<p><a href="http://corysimon.github.io/articles/classification-metrics/">source</a></p>

<p>####
<strong>Metrics for classification</strong></p>

<p>In this exercise, you will dive more deeply into evaluating the performance of binary classifiers by computing a confusion matrix and generating a classification report.</p>

<p>Here, you’ll work with the
 <a href="https://www.kaggle.com/uciml/pima-indians-diabetes-database">PIMA Indians</a>
 dataset obtained from the UCI Machine Learning Repository. The goal is to predict whether or not a given female patient will contract diabetes based on features such as BMI, age, and number of pregnancies.</p>

<p>Therefore, it is a binary classification problem. A target value of
 <code class="language-plaintext highlighter-rouge">0</code>
 indicates that the patient does
 <em>not</em>
 have diabetes, while a value of
 <code class="language-plaintext highlighter-rouge">1</code>
 indicates that the patient
 <em>does</em>
 have diabetes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 768 entries, 0 to 767
Data columns (total 9 columns):
pregnancies    768 non-null int64
glucose        768 non-null int64
diastolic      768 non-null int64
triceps        768 non-null float64
insulin        768 non-null float64
bmi            768 non-null float64
dpf            768 non-null float64
age            768 non-null int64
diabetes       768 non-null int64
dtypes: float64(4), int64(5)
memory usage: 54.1 KB

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>

<span class="c1"># Create training and test set
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Instantiate a k-NN classifier: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test data: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Generate the confusion matrix and classification report
</span><span class="k">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[[176  30]
 [ 52  50]]

             precision    recall  f1-score   support

          0       0.77      0.85      0.81       206
          1       0.62      0.49      0.55       102

avg / total       0.72      0.73      0.72       308

</code></pre></div></div>

<hr />

<p>###
<strong>Logistic regression and the ROC curve</strong></p>

<p>What is logistic regression?</p>

<p><a href="https://en.wikipedia.org/wiki/Logistic_regression">https://en.wikipedia.org/wiki/Logistic_regression</a></p>

<p>What is ROC?</p>

<p><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">Receiver operating characteristic</a></p>

<p>Further Reading:
 <a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.html#sphx-glr-auto-examples-model-selection-plot-roc-py">scikit-learn document</a></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/roc_space-2.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Building a logistic regression model</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
X.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 768 entries, 0 to 767
Data columns (total 8 columns):
pregnancies    768 non-null int64
glucose        768 non-null int64
diastolic      768 non-null int64
triceps        768 non-null float64
insulin        768 non-null float64
bmi            768 non-null float64
dpf            768 non-null float64
age            768 non-null int64
dtypes: float64(4), int64(4)
memory usage: 48.1 KB


y
0      1
1      0
2      1
      ..

765    0
766    1
767    0
Name: diabetes, dtype: int64

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span><span class="p">,</span> <span class="n">confusion_matrix</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">logreg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print the confusion matrix and classification report
</span><span class="k">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[[176  30]
 [ 35  67]]

             precision    recall  f1-score   support

          0       0.83      0.85      0.84       206
          1       0.69      0.66      0.67       102

avg / total       0.79      0.79      0.79       308

</code></pre></div></div>

<p>####
<strong>Plotting an ROC curve</strong></p>

<p><strong>.predict_proba()</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>

<span class="c1"># Compute predicted probabilities: y_pred_prob
</span><span class="n">y_pred_prob</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Generate ROC curve values: fpr, tpr, thresholds
</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_prob</span><span class="p">)</span>

<span class="c1"># Plot ROC curve
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s">'k--'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'False Positive Rate'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'True Positive Rate'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'ROC Curve'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
logreg.predict_proba(X_test)
# False, True
# 0, 1
# Negative, Positive
array([[ 0.60409835,  0.39590165],
       [ 0.76042394,  0.23957606],
       [ 0.79670177,  0.20329823],
       ...
       [ 0.84686912,  0.15313088],
       [ 0.97617225,  0.02382775],
       [ 0.40380502,  0.59619498]])

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture1-21.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Precision-recall Curve</strong></p>

<p>There are other ways to visually evaluate model performance. One such way is the precision-recall curve, which is generated by plotting the precision and recall for different thresholds.</p>

<p>Note that here, the class is positive (1) if the individual
 <em>has</em>
 diabetes.</p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture2-20.png?w=1024" alt="Desktop View" /></p>

<ul>
  <li>A recall of 1 corresponds to a classifier with a low threshold in which
 <em>all</em>
 females who contract diabetes were correctly classified as such, at the expense of many misclassifications of those who did
 <em>not</em>
 have diabetes.</li>
  <li>Precision is undefined for a classifier which makes
 <em>no</em>
 positive predictions, that is, classifies
 <em>everyone</em>
 as
 <em>not</em>
 having diabetes.</li>
  <li>When the threshold is very close to 1, precision is also 1, because the classifier is absolutely certain about its predictions.</li>
</ul>

<p>recall or sensitivity, TPR = 1 means all true positive are detected. We can predict all to positive to get a recall of 1.</p>

<p>precision, PPV = 1 means no false positive are detected. We can predict less positive to get a higher precision.</p>

<p>####
<strong>Area under the ROC curve</strong></p>

<p>####
<strong>AUC(</strong>
 Area Under the Curve
 <strong>) computation</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span><span class="n">df</span><span class="p">.</span><span class="n">head</span><span class="p">()</span>
   <span class="n">pregnancies</span>  <span class="n">glucose</span>  <span class="n">diastolic</span>   <span class="n">triceps</span>     <span class="n">insulin</span>   <span class="n">bmi</span>    <span class="n">dpf</span>  <span class="n">age</span>  \
<span class="mi">0</span>            <span class="mi">6</span>      <span class="mi">148</span>         <span class="mi">72</span>  <span class="mf">35.00000</span>  <span class="mf">155.548223</span>  <span class="mf">33.6</span>  <span class="mf">0.627</span>   <span class="mi">50</span>
<span class="mi">1</span>            <span class="mi">1</span>       <span class="mi">85</span>         <span class="mi">66</span>  <span class="mf">29.00000</span>  <span class="mf">155.548223</span>  <span class="mf">26.6</span>  <span class="mf">0.351</span>   <span class="mi">31</span>
<span class="mi">2</span>            <span class="mi">8</span>      <span class="mi">183</span>         <span class="mi">64</span>  <span class="mf">29.15342</span>  <span class="mf">155.548223</span>  <span class="mf">23.3</span>  <span class="mf">0.672</span>   <span class="mi">32</span>
<span class="mi">3</span>            <span class="mi">1</span>       <span class="mi">89</span>         <span class="mi">66</span>  <span class="mf">23.00000</span>   <span class="mf">94.000000</span>  <span class="mf">28.1</span>  <span class="mf">0.167</span>   <span class="mi">21</span>
<span class="mi">4</span>            <span class="mi">0</span>      <span class="mi">137</span>         <span class="mi">40</span>  <span class="mf">35.00000</span>  <span class="mf">168.000000</span>  <span class="mf">43.1</span>  <span class="mf">2.288</span>   <span class="mi">33</span>

   <span class="n">diabetes</span>
<span class="mi">0</span>         <span class="mi">1</span>
<span class="mi">1</span>         <span class="mi">0</span>
<span class="mi">2</span>         <span class="mi">1</span>
<span class="mi">3</span>         <span class="mi">0</span>
<span class="mi">4</span>         <span class="mi">1</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Compute predicted probabilities: y_pred_prob
</span><span class="n">y_pred_prob</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Compute and print AUC score
</span><span class="k">print</span><span class="p">(</span><span class="s">"AUC: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_prob</span><span class="p">)))</span>

<span class="c1"># Compute cross-validated AUC scores: cv_auc
</span><span class="n">cv_auc</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'roc_auc'</span><span class="p">)</span>

<span class="c1"># Print list of AUC scores
</span><span class="k">print</span><span class="p">(</span><span class="s">"AUC scores computed using 5-fold cross-validation: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv_auc</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
AUC: 0.8254806777079764

AUC scores computed using 5-fold cross-validation:
[ 0.80148148  0.8062963   0.81481481  0.86245283  0.8554717 ]

</code></pre></div></div>

<hr />

<p>###
<strong>Hyperparameter tuning</strong></p>

<p>####
<strong>Hyperparameter tuning with GridSearchCV</strong></p>

<p>You will now practice this yourself, but by using logistic regression on the diabetes dataset.</p>

<p>Like the alpha parameter of lasso and ridge regularization that you saw earlier, logistic regression also has a regularization parameter: CC. CC controls the
 <em>inverse</em>
 of the regularization strength, and this is what you will tune in this exercise. A large CC can lead to an
 <em>overfit</em>
 model, while a small CC can lead to an
 <em>underfit</em>
 model.</p>

<p>The hyperparameter space for CC has been setup for you. Your job is to use GridSearchCV and logistic regression to find the optimal CC in this hyperparameter space.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="c1"># Setup the hyperparameter grid
</span><span class="n">c_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'C'</span><span class="p">:</span> <span class="n">c_space</span><span class="p">}</span>

<span class="c1"># Instantiate a logistic regression classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Instantiate the GridSearchCV object: logreg_cv
</span><span class="n">logreg_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the data
</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Print the tuned parameters and score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Best score is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Logistic Regression Parameters: {'C': 3.7275937203149381}
Best score is 0.7708333333333334

</code></pre></div></div>

<p>####
<strong>Hyperparameter tuning with RandomizedSearchCV</strong></p>

<p>GridSearchCV can be computationally expensive, especially if you are searching over a large hyperparameter space and dealing with multiple hyperparameters. A solution to this is to use
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 , in which not all hyperparameter values are tried out. Instead, a fixed number of hyperparameter settings is sampled from specified probability distributions. You’ll practice using
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 in this exercise and see how this works.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">RandomizedSearchCV</span>

<span class="c1"># Setup the parameters and distributions to sample from: param_dist
</span><span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s">"max_depth"</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
              <span class="s">"max_features"</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="s">"min_samples_leaf"</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="s">"criterion"</span><span class="p">:</span> <span class="p">[</span><span class="s">"gini"</span><span class="p">,</span> <span class="s">"entropy"</span><span class="p">]}</span>

<span class="c1"># Instantiate a Decision Tree classifier: tree
</span><span class="n">tree</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">()</span>

<span class="c1"># Instantiate the RandomizedSearchCV object: tree_cv
</span><span class="n">tree_cv</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">param_dist</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the data
</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Print the tuned parameters and score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Decision Tree Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Best score is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Decision Tree Parameters: {'criterion': 'entropy', 'max_depth': 3, 'max_features': 7, 'min_samples_leaf': 1}
Best score is 0.7317708333333334

</code></pre></div></div>

<p>Note that
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 will never outperform
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 . Instead, it is valuable because it saves on computation time.</p>

<p>###
<strong>Hold-out set for final evaluation</strong></p>

<p>####
<strong>Hold-out set in practice I: Classification</strong></p>

<p>In addition to CC, logistic regression has a
 <code class="language-plaintext highlighter-rouge">'penalty'</code>
 hyperparameter which specifies whether to use
 <code class="language-plaintext highlighter-rouge">'l1'</code>
 or
 <code class="language-plaintext highlighter-rouge">'l2'</code>
 regularization. Your job in this exercise is to create a hold-out set, tune the
 <code class="language-plaintext highlighter-rouge">'C'</code>
 and
 <code class="language-plaintext highlighter-rouge">'penalty'</code>
 hyperparameters of a logistic regression classifier using
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 on the training set.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="c1"># Create the hyperparameter grid
</span><span class="n">c_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'C'</span><span class="p">:</span> <span class="n">c_space</span><span class="p">,</span> <span class="s">'penalty'</span><span class="p">:</span> <span class="p">[</span><span class="s">'l1'</span><span class="p">,</span> <span class="s">'l2'</span><span class="p">]}</span>

<span class="c1"># Instantiate the logistic regression classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Instantiate the GridSearchCV object: logreg_cv
</span><span class="n">logreg_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the training data
</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Print the optimal parameters and best score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Parameter: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Accuracy: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Logistic Regression Parameter: {'C': 0.43939705607607948, 'penalty': 'l1'}
Tuned Logistic Regression Accuracy: 0.7652173913043478

</code></pre></div></div>

<p>####
<strong>Hold-out set in practice II: Regression</strong></p>

<p>Remember lasso and ridge regression from the previous chapter? Lasso used the L1 penalty to regularize, while ridge used the L2 penalty. There is another type of regularized regression known as the elastic net. In elastic net regularization, the penalty term is a linear combination of the L1 and L2 penalties:</p>

<p><strong>a∗L1+b∗L2</strong></p>

<p>In scikit-learn, this term is represented by the
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 parameter: An
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 of
 <code class="language-plaintext highlighter-rouge">1</code>
 corresponds to an L1L1 penalty, and anything lower is a combination of L1L1 and L2L2.</p>

<p>In this exercise, you will
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 to tune the
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 of an elastic net model trained on the Gapminder data. As in the previous exercise, use a hold-out set to evaluate your model’s performance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5
3   2975029.0       1.40  0.1   1.804106  25.35542   7383.0    132.8108  72.5
4  21370348.0       1.96  0.1  18.016313  27.56373  41312.0    117.3755  81.5

   child_mortality
0             29.5
1            192.0
2             15.4
3             20.0
4              5.2


</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">ElasticNet</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">train_test_split</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the hyperparameter grid
</span><span class="n">l1_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'l1_ratio'</span><span class="p">:</span> <span class="n">l1_space</span><span class="p">}</span>

<span class="c1"># Instantiate the ElasticNet regressor: elastic_net
</span><span class="n">elastic_net</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">()</span>

<span class="c1"># Setup the GridSearchCV object: gm_cv
</span><span class="n">gm_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">elastic_net</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the training data
</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict on the test set and compute metrics
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">r2</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="n">mse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet l1 ratio: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet R squared: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet MSE: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">mse</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned ElasticNet l1 ratio: {'l1_ratio': 0.20689655172413793}
Tuned ElasticNet R squared: 0.8668305372460283
Tuned ElasticNet MSE: 10.05791413339844

</code></pre></div></div>

<hr />

<h2 id="preprocessing-and-pipelines-2"><strong>Preprocessing and pipelines</strong></h2>

<p>###
<strong>Preprocessing data</strong></p>

<p>####
<strong>Exploring categorical features</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5
3   2975029.0       1.40  0.1   1.804106  25.35542   7383.0    132.8108  72.5
4  21370348.0       1.96  0.1  18.016313  27.56373  41312.0    117.3755  81.5

   child_mortality                      Region
0             29.5  Middle East &amp; North Africa
1            192.0          Sub-Saharan Africa
2             15.4                     America
3             20.0       Europe &amp; Central Asia
4              5.2         East Asia &amp; Pacific

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import pandas
</span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Read 'gapminder.csv' into a DataFrame: df
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'gapminder.csv'</span><span class="p">)</span>

<span class="c1"># Create a boxplot of life expectancy per region
</span><span class="n">df</span><span class="p">.</span><span class="n">boxplot</span><span class="p">(</span><span class="s">'life'</span><span class="p">,</span> <span class="s">'Region'</span><span class="p">,</span> <span class="n">rot</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture3-19.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Creating dummy variables</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create dummy variables: df_region
</span><span class="n">df_region</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Print the columns of df_region
</span><span class="k">print</span><span class="p">(</span><span class="n">df_region</span><span class="p">.</span><span class="n">columns</span><span class="p">)</span>

<span class="c1"># Create dummy variables with drop_first=True: df_region
</span><span class="n">df_region</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">drop_first</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Print the new columns of df_region
</span><span class="k">print</span><span class="p">(</span><span class="n">df_region</span><span class="p">.</span><span class="n">columns</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality', 'Region_America',
       'Region_East Asia &amp; Pacific', 'Region_Europe &amp; Central Asia',
       'Region_Middle East &amp; North Africa', 'Region_South Asia',
       'Region_Sub-Saharan Africa'],
      dtype='object')

# Region_America has been dropped
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality', 'Region_East Asia &amp; Pacific',
       'Region_Europe &amp; Central Asia', 'Region_Middle East &amp; North Africa',
       'Region_South Asia', 'Region_Sub-Saharan Africa'],
      dtype='object')


df_region.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5

   child_mortality  Region_East Asia &amp; Pacific  Region_Europe &amp; Central Asia  \
0             29.5                           0                             0
1            192.0                           0                             0
2             15.4                           0                             0

   Region_Middle East &amp; North Africa  Region_South Asia  \
0                                  1                  0
1                                  0                  0
2                                  0                  0

   Region_Sub-Saharan Africa
0                          0
1                          1
2                          0

</code></pre></div></div>

<p>####
<strong>Regression with categorical features</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Instantiate a ridge regressor: ridge
</span><span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Perform 5-fold cross-validation: ridge_cv
</span><span class="n">ridge_cv</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Print the cross-validated scores
</span><span class="k">print</span><span class="p">(</span><span class="n">ridge_cv</span><span class="p">)</span>
<span class="p">[</span> <span class="mf">0.86808336</span>  <span class="mf">0.80623545</span>  <span class="mf">0.84004203</span>  <span class="mf">0.7754344</span>   <span class="mf">0.87503712</span><span class="p">]</span>

</code></pre></div></div>

<hr />

<p>###
<strong>Handling missing data</strong></p>

<p>####
<strong>Dropping missing data</strong></p>

<p>Now, it’s time for you to take care of these yourself!</p>

<p>The unprocessed dataset has been loaded into a DataFrame
 <code class="language-plaintext highlighter-rouge">df</code>
 . Explore it in the IPython Shell with the
 <code class="language-plaintext highlighter-rouge">.head()</code>
 method. You will see that there are certain data points labeled with a
 <code class="language-plaintext highlighter-rouge">'?'</code>
 . These denote missing values. As you saw in the video, different datasets encode missing values in different ways. Sometimes it may be a
 <code class="language-plaintext highlighter-rouge">'9999'</code>
 , other times a
 <code class="language-plaintext highlighter-rouge">0</code>
 – real-world data can be very messy! If you’re lucky, the missing values will already be encoded as
 <code class="language-plaintext highlighter-rouge">NaN</code>
 . We use
 <code class="language-plaintext highlighter-rouge">NaN</code>
 because it is an efficient and simplified way of internally representing missing data, and it lets us take advantage of pandas methods such as
 <code class="language-plaintext highlighter-rouge">.dropna()</code>
 and
 <code class="language-plaintext highlighter-rouge">.fillna()</code>
 , as well as scikit-learn’s Imputation transformer
 <code class="language-plaintext highlighter-rouge">Imputer()</code>
 .</p>

<p>In this exercise, your job is to convert the
 <code class="language-plaintext highlighter-rouge">'?'</code>
 s to NaNs, and then drop the rows that contain them from the DataFrame.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head(3)
        party infants water budget physician salvador religious satellite aid  \
0  republican       0     1      0         1        1         1         0   0
1  republican       0     1      0         1        1         1         0   0
2    democrat       ?     1      1         ?        1         1         0   0

  missile immigration synfuels education superfund crime duty_free_exports  \
0       0           1        ?         1         1     1                 0
1       0           0        0         1         1     1                 0
2       0           0        1         0         1     1                 0

  eaa_rsa
0       1
1       ?
2       0

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Convert '?' to NaN
</span><span class="n">df</span><span class="p">[</span><span class="n">df</span> <span class="o">==</span> <span class="s">'?'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">nan</span>

<span class="c1"># Print the number of NaNs
</span><span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">isnull</span><span class="p">().</span><span class="nb">sum</span><span class="p">())</span>

<span class="c1"># Print shape of original DataFrame
</span><span class="k">print</span><span class="p">(</span><span class="s">"Shape of Original DataFrame: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Drop missing values and print shape of new DataFrame
</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">dropna</span><span class="p">()</span>

<span class="c1"># Print shape of new DataFrame
</span><span class="k">print</span><span class="p">(</span><span class="s">"Shape of DataFrame After Dropping All Rows with Missing Values: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
party                  0
infants               12
water                 48
budget                11
physician             11
salvador              15
religious             11
satellite             14
aid                   15
missile               22
immigration            7
synfuels              21
education             31
superfund             25
crime                 17
duty_free_exports     28
eaa_rsa              104
dtype: int64
Shape of Original DataFrame: (435, 17)


Shape of DataFrame After Dropping All Rows with Missing Values: (232, 17)

</code></pre></div></div>

<p>When many values in your dataset are missing, if you drop them, you may end up throwing away valuable information along with the missing data. It’s better instead to develop an imputation strategy. This is where domain knowledge is useful, but in the absence of it, you can impute missing values with the mean or the median of the row or column that the missing value is in.</p>

<p>####
<strong>Imputing missing data in a ML Pipeline I</strong></p>

<p>As you’ve come to appreciate, there are many steps to building a model, from creating training and test sets, to fitting a classifier or regressor, to tuning its parameters, to evaluating its performance on new data. Imputation can be seen as the first step of this machine learning process, the entirety of which can be viewed within the context of a pipeline. Scikit-learn provides a pipeline constructor that allows you to piece together these steps into one process and thereby simplify your workflow.</p>

<p>You’ll now practice setting up a pipeline with two steps: the imputation step, followed by the instantiation of a classifier. You’ve seen three classifiers in this course so far: k-NN, logistic regression, and the decision tree. You will now be introduced to a fourth one – the Support Vector Machine, or
 <a href="http://scikit-learn.org/stable/modules/svm.html">SVM</a>
 .</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the Imputer module
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Imputer</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Setup the Imputation transformer: imp
# axis=0 for column
</span><span class="n">imp</span> <span class="o">=</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'most_frequent'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Instantiate the SVC classifier: clf
</span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">()</span>

<span class="c1"># Setup the pipeline with the required steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">imp</span><span class="p">),</span>
        <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">clf</span><span class="p">)]</span>

</code></pre></div></div>

<p>####
<strong>Imputing missing data in a ML Pipeline II</strong></p>

<p>Having setup the steps of the pipeline in the previous exercise, you will now use it on the voting dataset to classify a Congressman’s party affiliation.</p>

<p>What makes pipelines so incredibly useful is the simple interface that they provide. You can use the
 <code class="language-plaintext highlighter-rouge">.fit()</code>
 and
 <code class="language-plaintext highlighter-rouge">.predict()</code>
 methods on pipelines just as you did with your classifiers and regressors!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Imputer</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'most_frequent'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Fit the pipeline to the train set
</span><span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute metrics
</span><span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
             precision    recall  f1-score   support

   democrat       0.99      0.96      0.98        85
 republican       0.94      0.98      0.96        46

avg / total       0.97      0.97      0.97       131

</code></pre></div></div>

<p>###
<strong>Centering and scaling</strong></p>

<p>####
<strong>Centering and scaling your data</strong></p>

<p>You will now explore scaling for yourself on a new dataset –
 <a href="https://archive.ics.uci.edu/ml/datasets/Wine+Quality">White Wine Quality</a>
 !</p>

<p>We have used the
 <code class="language-plaintext highlighter-rouge">'quality'</code>
 feature of the wine to create a binary target variable: If
 <code class="language-plaintext highlighter-rouge">'quality'</code>
 is less than
 <code class="language-plaintext highlighter-rouge">5</code>
 , the target variable is
 <code class="language-plaintext highlighter-rouge">1</code>
 , and otherwise, it is
 <code class="language-plaintext highlighter-rouge">0</code>
 .</p>

<p>Notice how some features seem to have different units of measurement.
 <code class="language-plaintext highlighter-rouge">'density'</code>
 , for instance, takes values between 0.98 and 1.04, while
 <code class="language-plaintext highlighter-rouge">'total sulfur dioxide'</code>
 ranges from 9 to 440. As a result, it may be worth scaling the features here. Your job in this exercise is to scale the features and compute the mean and standard deviation of the unscaled features compared to the scaled features.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># white wine quality data set
</span><span class="n">df</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">fixed</span> <span class="n">acidity</span>  <span class="n">volatile</span> <span class="n">acidity</span>  <span class="n">citric</span> <span class="n">acid</span>  <span class="n">residual</span> <span class="n">sugar</span>  <span class="n">chlorides</span>  \
<span class="mi">0</span>            <span class="mf">7.0</span>              <span class="mf">0.27</span>         <span class="mf">0.36</span>            <span class="mf">20.7</span>      <span class="mf">0.045</span>
<span class="mi">1</span>            <span class="mf">6.3</span>              <span class="mf">0.30</span>         <span class="mf">0.34</span>             <span class="mf">1.6</span>      <span class="mf">0.049</span>
<span class="mi">2</span>            <span class="mf">8.1</span>              <span class="mf">0.28</span>         <span class="mf">0.40</span>             <span class="mf">6.9</span>      <span class="mf">0.050</span>

   <span class="n">free</span> <span class="n">sulfur</span> <span class="n">dioxide</span>  <span class="n">total</span> <span class="n">sulfur</span> <span class="n">dioxide</span>  <span class="n">density</span>    <span class="n">pH</span>  <span class="n">sulphates</span>  \
<span class="mi">0</span>                 <span class="mf">45.0</span>                 <span class="mf">170.0</span>   <span class="mf">1.0010</span>  <span class="mf">3.00</span>       <span class="mf">0.45</span>
<span class="mi">1</span>                 <span class="mf">14.0</span>                 <span class="mf">132.0</span>   <span class="mf">0.9940</span>  <span class="mf">3.30</span>       <span class="mf">0.49</span>
<span class="mi">2</span>                 <span class="mf">30.0</span>                  <span class="mf">97.0</span>   <span class="mf">0.9951</span>  <span class="mf">3.26</span>       <span class="mf">0.44</span>

   <span class="n">alcohol</span>  <span class="n">quality</span>
<span class="mi">0</span>      <span class="mf">8.8</span>        <span class="mi">6</span>
<span class="mi">1</span>      <span class="mf">9.5</span>        <span class="mi">6</span>
<span class="mi">2</span>     <span class="mf">10.1</span>        <span class="mi">6</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import scale
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>

<span class="c1"># Scale the features: X_scaled
</span><span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># Print the mean and standard deviation of the unscaled features
</span><span class="k">print</span><span class="p">(</span><span class="s">"Mean of Unscaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Standard Deviation of Unscaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>

<span class="c1"># Print the mean and standard deviation of the scaled features
</span><span class="k">print</span><span class="p">(</span><span class="s">"Mean of Scaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Standard Deviation of Scaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Mean of Unscaled Features: 18.432687072460002
Standard Deviation of Unscaled Features: 41.54494764094571

Mean of Scaled Features: 2.7314972981668206e-15
Standard Deviation of Scaled Features: 0.9999999999999999

</code></pre></div></div>

<p>####
<strong>Centering and scaling in a pipeline</strong></p>

<p>With regard to whether or not scaling is effective, the proof is in the pudding! See for yourself whether or not scaling the features of the White Wine Quality dataset has any impact on its performance.</p>

<p>You will use a k-NN classifier as part of a pipeline that includes scaling, and for the purposes of comparison, a k-NN classifier trained on the unscaled data has been provided.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>

<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
        <span class="p">(</span><span class="s">'knn'</span><span class="p">,</span> <span class="n">KNeighborsClassifier</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Fit the pipeline to the training set: knn_scaled
</span><span class="n">knn_scaled</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Instantiate and fit a k-NN classifier to the unscaled data
</span><span class="n">knn_unscaled</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">().</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Compute and print metrics
</span><span class="k">print</span><span class="p">(</span><span class="s">'Accuracy with Scaling: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">knn_scaled</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Accuracy without Scaling: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">knn_unscaled</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>

<span class="n">Accuracy</span> <span class="k">with</span> <span class="n">Scaling</span><span class="p">:</span> <span class="mf">0.7700680272108843</span>
<span class="n">Accuracy</span> <span class="n">without</span> <span class="n">Scaling</span><span class="p">:</span> <span class="mf">0.6979591836734694</span>

</code></pre></div></div>

<p>It looks like scaling has significantly improved model performance!</p>

<hr />

<p>####
<strong>Bringing it all together I: Pipeline for classification</strong></p>

<p>It is time now to piece together everything you have learned so far into a pipeline for classification! Your job in this exercise is to build a pipeline that includes scaling and hyperparameter tuning to classify wine quality.</p>

<p>You’ll return to using the SVM classifier you were briefly introduced to earlier in this chapter. The hyperparameters you will tune are C and gamma. C controls the regularization strength. It is analogous to the C you tuned for logistic regression in Chapter 3, while gamma controls the kernel coefficient:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup the pipeline
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
         <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Specify the hyperparameter space
</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">'SVM__C'</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
              <span class="s">'SVM__gamma'</span><span class="p">:[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]}</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>

<span class="c1"># Instantiate the GridSearchCV object: cv
</span><span class="n">cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="c1"># Fit to the training set
</span><span class="n">cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print metrics
</span><span class="k">print</span><span class="p">(</span><span class="s">"Accuracy: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned Model Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Accuracy: 0.7795918367346939
             precision    recall  f1-score   support

      False       0.83      0.85      0.84       662
       True       0.67      0.63      0.65       318

avg / total       0.78      0.78      0.78       980

Tuned Model Parameters: {'SVM__C': 10, 'SVM__gamma': 0.1}

</code></pre></div></div>

<p>####
<strong>Bringing it all together II: Pipeline for regression</strong></p>

<p>Your job is to build a pipeline that imputes the missing data, scales the features, and fits an ElasticNet to the Gapminder data. You will then tune the
 <code class="language-plaintext highlighter-rouge">l1_ratio</code>
 of your ElasticNet using GridSearchCV.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'mean'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
         <span class="p">(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
         <span class="p">(</span><span class="s">'elasticnet'</span><span class="p">,</span> <span class="n">ElasticNet</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Specify the hyperparameter space
</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">'elasticnet__l1_ratio'</span><span class="p">:</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">30</span><span class="p">)}</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the GridSearchCV object: gm_cv
</span><span class="n">gm_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="c1"># Fit to the training set
</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Compute and print the metrics
</span><span class="n">r2</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet Alpha: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet R squared: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span>

<span class="c1">#    Tuned ElasticNet Alpha: {'elasticnet__l1_ratio': 1.0}
#    Tuned ElasticNet R squared: 0.8862016570888217
</span>
</code></pre></div></div>

<p>The End.</p>

<p>Thank you for reading.</p>

<hr />

<ol>
  <li>
    <h2 id="classification-3">Classification</h2>
  </li>
</ol>

<p>###
<strong>Machine learning introduction</strong></p>

<p><strong>What is machine learning?</strong>
 Giving computers the ability to learn to make decisions from data without being explicitly programmed</p>

<p><strong>Examples of machine learning:</strong>
 Learning to predict whether an email is spam or not (supervised)</p>

<p>Clustering Wikipedia entries into different categories (unsupervised)</p>

<p>####
<strong>Types of Machine Learning</strong></p>

<ul>
  <li>supervised learning</li>
  <li>unsupervised learning</li>
  <li>reinforcement learning</li>
</ul>

<p><strong>Supervised learning:</strong></p>

<p>Predictor variables/
 <strong>features</strong>
 and a
 <strong>target variable</strong></p>

<p>Aim: Predict the target variable, given the predictor variables</p>

<p>Classification: Target variable consists of categories</p>

<p>Regression: Target variable is continuous</p>

<p><strong>Unsupervised learning:</strong></p>

<p>Uncovering hidden patterns from unlabeled data</p>

<p>Example of unsupervised learning:</p>

<p>Grouping customers into distinct categories (Clustering)</p>

<p><strong>Reinforcement learning:</strong>
 Software agents interact with an environment</p>

<p>Learn how to optimize their behavior</p>

<p>Given a system of rewards and punishments</p>

<p>Applications</p>

<p>Economics</p>

<p>Genetics</p>

<p>Game playing (AlphaGo)</p>

<p>####
 Naming conventions</p>

<ul>
  <li>Features = predictor variables = independent variables</li>
  <li>Target variable = dependent variable = response variable</li>
</ul>

<hr />

<p>####
 Features of
 <strong>Supervised learning</strong></p>

<ul>
  <li>Automate time-consuming or expensive manual tasks (ex. Doctor’s diagnosis)</li>
  <li>Make predictions about the future (ex. Will a customer click on an ad or not)</li>
  <li>Need labeled data (Historical data with labels etc.)</li>
</ul>

<p>####
<strong>Popular libraries</strong></p>

<ul>
  <li>scikit-learning (basic)</li>
  <li>TensorFlow</li>
  <li>keras</li>
</ul>

<hr />

<p>###
<strong>Exploratory data analysis</strong></p>

<p>####
<strong>Numerical EDA</strong></p>

<p>In this chapter, you’ll be working with a dataset obtained from the
 <a href="https://archive.ics.uci.edu/ml/datasets/Congressional+Voting+Records">UCI Machine Learning Repository</a>
 consisting of votes made by US House of Representatives Congressmen.</p>

<p>Your goal will be to predict their party affiliation (‘Democrat’ or ‘Republican’) based on how they voted on certain key issues.</p>

<p>Here, it’s worth noting that we have preprocessed this dataset to deal with missing values. This is so that your focus can be directed towards understanding how to train and evaluate supervised learning models.</p>

<p>Once you have mastered these fundamentals, you will be introduced to preprocessing techniques in Chapter 4 and have the chance to apply them there yourself – including on this very same dataset!</p>

<p>Before thinking about what supervised learning models you can apply to this, however, you need to perform Exploratory data analysis (EDA) in order to understand the structure of the data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
        party  infants  water  budget  physician  salvador  religious  \
0  republican        0      1       0          1         1          1
1  republican        0      1       0          1         1          1
2    democrat        0      1       1          0         1          1
3    democrat        0      1       1          0         1          1
4    democrat        1      1       1          0         1          1

   satellite  aid  missile  immigration  synfuels  education  superfund  \
0          0    0        0            1         0          1          1
1          0    0        0            0         0          1          1
2          0    0        0            0         1          0          1
3          0    0        0            0         1          0          1
4          0    0        0            0         1          0          1

   crime  duty_free_exports  eaa_rsa
0      1                  0        1
1      1                  0        1
2      1                  0        0
3      0                  0        1
4      1                  1        1

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 435 entries, 0 to 434
Data columns (total 17 columns):
party                435 non-null object
infants              435 non-null int64
water                435 non-null int64
budget               435 non-null int64
physician            435 non-null int64
salvador             435 non-null int64
religious            435 non-null int64
satellite            435 non-null int64
aid                  435 non-null int64
missile              435 non-null int64
immigration          435 non-null int64
synfuels             435 non-null int64
education            435 non-null int64
superfund            435 non-null int64
crime                435 non-null int64
duty_free_exports    435 non-null int64
eaa_rsa              435 non-null int64
dtypes: int64(16), object(1)
memory usage: 57.9+ KB

</code></pre></div></div>

<p>###
<strong>Visual EDA</strong></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture-21.png" alt="Desktop View" /></p>

<p>Above is a
 <code class="language-plaintext highlighter-rouge">countplot</code>
 of the
 <code class="language-plaintext highlighter-rouge">'education'</code>
 bill, generated from the following code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.figure()
sns.countplot(x='education', hue='party', data=df, palette='RdBu')
plt.xticks([0,1], ['No', 'Yes'])
plt.show()

</code></pre></div></div>

<p>In
 <code class="language-plaintext highlighter-rouge">sns.countplot()</code>
 , we specify the x-axis data to be
 <code class="language-plaintext highlighter-rouge">'education'</code>
 , and hue to be
 <code class="language-plaintext highlighter-rouge">'party'</code>
 . Recall that
 <code class="language-plaintext highlighter-rouge">'party'</code>
 is also our target variable. So the resulting plot shows the difference in voting behavior between the two parties for the
 <code class="language-plaintext highlighter-rouge">'education'</code>
 bill, with each party colored differently. We manually specified the color to be
 <code class="language-plaintext highlighter-rouge">'RdBu'</code>
 , as the Republican party has been traditionally associated with red, and the Democratic party with blue.</p>

<p>It seems like Democrats voted resoundingly
 <em>against</em>
 this bill, compared to Republicans.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.figure()
sns.countplot(x='missile', hue='party', data=df, palette='RdBu')
plt.xticks([0,1], ['No', 'Yes'])
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture1-20.png" alt="Desktop View" /></p>

<p>Democrats vote resoundingly in
 <em>favor</em>
 of missile, compared to Republicans.</p>

<hr />

<p>###
<strong>The classification challenge</strong></p>

<p>####
<strong>k-Nearest Neighbors: Fit</strong></p>

<p><a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">k-nearest neighbors algorithm</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import KNeighborsClassifier from sklearn.neighbors
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="c1"># Create arrays for the features and the response variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'party'</span><span class="p">].</span><span class="n">values</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">'party'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>

<span class="c1"># Create a k-NN classifier with 6 neighbors
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

</code></pre></div></div>

<p>####
<strong>k-Nearest Neighbors: Predict</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import KNeighborsClassifier from sklearn.neighbors
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="c1"># Create arrays for the features and the response variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'party'</span><span class="p">]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">'party'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>

<span class="c1"># Create a k-NN classifier with 6 neighbors: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Predict the labels for the training data X
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># Predict and print the label for the new data point X_new
</span><span class="n">new_prediction</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Prediction: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">new_prediction</span><span class="p">))</span>

<span class="c1"># Prediction: ['democrat']
</span>
</code></pre></div></div>

<p>How sure can you be of its predictions? In other words, how can you measure its performance?</p>

<hr />

<p>###
<strong>Measuring model performance</strong></p>

<p>####
<strong>The digits recognition dataset: MNIST</strong></p>

<p>In the following exercises, you’ll be working with the
 <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>
 digits recognition dataset, which has 10 classes, the digits 0 through 9! A reduced version of the MNIST dataset is one of scikit-learn’s included datasets, and that is the one we will use in this exercise.</p>

<p>Each sample in this scikit-learn dataset is an 8×8 image representing a handwritten digit. Each pixel is represented by an integer in the range 0 to 16, indicating varying levels of black.</p>

<p>It is a famous dataset in machine learning and computer vision, and frequently used as a benchmark to evaluate the performance of a new model.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Load the digits dataset: digits
</span><span class="n">digits</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">.</span><span class="n">load_digits</span><span class="p">()</span>

<span class="c1"># Print the keys and DESCR of the dataset
</span><span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
<span class="c1">#dict_keys(['data', 'target', 'target_names', 'images', 'DESCR'])
</span>
<span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">DESCR</span><span class="p">)</span>
<span class="o">/*</span>
<span class="n">Optical</span> <span class="n">Recognition</span> <span class="n">of</span> <span class="n">Handwritten</span> <span class="n">Digits</span> <span class="n">Data</span> <span class="n">Set</span>
<span class="o">===================================================</span>

<span class="n">Notes</span>
<span class="o">-----</span>
<span class="n">Data</span> <span class="n">Set</span> <span class="n">Characteristics</span><span class="p">:</span>
    <span class="p">:</span><span class="n">Number</span> <span class="n">of</span> <span class="n">Instances</span><span class="p">:</span> <span class="mi">5620</span>
    <span class="p">:</span><span class="n">Number</span> <span class="n">of</span> <span class="n">Attributes</span><span class="p">:</span> <span class="mi">64</span>
    <span class="p">:</span><span class="n">Attribute</span> <span class="n">Information</span><span class="p">:</span> <span class="mi">8</span><span class="n">x8</span> <span class="n">image</span> <span class="n">of</span> <span class="n">integer</span> <span class="n">pixels</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">range</span> <span class="mf">0.</span><span class="p">.</span><span class="mf">16.</span>
    <span class="p">:</span><span class="n">Missing</span> <span class="n">Attribute</span> <span class="n">Values</span><span class="p">:</span> <span class="bp">None</span>
    <span class="p">:</span><span class="n">Creator</span><span class="p">:</span> <span class="n">E</span><span class="p">.</span> <span class="n">Alpaydin</span> <span class="p">(</span><span class="n">alpaydin</span> <span class="s">'@'</span> <span class="n">boun</span><span class="p">.</span><span class="n">edu</span><span class="p">.</span><span class="n">tr</span><span class="p">)</span>
    <span class="p">:</span><span class="n">Date</span><span class="p">:</span> <span class="n">July</span><span class="p">;</span> <span class="mi">1998</span>
<span class="p">...</span>
<span class="o">*/</span>

<span class="c1"># Print the shape of the images and data keys
</span><span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">images</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

<span class="c1"># Display digit 1010
</span><span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">images</span><span class="p">[</span><span class="mi">1010</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">gray_r</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">'nearest'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture2-19.png" alt="Desktop View" /></p>

<p>####
<strong>Train/Test Split + Fit/Predict/Accuracy</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Create feature and target arrays
</span><span class="n">X</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">data</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">target</span>

<span class="c1"># Split into training and test set
#  Stratify the split according to the labels so that they are distributed in the training and test sets as they are in the original dataset.
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

<span class="c1"># Create a k-NN classifier with 7 neighbors: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Print the accuracy
</span><span class="k">print</span><span class="p">(</span><span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
<span class="c1"># 0.983333333333
</span>
</code></pre></div></div>

<p>Incredibly, this out of the box k-NN classifier with 7 neighbors has learned from the training data and predicted the labels of the images in the test set with 98% accuracy, and it did so in less than a second! This is one illustration of how incredibly useful machine learning techniques can be.</p>

<hr />

<p>####
<strong>Overfitting and underfitting</strong></p>

<p>In this exercise, you will compute and plot the training and testing accuracy scores for a variety of different neighbor values. By observing how the accuracy scores differ for the training and testing sets with different values of k, you will develop your intuition for overfitting and underfitting.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup arrays to store train and test accuracies
</span><span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">train_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>
<span class="n">test_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>

<span class="c1"># Loop over different values of k
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
    <span class="c1"># Setup a k-NN Classifier with k neighbors: knn
</span>    <span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># Fit the classifier to the training data
</span>    <span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1">#Compute accuracy on the training set
</span>    <span class="n">train_accuracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1">#Compute accuracy on the testing set
</span>    <span class="n">test_accuracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

<span class="c1"># Generate plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'k-NN: Varying Number of Neighbors'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">test_accuracy</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Testing Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">train_accuracy</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Training Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Number of Neighbors'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture3-18.png" alt="Desktop View" /></p>

<p>It looks like the test accuracy is highest when using 3 and 5 neighbors. Using 8 neighbors or more seems to result in a simple model that underfits the data.</p>

<hr />

<h1 id="2-regression-3"><strong>2. Regression</strong></h1>
<hr />

<p>###
<strong>Introduction to regression</strong></p>

<p>####
<strong>Importing data for supervised learning</strong></p>

<p>In this chapter, you will work with
 <a href="https://www.gapminder.org/data/">Gapminder</a>
 data that we have consolidated into one CSV file available in the workspace as
 <code class="language-plaintext highlighter-rouge">'gapminder.csv'</code>
 . Specifically, your goal will be to use this data to predict the life expectancy in a given country based on features such as the country’s GDP, fertility rate, and population.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import numpy and pandas
</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Read the CSV file into a DataFrame: df
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'gapminder.csv'</span><span class="p">)</span>

<span class="c1"># Create arrays for features and target variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'life'</span><span class="p">].</span><span class="n">values</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'fertility'</span><span class="p">].</span><span class="n">values</span>

<span class="c1"># Print the dimensions of X and y before reshaping
</span><span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of y before reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of X before reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Dimensions of y before reshaping: (139,)
# Dimensions of X before reshaping: (139,)
</span>

<span class="c1"># Reshape X and y
</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the dimensions of X and y after reshaping
</span><span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of y after reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of X after reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Dimensions of y after reshaping: (139, 1)
# Dimensions of X after reshaping: (139, 1)
</span>
</code></pre></div></div>

<p>####
<strong>Exploring the Gapminder data</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 139 entries, 0 to 138
Data columns (total 9 columns):
population         139 non-null float64
fertility          139 non-null float64
HIV                139 non-null float64
CO2                139 non-null float64
BMI_male           139 non-null float64
GDP                139 non-null float64
BMI_female         139 non-null float64
life               139 non-null float64
child_mortality    139 non-null float64
dtypes: float64(9)
memory usage: 9.9 KB

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
sns.heatmap(df.corr(), square=True, cmap='RdYlGn')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture4-17.png" alt="Desktop View" /></p>

<p>###
<strong>The basics of linear regression</strong></p>

<p>We suppose that y and x have a linear relationship that can be model by</p>

<p>y = ax + b</p>

<p>An linear regression is to find a, b that minimize the sum of the squared residual (= Ordinary Least Squares, OLS)</p>

<p>Why squared residual?</p>

<p>Residuals may be positive and negative.</p>

<p>They cancel each other. square residual can solve this problem.</p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture6-11.png" alt="Desktop View" /></p>

<p>green lines are residuals</p>

<p>When we have n variables of x,</p>

<p>y = a1<em>x1 + a2</em>x2 + … an*xn + b</p>

<p>we find a1, a2, … an, b that minimize the sum of the squared residual.</p>

<p>####
<strong>Fit &amp; predict for regression</strong></p>

<p>In this exercise, you will use the
 <code class="language-plaintext highlighter-rouge">'fertility'</code>
 feature of the Gapminder dataset. Since the goal is to predict life expectancy, the target variable here is
 <code class="language-plaintext highlighter-rouge">'life'</code>
 .</p>

<p>You will also compute and print the R2 score using sckit-learn’s
 <code class="language-plaintext highlighter-rouge">.score()</code>
 method.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import LinearRegression
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="c1"># Create the regressor: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Create the prediction space
</span><span class="n">prediction_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">)).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Fit the model to the data
</span><span class="n">reg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Compute predictions over the prediction space: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">prediction_space</span><span class="p">)</span>

<span class="c1"># Print R^2
</span><span class="k">print</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="mf">0.619244216774</span>

<span class="c1"># Plot regression line
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">prediction_space</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'black'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture7-12.png" alt="Desktop View" /></p>

<p>####
<strong>Train/test split for regression</strong></p>

<p>In this exercise, you will split the Gapminder dataset into training and testing sets, and then fit and predict a linear regression over
 <strong>all</strong>
 features. In addition to computing the R2 score, you will also compute the Root Mean Squared Error (RMSE), which is another commonly used metric to evaluate regression models.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the regressor: reg_all
</span><span class="n">reg_all</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Fit the regressor to the training data
</span><span class="n">reg_all</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict on the test data: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg_all</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print R^2 and RMSE
</span><span class="k">print</span><span class="p">(</span><span class="s">"R^2: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">reg_all</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="c1"># R^2: 0.838046873142936
</span>

<span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Root Mean Squared Error: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">rmse</span><span class="p">))</span>
<span class="c1"># Root Mean Squared Error: 3.2476010800377213
</span>

</code></pre></div></div>

<p>###
<strong>Cross-validation</strong></p>

<p>What is cross validation?</p>

<p><a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)">https://en.wikipedia.org/wiki/Cross-validation_(statistics)</a></p>

<p>####
<strong>5-fold cross-validation</strong></p>

<p>In this exercise, you will practice 5-fold cross validation on the Gapminder data. By default, scikit-learn’s
 <code class="language-plaintext highlighter-rouge">cross_val_score()</code>
 function uses R2R2 as the metric of choice for regression.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Create a linear regression object: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Compute 5-fold cross-validation scores: cv_scores
</span><span class="n">cv_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Print the 5-fold cross-validation scores
</span><span class="k">print</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)</span>
<span class="c1"># [ 0.81720569  0.82917058  0.90214134  0.80633989  0.94495637]
</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Average 5-Fold CV Score: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)))</span>
<span class="c1"># Average 5-Fold CV Score: 0.8599627722793232
</span>
</code></pre></div></div>

<p>####
<strong>K-Fold CV comparison</strong></p>

<p>Cross validation is essential but do not forget that the more folds you use, the more computationally expensive cross-validation becomes. In this exercise, you will explore this for yourself. Your job is to perform 3-fold cross-validation and then 10-fold cross-validation on the Gapminder dataset.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Create a linear regression object: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Perform 3-fold CV
</span><span class="n">cvscores_3</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvscores_3</span><span class="p">))</span>
<span class="c1"># 0.871871278262
</span>
<span class="c1"># Perform 10-fold CV
</span><span class="n">cvscores_10</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvscores_10</span><span class="p">))</span>
<span class="c1"># 0.843612862013
</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
%timeit cross_val_score(reg, X, y, cv=3)
100 loops, best of 3: 8.73 ms per loop

%timeit cross_val_score(reg, X, y, cv=10)
10 loops, best of 3: 27.5 ms per loop

</code></pre></div></div>

<hr />

<p>###
<strong>Regularized regression</strong></p>

<p>####
<strong><a href="https://en.wikipedia.org/wiki/Lasso_(statistics)">Regularization I: Lasso</a></strong></p>

<p>In this exercise, you will fit a lasso regression to the Gapminder data you have been working with and plot the coefficients. Just as with the Boston data, you will find that the coefficients of some features are shrunk to 0, with only the most important ones remaining.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.columns
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality'],
      dtype='object')

X: ['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'child_mortality']
y: life

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import Lasso
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Lasso</span>

<span class="c1"># Instantiate a lasso regressor: lasso
</span><span class="n">lasso</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Fit the regressor to the data
</span><span class="n">lasso</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Compute and print the coefficients
</span><span class="n">lasso_coef</span> <span class="o">=</span> <span class="n">lasso</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">).</span><span class="n">coef_</span>
<span class="k">print</span><span class="p">(</span><span class="n">lasso_coef</span><span class="p">)</span>
<span class="c1">#  [-0.         -0.         -0.          0.          0.          0.         -0.
</span>     <span class="o">-</span><span class="mf">0.07087587</span><span class="p">]</span>


<span class="c1"># Plot the coefficients
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_columns</span><span class="p">)),</span> <span class="n">lasso_coef</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_columns</span><span class="p">)),</span> <span class="n">df_columns</span><span class="p">.</span><span class="n">values</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture8-9.png" alt="Desktop View" /></p>

<p>According to the lasso algorithm, it seems like
 <code class="language-plaintext highlighter-rouge">'child_mortality'</code>
 is the most important feature when predicting life expectancy.</p>

<p>####
<strong>Regularization II: Ridge</strong></p>

<p>Lasso is great for feature selection, but when building regression models, Ridge regression should be your first choice.</p>

<p>Recall that lasso performs regularization by adding to the loss function a penalty term of the
 <em>absolute</em>
 value of each coefficient multiplied by some alpha. This is also known as L1L1 regularization because the regularization term is the L1L1 norm of the coefficients. This is not the only way to regularize, however.</p>

<p>If instead you took the sum of the
 <em>squared</em>
 values of the coefficients multiplied by some alpha – like in Ridge regression – you would be computing the L2L2norm. In this exercise, you will practice fitting ridge regression models over a range of different alphas, and plot cross-validated R2R2 scores for each, using this function that we have defined for you, which plots the R2R2 score as well as standard error for each alpha:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def display_plot(cv_scores, cv_scores_std):
    fig = plt.figure()
    ax = fig.add_subplot(1,1,1)
    ax.plot(alpha_space, cv_scores)

    std_error = cv_scores_std / np.sqrt(10)

    ax.fill_between(alpha_space, cv_scores + std_error, cv_scores - std_error, alpha=0.2)
    ax.set_ylabel('CV Score +/- Std Error')
    ax.set_xlabel('Alpha')
    ax.axhline(np.max(cv_scores), linestyle='--', color='.5')
    ax.set_xlim([alpha_space[0], alpha_space[-1]])
    ax.set_xscale('log')
    plt.show()


</code></pre></div></div>

<p>Don’t worry about the specifics of the above function works. The motivation behind this exercise is for you to see how the R2R2 score varies with different alphas, and to understand the importance of selecting the right value for alpha. You’ll learn how to tune alpha in the next chapter.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Setup the array of alphas and lists to store scores
</span><span class="n">alpha_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">ridge_scores</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ridge_scores_std</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Create a ridge regressor: ridge
</span><span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Compute scores over range of alphas
</span><span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">alpha_space</span><span class="p">:</span>

    <span class="c1"># Specify the alpha value to use: ridge.alpha
</span>    <span class="n">ridge</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="c1"># Perform 10-fold CV: ridge_cv_scores
</span>    <span class="n">ridge_cv_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="c1"># Append the mean of ridge_cv_scores to ridge_scores
</span>    <span class="n">ridge_scores</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ridge_cv_scores</span><span class="p">))</span>

    <span class="c1"># Append the std of ridge_cv_scores to ridge_scores_std
</span>    <span class="n">ridge_scores_std</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">ridge_cv_scores</span><span class="p">))</span>

<span class="c1"># Display the plot
</span><span class="n">display_plot</span><span class="p">(</span><span class="n">ridge_scores</span><span class="p">,</span> <span class="n">ridge_scores_std</span><span class="p">)</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture9-8.png" alt="Desktop View" /></p>

<p>Notice how the cross-validation scores change with different alphas.</p>

<hr />

<h1 id="3-fine-tuning-your-model-3"><strong>3. Fine-tuning your model</strong></h1>
<hr />

<p>###
<strong>confusion matrix</strong></p>

<p>What is confusion matrix</p>

<p><a href="https://en.wikipedia.org/wiki/Confusion_matrix">https://en.wikipedia.org/wiki/Confusion_matrix</a></p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f02ea353bf60bfdd9557d2c98fe18c34cd8db835" alt="{\displaystyle \mathrm {TPR} ={\frac {\mathrm {TP} }{\mathrm {P} }}={\frac {\mathrm {TP} }{\mathrm {TP} +\mathrm {FN} }}=1-\mathrm {FNR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">sensitivity</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Precision_and_recall#Recall">recall</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Hit_rate">hit rate</a>
 , or
 <a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">true positive rate</a>
 (TPR)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8f2c867f0641e498ec8a59de63697a3a45d66b07" alt="{\displaystyle \mathrm {TNR} ={\frac {\mathrm {TN} }{\mathrm {N} }}={\frac {\mathrm {TN} }{\mathrm {TN} +\mathrm {FP} }}=1-\mathrm {FPR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Specificity_(tests)">specificity</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Specificity_(tests)">selectivity</a>
 or
 <a href="https://en.wikipedia.org/wiki/Specificity_(tests)">true negative rate</a>
 (TNR)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d854b1544fc77735d575ce0d30e34d7f1eacf707" alt="{\displaystyle \mathrm {PPV} ={\frac {\mathrm {TP} }{\mathrm {TP} +\mathrm {FP} }}=1-\mathrm {FDR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision">precision</a>
 or
 <a href="https://en.wikipedia.org/wiki/Positive_predictive_value">positive predictive value</a>
 (PPV)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47deb47eb7ac214423d0a6afd05ec0af362fef9b" alt="{\displaystyle \mathrm {ACC} ={\frac {\mathrm {TP} +\mathrm {TN} }{\mathrm {P} +\mathrm {N} }}={\frac {\mathrm {TP} +\mathrm {TN} }{\mathrm {TP} +\mathrm {TN} +\mathrm {FP} +\mathrm {FN} }}}" /></p>

<p><a href="https://en.wikipedia.org/wiki/Accuracy">accuracy</a>
 (ACC)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0e5f071c6418f444fadc9f5f9b0358beed3e094c" alt="{\displaystyle \mathrm {F} _{1}=2\cdot {\frac {\mathrm {PPV} \cdot \mathrm {TPR} }{\mathrm {PPV} +\mathrm {TPR} }}={\frac {2\mathrm {TP} }{2\mathrm {TP} +\mathrm {FP} +\mathrm {FN} }}}" /></p>

<p><a href="https://en.wikipedia.org/wiki/F1_score">F1 score</a>
 is the
 <a href="https://en.wikipedia.org/wiki/Harmonic_mean#Harmonic_mean_of_two_numbers">harmonic mean</a>
 of
 <a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision">precision</a>
 and
 <a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">sensitivity</a></p>

<p>####
<strong>illustration for TPR, TNR and PPV</strong></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/metric_example.png?w=1024" alt="Desktop View" /></p>

<p><a href="http://corysimon.github.io/articles/classification-metrics/">source</a></p>

<p>####
<strong>Metrics for classification</strong></p>

<p>In this exercise, you will dive more deeply into evaluating the performance of binary classifiers by computing a confusion matrix and generating a classification report.</p>

<p>Here, you’ll work with the
 <a href="https://www.kaggle.com/uciml/pima-indians-diabetes-database">PIMA Indians</a>
 dataset obtained from the UCI Machine Learning Repository. The goal is to predict whether or not a given female patient will contract diabetes based on features such as BMI, age, and number of pregnancies.</p>

<p>Therefore, it is a binary classification problem. A target value of
 <code class="language-plaintext highlighter-rouge">0</code>
 indicates that the patient does
 <em>not</em>
 have diabetes, while a value of
 <code class="language-plaintext highlighter-rouge">1</code>
 indicates that the patient
 <em>does</em>
 have diabetes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 768 entries, 0 to 767
Data columns (total 9 columns):
pregnancies    768 non-null int64
glucose        768 non-null int64
diastolic      768 non-null int64
triceps        768 non-null float64
insulin        768 non-null float64
bmi            768 non-null float64
dpf            768 non-null float64
age            768 non-null int64
diabetes       768 non-null int64
dtypes: float64(4), int64(5)
memory usage: 54.1 KB

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>

<span class="c1"># Create training and test set
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Instantiate a k-NN classifier: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test data: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Generate the confusion matrix and classification report
</span><span class="k">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[[176  30]
 [ 52  50]]

             precision    recall  f1-score   support

          0       0.77      0.85      0.81       206
          1       0.62      0.49      0.55       102

avg / total       0.72      0.73      0.72       308

</code></pre></div></div>

<hr />

<p>###
<strong>Logistic regression and the ROC curve</strong></p>

<p>What is logistic regression?</p>

<p><a href="https://en.wikipedia.org/wiki/Logistic_regression">https://en.wikipedia.org/wiki/Logistic_regression</a></p>

<p>What is ROC?</p>

<p><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">Receiver operating characteristic</a></p>

<p>Further Reading:
 <a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.html#sphx-glr-auto-examples-model-selection-plot-roc-py">scikit-learn document</a></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/roc_space-2.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Building a logistic regression model</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
X.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 768 entries, 0 to 767
Data columns (total 8 columns):
pregnancies    768 non-null int64
glucose        768 non-null int64
diastolic      768 non-null int64
triceps        768 non-null float64
insulin        768 non-null float64
bmi            768 non-null float64
dpf            768 non-null float64
age            768 non-null int64
dtypes: float64(4), int64(4)
memory usage: 48.1 KB


y
0      1
1      0
2      1
      ..

765    0
766    1
767    0
Name: diabetes, dtype: int64

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span><span class="p">,</span> <span class="n">confusion_matrix</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">logreg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print the confusion matrix and classification report
</span><span class="k">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[[176  30]
 [ 35  67]]

             precision    recall  f1-score   support

          0       0.83      0.85      0.84       206
          1       0.69      0.66      0.67       102

avg / total       0.79      0.79      0.79       308

</code></pre></div></div>

<p>####
<strong>Plotting an ROC curve</strong></p>

<p><strong>.predict_proba()</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>

<span class="c1"># Compute predicted probabilities: y_pred_prob
</span><span class="n">y_pred_prob</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Generate ROC curve values: fpr, tpr, thresholds
</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_prob</span><span class="p">)</span>

<span class="c1"># Plot ROC curve
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s">'k--'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'False Positive Rate'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'True Positive Rate'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'ROC Curve'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
logreg.predict_proba(X_test)
# False, True
# 0, 1
# Negative, Positive
array([[ 0.60409835,  0.39590165],
       [ 0.76042394,  0.23957606],
       [ 0.79670177,  0.20329823],
       ...
       [ 0.84686912,  0.15313088],
       [ 0.97617225,  0.02382775],
       [ 0.40380502,  0.59619498]])

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture1-21.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Precision-recall Curve</strong></p>

<p>There are other ways to visually evaluate model performance. One such way is the precision-recall curve, which is generated by plotting the precision and recall for different thresholds.</p>

<p>Note that here, the class is positive (1) if the individual
 <em>has</em>
 diabetes.</p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture2-20.png?w=1024" alt="Desktop View" /></p>

<ul>
  <li>A recall of 1 corresponds to a classifier with a low threshold in which
 <em>all</em>
 females who contract diabetes were correctly classified as such, at the expense of many misclassifications of those who did
 <em>not</em>
 have diabetes.</li>
  <li>Precision is undefined for a classifier which makes
 <em>no</em>
 positive predictions, that is, classifies
 <em>everyone</em>
 as
 <em>not</em>
 having diabetes.</li>
  <li>When the threshold is very close to 1, precision is also 1, because the classifier is absolutely certain about its predictions.</li>
</ul>

<p>recall or sensitivity, TPR = 1 means all true positive are detected. We can predict all to positive to get a recall of 1.</p>

<p>precision, PPV = 1 means no false positive are detected. We can predict less positive to get a higher precision.</p>

<p>####
<strong>Area under the ROC curve</strong></p>

<p>####
<strong>AUC(</strong>
 Area Under the Curve
 <strong>) computation</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span><span class="n">df</span><span class="p">.</span><span class="n">head</span><span class="p">()</span>
   <span class="n">pregnancies</span>  <span class="n">glucose</span>  <span class="n">diastolic</span>   <span class="n">triceps</span>     <span class="n">insulin</span>   <span class="n">bmi</span>    <span class="n">dpf</span>  <span class="n">age</span>  \
<span class="mi">0</span>            <span class="mi">6</span>      <span class="mi">148</span>         <span class="mi">72</span>  <span class="mf">35.00000</span>  <span class="mf">155.548223</span>  <span class="mf">33.6</span>  <span class="mf">0.627</span>   <span class="mi">50</span>
<span class="mi">1</span>            <span class="mi">1</span>       <span class="mi">85</span>         <span class="mi">66</span>  <span class="mf">29.00000</span>  <span class="mf">155.548223</span>  <span class="mf">26.6</span>  <span class="mf">0.351</span>   <span class="mi">31</span>
<span class="mi">2</span>            <span class="mi">8</span>      <span class="mi">183</span>         <span class="mi">64</span>  <span class="mf">29.15342</span>  <span class="mf">155.548223</span>  <span class="mf">23.3</span>  <span class="mf">0.672</span>   <span class="mi">32</span>
<span class="mi">3</span>            <span class="mi">1</span>       <span class="mi">89</span>         <span class="mi">66</span>  <span class="mf">23.00000</span>   <span class="mf">94.000000</span>  <span class="mf">28.1</span>  <span class="mf">0.167</span>   <span class="mi">21</span>
<span class="mi">4</span>            <span class="mi">0</span>      <span class="mi">137</span>         <span class="mi">40</span>  <span class="mf">35.00000</span>  <span class="mf">168.000000</span>  <span class="mf">43.1</span>  <span class="mf">2.288</span>   <span class="mi">33</span>

   <span class="n">diabetes</span>
<span class="mi">0</span>         <span class="mi">1</span>
<span class="mi">1</span>         <span class="mi">0</span>
<span class="mi">2</span>         <span class="mi">1</span>
<span class="mi">3</span>         <span class="mi">0</span>
<span class="mi">4</span>         <span class="mi">1</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Compute predicted probabilities: y_pred_prob
</span><span class="n">y_pred_prob</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Compute and print AUC score
</span><span class="k">print</span><span class="p">(</span><span class="s">"AUC: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_prob</span><span class="p">)))</span>

<span class="c1"># Compute cross-validated AUC scores: cv_auc
</span><span class="n">cv_auc</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'roc_auc'</span><span class="p">)</span>

<span class="c1"># Print list of AUC scores
</span><span class="k">print</span><span class="p">(</span><span class="s">"AUC scores computed using 5-fold cross-validation: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv_auc</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
AUC: 0.8254806777079764

AUC scores computed using 5-fold cross-validation:
[ 0.80148148  0.8062963   0.81481481  0.86245283  0.8554717 ]

</code></pre></div></div>

<hr />

<p>###
<strong>Hyperparameter tuning</strong></p>

<p>####
<strong>Hyperparameter tuning with GridSearchCV</strong></p>

<p>You will now practice this yourself, but by using logistic regression on the diabetes dataset.</p>

<p>Like the alpha parameter of lasso and ridge regularization that you saw earlier, logistic regression also has a regularization parameter: CC. CC controls the
 <em>inverse</em>
 of the regularization strength, and this is what you will tune in this exercise. A large CC can lead to an
 <em>overfit</em>
 model, while a small CC can lead to an
 <em>underfit</em>
 model.</p>

<p>The hyperparameter space for CC has been setup for you. Your job is to use GridSearchCV and logistic regression to find the optimal CC in this hyperparameter space.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="c1"># Setup the hyperparameter grid
</span><span class="n">c_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'C'</span><span class="p">:</span> <span class="n">c_space</span><span class="p">}</span>

<span class="c1"># Instantiate a logistic regression classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Instantiate the GridSearchCV object: logreg_cv
</span><span class="n">logreg_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the data
</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Print the tuned parameters and score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Best score is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Logistic Regression Parameters: {'C': 3.7275937203149381}
Best score is 0.7708333333333334

</code></pre></div></div>

<p>####
<strong>Hyperparameter tuning with RandomizedSearchCV</strong></p>

<p>GridSearchCV can be computationally expensive, especially if you are searching over a large hyperparameter space and dealing with multiple hyperparameters. A solution to this is to use
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 , in which not all hyperparameter values are tried out. Instead, a fixed number of hyperparameter settings is sampled from specified probability distributions. You’ll practice using
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 in this exercise and see how this works.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">RandomizedSearchCV</span>

<span class="c1"># Setup the parameters and distributions to sample from: param_dist
</span><span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s">"max_depth"</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
              <span class="s">"max_features"</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="s">"min_samples_leaf"</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="s">"criterion"</span><span class="p">:</span> <span class="p">[</span><span class="s">"gini"</span><span class="p">,</span> <span class="s">"entropy"</span><span class="p">]}</span>

<span class="c1"># Instantiate a Decision Tree classifier: tree
</span><span class="n">tree</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">()</span>

<span class="c1"># Instantiate the RandomizedSearchCV object: tree_cv
</span><span class="n">tree_cv</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">param_dist</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the data
</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Print the tuned parameters and score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Decision Tree Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Best score is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Decision Tree Parameters: {'criterion': 'entropy', 'max_depth': 3, 'max_features': 7, 'min_samples_leaf': 1}
Best score is 0.7317708333333334

</code></pre></div></div>

<p>Note that
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 will never outperform
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 . Instead, it is valuable because it saves on computation time.</p>

<p>###
<strong>Hold-out set for final evaluation</strong></p>

<p>####
<strong>Hold-out set in practice I: Classification</strong></p>

<p>In addition to CC, logistic regression has a
 <code class="language-plaintext highlighter-rouge">'penalty'</code>
 hyperparameter which specifies whether to use
 <code class="language-plaintext highlighter-rouge">'l1'</code>
 or
 <code class="language-plaintext highlighter-rouge">'l2'</code>
 regularization. Your job in this exercise is to create a hold-out set, tune the
 <code class="language-plaintext highlighter-rouge">'C'</code>
 and
 <code class="language-plaintext highlighter-rouge">'penalty'</code>
 hyperparameters of a logistic regression classifier using
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 on the training set.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="c1"># Create the hyperparameter grid
</span><span class="n">c_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'C'</span><span class="p">:</span> <span class="n">c_space</span><span class="p">,</span> <span class="s">'penalty'</span><span class="p">:</span> <span class="p">[</span><span class="s">'l1'</span><span class="p">,</span> <span class="s">'l2'</span><span class="p">]}</span>

<span class="c1"># Instantiate the logistic regression classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Instantiate the GridSearchCV object: logreg_cv
</span><span class="n">logreg_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the training data
</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Print the optimal parameters and best score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Parameter: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Accuracy: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Logistic Regression Parameter: {'C': 0.43939705607607948, 'penalty': 'l1'}
Tuned Logistic Regression Accuracy: 0.7652173913043478

</code></pre></div></div>

<p>####
<strong>Hold-out set in practice II: Regression</strong></p>

<p>Remember lasso and ridge regression from the previous chapter? Lasso used the L1 penalty to regularize, while ridge used the L2 penalty. There is another type of regularized regression known as the elastic net. In elastic net regularization, the penalty term is a linear combination of the L1 and L2 penalties:</p>

<p><strong>a∗L1+b∗L2</strong></p>

<p>In scikit-learn, this term is represented by the
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 parameter: An
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 of
 <code class="language-plaintext highlighter-rouge">1</code>
 corresponds to an L1L1 penalty, and anything lower is a combination of L1L1 and L2L2.</p>

<p>In this exercise, you will
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 to tune the
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 of an elastic net model trained on the Gapminder data. As in the previous exercise, use a hold-out set to evaluate your model’s performance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5
3   2975029.0       1.40  0.1   1.804106  25.35542   7383.0    132.8108  72.5
4  21370348.0       1.96  0.1  18.016313  27.56373  41312.0    117.3755  81.5

   child_mortality
0             29.5
1            192.0
2             15.4
3             20.0
4              5.2


</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">ElasticNet</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">train_test_split</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the hyperparameter grid
</span><span class="n">l1_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'l1_ratio'</span><span class="p">:</span> <span class="n">l1_space</span><span class="p">}</span>

<span class="c1"># Instantiate the ElasticNet regressor: elastic_net
</span><span class="n">elastic_net</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">()</span>

<span class="c1"># Setup the GridSearchCV object: gm_cv
</span><span class="n">gm_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">elastic_net</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the training data
</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict on the test set and compute metrics
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">r2</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="n">mse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet l1 ratio: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet R squared: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet MSE: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">mse</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned ElasticNet l1 ratio: {'l1_ratio': 0.20689655172413793}
Tuned ElasticNet R squared: 0.8668305372460283
Tuned ElasticNet MSE: 10.05791413339844

</code></pre></div></div>

<hr />

<h2 id="preprocessing-and-pipelines-3"><strong>Preprocessing and pipelines</strong></h2>

<p>###
<strong>Preprocessing data</strong></p>

<p>####
<strong>Exploring categorical features</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5
3   2975029.0       1.40  0.1   1.804106  25.35542   7383.0    132.8108  72.5
4  21370348.0       1.96  0.1  18.016313  27.56373  41312.0    117.3755  81.5

   child_mortality                      Region
0             29.5  Middle East &amp; North Africa
1            192.0          Sub-Saharan Africa
2             15.4                     America
3             20.0       Europe &amp; Central Asia
4              5.2         East Asia &amp; Pacific

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import pandas
</span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Read 'gapminder.csv' into a DataFrame: df
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'gapminder.csv'</span><span class="p">)</span>

<span class="c1"># Create a boxplot of life expectancy per region
</span><span class="n">df</span><span class="p">.</span><span class="n">boxplot</span><span class="p">(</span><span class="s">'life'</span><span class="p">,</span> <span class="s">'Region'</span><span class="p">,</span> <span class="n">rot</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture3-19.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Creating dummy variables</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create dummy variables: df_region
</span><span class="n">df_region</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Print the columns of df_region
</span><span class="k">print</span><span class="p">(</span><span class="n">df_region</span><span class="p">.</span><span class="n">columns</span><span class="p">)</span>

<span class="c1"># Create dummy variables with drop_first=True: df_region
</span><span class="n">df_region</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">drop_first</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Print the new columns of df_region
</span><span class="k">print</span><span class="p">(</span><span class="n">df_region</span><span class="p">.</span><span class="n">columns</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality', 'Region_America',
       'Region_East Asia &amp; Pacific', 'Region_Europe &amp; Central Asia',
       'Region_Middle East &amp; North Africa', 'Region_South Asia',
       'Region_Sub-Saharan Africa'],
      dtype='object')

# Region_America has been dropped
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality', 'Region_East Asia &amp; Pacific',
       'Region_Europe &amp; Central Asia', 'Region_Middle East &amp; North Africa',
       'Region_South Asia', 'Region_Sub-Saharan Africa'],
      dtype='object')


df_region.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5

   child_mortality  Region_East Asia &amp; Pacific  Region_Europe &amp; Central Asia  \
0             29.5                           0                             0
1            192.0                           0                             0
2             15.4                           0                             0

   Region_Middle East &amp; North Africa  Region_South Asia  \
0                                  1                  0
1                                  0                  0
2                                  0                  0

   Region_Sub-Saharan Africa
0                          0
1                          1
2                          0

</code></pre></div></div>

<p>####
<strong>Regression with categorical features</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Instantiate a ridge regressor: ridge
</span><span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Perform 5-fold cross-validation: ridge_cv
</span><span class="n">ridge_cv</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Print the cross-validated scores
</span><span class="k">print</span><span class="p">(</span><span class="n">ridge_cv</span><span class="p">)</span>
<span class="p">[</span> <span class="mf">0.86808336</span>  <span class="mf">0.80623545</span>  <span class="mf">0.84004203</span>  <span class="mf">0.7754344</span>   <span class="mf">0.87503712</span><span class="p">]</span>

</code></pre></div></div>

<hr />

<p>###
<strong>Handling missing data</strong></p>

<p>####
<strong>Dropping missing data</strong></p>

<p>Now, it’s time for you to take care of these yourself!</p>

<p>The unprocessed dataset has been loaded into a DataFrame
 <code class="language-plaintext highlighter-rouge">df</code>
 . Explore it in the IPython Shell with the
 <code class="language-plaintext highlighter-rouge">.head()</code>
 method. You will see that there are certain data points labeled with a
 <code class="language-plaintext highlighter-rouge">'?'</code>
 . These denote missing values. As you saw in the video, different datasets encode missing values in different ways. Sometimes it may be a
 <code class="language-plaintext highlighter-rouge">'9999'</code>
 , other times a
 <code class="language-plaintext highlighter-rouge">0</code>
 – real-world data can be very messy! If you’re lucky, the missing values will already be encoded as
 <code class="language-plaintext highlighter-rouge">NaN</code>
 . We use
 <code class="language-plaintext highlighter-rouge">NaN</code>
 because it is an efficient and simplified way of internally representing missing data, and it lets us take advantage of pandas methods such as
 <code class="language-plaintext highlighter-rouge">.dropna()</code>
 and
 <code class="language-plaintext highlighter-rouge">.fillna()</code>
 , as well as scikit-learn’s Imputation transformer
 <code class="language-plaintext highlighter-rouge">Imputer()</code>
 .</p>

<p>In this exercise, your job is to convert the
 <code class="language-plaintext highlighter-rouge">'?'</code>
 s to NaNs, and then drop the rows that contain them from the DataFrame.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head(3)
        party infants water budget physician salvador religious satellite aid  \
0  republican       0     1      0         1        1         1         0   0
1  republican       0     1      0         1        1         1         0   0
2    democrat       ?     1      1         ?        1         1         0   0

  missile immigration synfuels education superfund crime duty_free_exports  \
0       0           1        ?         1         1     1                 0
1       0           0        0         1         1     1                 0
2       0           0        1         0         1     1                 0

  eaa_rsa
0       1
1       ?
2       0

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Convert '?' to NaN
</span><span class="n">df</span><span class="p">[</span><span class="n">df</span> <span class="o">==</span> <span class="s">'?'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">nan</span>

<span class="c1"># Print the number of NaNs
</span><span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">isnull</span><span class="p">().</span><span class="nb">sum</span><span class="p">())</span>

<span class="c1"># Print shape of original DataFrame
</span><span class="k">print</span><span class="p">(</span><span class="s">"Shape of Original DataFrame: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Drop missing values and print shape of new DataFrame
</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">dropna</span><span class="p">()</span>

<span class="c1"># Print shape of new DataFrame
</span><span class="k">print</span><span class="p">(</span><span class="s">"Shape of DataFrame After Dropping All Rows with Missing Values: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
party                  0
infants               12
water                 48
budget                11
physician             11
salvador              15
religious             11
satellite             14
aid                   15
missile               22
immigration            7
synfuels              21
education             31
superfund             25
crime                 17
duty_free_exports     28
eaa_rsa              104
dtype: int64
Shape of Original DataFrame: (435, 17)


Shape of DataFrame After Dropping All Rows with Missing Values: (232, 17)

</code></pre></div></div>

<p>When many values in your dataset are missing, if you drop them, you may end up throwing away valuable information along with the missing data. It’s better instead to develop an imputation strategy. This is where domain knowledge is useful, but in the absence of it, you can impute missing values with the mean or the median of the row or column that the missing value is in.</p>

<p>####
<strong>Imputing missing data in a ML Pipeline I</strong></p>

<p>As you’ve come to appreciate, there are many steps to building a model, from creating training and test sets, to fitting a classifier or regressor, to tuning its parameters, to evaluating its performance on new data. Imputation can be seen as the first step of this machine learning process, the entirety of which can be viewed within the context of a pipeline. Scikit-learn provides a pipeline constructor that allows you to piece together these steps into one process and thereby simplify your workflow.</p>

<p>You’ll now practice setting up a pipeline with two steps: the imputation step, followed by the instantiation of a classifier. You’ve seen three classifiers in this course so far: k-NN, logistic regression, and the decision tree. You will now be introduced to a fourth one – the Support Vector Machine, or
 <a href="http://scikit-learn.org/stable/modules/svm.html">SVM</a>
 .</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the Imputer module
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Imputer</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Setup the Imputation transformer: imp
# axis=0 for column
</span><span class="n">imp</span> <span class="o">=</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'most_frequent'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Instantiate the SVC classifier: clf
</span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">()</span>

<span class="c1"># Setup the pipeline with the required steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">imp</span><span class="p">),</span>
        <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">clf</span><span class="p">)]</span>

</code></pre></div></div>

<p>####
<strong>Imputing missing data in a ML Pipeline II</strong></p>

<p>Having setup the steps of the pipeline in the previous exercise, you will now use it on the voting dataset to classify a Congressman’s party affiliation.</p>

<p>What makes pipelines so incredibly useful is the simple interface that they provide. You can use the
 <code class="language-plaintext highlighter-rouge">.fit()</code>
 and
 <code class="language-plaintext highlighter-rouge">.predict()</code>
 methods on pipelines just as you did with your classifiers and regressors!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Imputer</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'most_frequent'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Fit the pipeline to the train set
</span><span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute metrics
</span><span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
             precision    recall  f1-score   support

   democrat       0.99      0.96      0.98        85
 republican       0.94      0.98      0.96        46

avg / total       0.97      0.97      0.97       131

</code></pre></div></div>

<p>###
<strong>Centering and scaling</strong></p>

<p>####
<strong>Centering and scaling your data</strong></p>

<p>You will now explore scaling for yourself on a new dataset –
 <a href="https://archive.ics.uci.edu/ml/datasets/Wine+Quality">White Wine Quality</a>
 !</p>

<p>We have used the
 <code class="language-plaintext highlighter-rouge">'quality'</code>
 feature of the wine to create a binary target variable: If
 <code class="language-plaintext highlighter-rouge">'quality'</code>
 is less than
 <code class="language-plaintext highlighter-rouge">5</code>
 , the target variable is
 <code class="language-plaintext highlighter-rouge">1</code>
 , and otherwise, it is
 <code class="language-plaintext highlighter-rouge">0</code>
 .</p>

<p>Notice how some features seem to have different units of measurement.
 <code class="language-plaintext highlighter-rouge">'density'</code>
 , for instance, takes values between 0.98 and 1.04, while
 <code class="language-plaintext highlighter-rouge">'total sulfur dioxide'</code>
 ranges from 9 to 440. As a result, it may be worth scaling the features here. Your job in this exercise is to scale the features and compute the mean and standard deviation of the unscaled features compared to the scaled features.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># white wine quality data set
</span><span class="n">df</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">fixed</span> <span class="n">acidity</span>  <span class="n">volatile</span> <span class="n">acidity</span>  <span class="n">citric</span> <span class="n">acid</span>  <span class="n">residual</span> <span class="n">sugar</span>  <span class="n">chlorides</span>  \
<span class="mi">0</span>            <span class="mf">7.0</span>              <span class="mf">0.27</span>         <span class="mf">0.36</span>            <span class="mf">20.7</span>      <span class="mf">0.045</span>
<span class="mi">1</span>            <span class="mf">6.3</span>              <span class="mf">0.30</span>         <span class="mf">0.34</span>             <span class="mf">1.6</span>      <span class="mf">0.049</span>
<span class="mi">2</span>            <span class="mf">8.1</span>              <span class="mf">0.28</span>         <span class="mf">0.40</span>             <span class="mf">6.9</span>      <span class="mf">0.050</span>

   <span class="n">free</span> <span class="n">sulfur</span> <span class="n">dioxide</span>  <span class="n">total</span> <span class="n">sulfur</span> <span class="n">dioxide</span>  <span class="n">density</span>    <span class="n">pH</span>  <span class="n">sulphates</span>  \
<span class="mi">0</span>                 <span class="mf">45.0</span>                 <span class="mf">170.0</span>   <span class="mf">1.0010</span>  <span class="mf">3.00</span>       <span class="mf">0.45</span>
<span class="mi">1</span>                 <span class="mf">14.0</span>                 <span class="mf">132.0</span>   <span class="mf">0.9940</span>  <span class="mf">3.30</span>       <span class="mf">0.49</span>
<span class="mi">2</span>                 <span class="mf">30.0</span>                  <span class="mf">97.0</span>   <span class="mf">0.9951</span>  <span class="mf">3.26</span>       <span class="mf">0.44</span>

   <span class="n">alcohol</span>  <span class="n">quality</span>
<span class="mi">0</span>      <span class="mf">8.8</span>        <span class="mi">6</span>
<span class="mi">1</span>      <span class="mf">9.5</span>        <span class="mi">6</span>
<span class="mi">2</span>     <span class="mf">10.1</span>        <span class="mi">6</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import scale
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>

<span class="c1"># Scale the features: X_scaled
</span><span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># Print the mean and standard deviation of the unscaled features
</span><span class="k">print</span><span class="p">(</span><span class="s">"Mean of Unscaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Standard Deviation of Unscaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>

<span class="c1"># Print the mean and standard deviation of the scaled features
</span><span class="k">print</span><span class="p">(</span><span class="s">"Mean of Scaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Standard Deviation of Scaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Mean of Unscaled Features: 18.432687072460002
Standard Deviation of Unscaled Features: 41.54494764094571

Mean of Scaled Features: 2.7314972981668206e-15
Standard Deviation of Scaled Features: 0.9999999999999999

</code></pre></div></div>

<p>####
<strong>Centering and scaling in a pipeline</strong></p>

<p>With regard to whether or not scaling is effective, the proof is in the pudding! See for yourself whether or not scaling the features of the White Wine Quality dataset has any impact on its performance.</p>

<p>You will use a k-NN classifier as part of a pipeline that includes scaling, and for the purposes of comparison, a k-NN classifier trained on the unscaled data has been provided.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>

<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
        <span class="p">(</span><span class="s">'knn'</span><span class="p">,</span> <span class="n">KNeighborsClassifier</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Fit the pipeline to the training set: knn_scaled
</span><span class="n">knn_scaled</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Instantiate and fit a k-NN classifier to the unscaled data
</span><span class="n">knn_unscaled</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">().</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Compute and print metrics
</span><span class="k">print</span><span class="p">(</span><span class="s">'Accuracy with Scaling: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">knn_scaled</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Accuracy without Scaling: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">knn_unscaled</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>

<span class="n">Accuracy</span> <span class="k">with</span> <span class="n">Scaling</span><span class="p">:</span> <span class="mf">0.7700680272108843</span>
<span class="n">Accuracy</span> <span class="n">without</span> <span class="n">Scaling</span><span class="p">:</span> <span class="mf">0.6979591836734694</span>

</code></pre></div></div>

<p>It looks like scaling has significantly improved model performance!</p>

<hr />

<p>####
<strong>Bringing it all together I: Pipeline for classification</strong></p>

<p>It is time now to piece together everything you have learned so far into a pipeline for classification! Your job in this exercise is to build a pipeline that includes scaling and hyperparameter tuning to classify wine quality.</p>

<p>You’ll return to using the SVM classifier you were briefly introduced to earlier in this chapter. The hyperparameters you will tune are C and gamma. C controls the regularization strength. It is analogous to the C you tuned for logistic regression in Chapter 3, while gamma controls the kernel coefficient:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup the pipeline
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
         <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Specify the hyperparameter space
</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">'SVM__C'</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
              <span class="s">'SVM__gamma'</span><span class="p">:[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]}</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>

<span class="c1"># Instantiate the GridSearchCV object: cv
</span><span class="n">cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="c1"># Fit to the training set
</span><span class="n">cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print metrics
</span><span class="k">print</span><span class="p">(</span><span class="s">"Accuracy: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned Model Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Accuracy: 0.7795918367346939
             precision    recall  f1-score   support

      False       0.83      0.85      0.84       662
       True       0.67      0.63      0.65       318

avg / total       0.78      0.78      0.78       980

Tuned Model Parameters: {'SVM__C': 10, 'SVM__gamma': 0.1}

</code></pre></div></div>

<p>####
<strong>Bringing it all together II: Pipeline for regression</strong></p>

<p>Your job is to build a pipeline that imputes the missing data, scales the features, and fits an ElasticNet to the Gapminder data. You will then tune the
 <code class="language-plaintext highlighter-rouge">l1_ratio</code>
 of your ElasticNet using GridSearchCV.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'mean'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
         <span class="p">(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
         <span class="p">(</span><span class="s">'elasticnet'</span><span class="p">,</span> <span class="n">ElasticNet</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Specify the hyperparameter space
</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">'elasticnet__l1_ratio'</span><span class="p">:</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">30</span><span class="p">)}</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the GridSearchCV object: gm_cv
</span><span class="n">gm_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="c1"># Fit to the training set
</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Compute and print the metrics
</span><span class="n">r2</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet Alpha: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet R squared: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span>

<span class="c1">#    Tuned ElasticNet Alpha: {'elasticnet__l1_ratio': 1.0}
#    Tuned ElasticNet R squared: 0.8862016570888217
</span>
</code></pre></div></div>

<p>The End.</p>

<p>Thank you for reading.</p>

<hr />

<ol>
  <li>
    <h2 id="classification-4">Classification</h2>
  </li>
</ol>

<p>###
<strong>Machine learning introduction</strong></p>

<p><strong>What is machine learning?</strong>
 Giving computers the ability to learn to make decisions from data without being explicitly programmed</p>

<p><strong>Examples of machine learning:</strong>
 Learning to predict whether an email is spam or not (supervised)</p>

<p>Clustering Wikipedia entries into different categories (unsupervised)</p>

<p>####
<strong>Types of Machine Learning</strong></p>

<ul>
  <li>supervised learning</li>
  <li>unsupervised learning</li>
  <li>reinforcement learning</li>
</ul>

<p><strong>Supervised learning:</strong></p>

<p>Predictor variables/
 <strong>features</strong>
 and a
 <strong>target variable</strong></p>

<p>Aim: Predict the target variable, given the predictor variables</p>

<p>Classification: Target variable consists of categories</p>

<p>Regression: Target variable is continuous</p>

<p><strong>Unsupervised learning:</strong></p>

<p>Uncovering hidden patterns from unlabeled data</p>

<p>Example of unsupervised learning:</p>

<p>Grouping customers into distinct categories (Clustering)</p>

<p><strong>Reinforcement learning:</strong>
 Software agents interact with an environment</p>

<p>Learn how to optimize their behavior</p>

<p>Given a system of rewards and punishments</p>

<p>Applications</p>

<p>Economics</p>

<p>Genetics</p>

<p>Game playing (AlphaGo)</p>

<p>####
 Naming conventions</p>

<ul>
  <li>Features = predictor variables = independent variables</li>
  <li>Target variable = dependent variable = response variable</li>
</ul>

<hr />

<p>####
 Features of
 <strong>Supervised learning</strong></p>

<ul>
  <li>Automate time-consuming or expensive manual tasks (ex. Doctor’s diagnosis)</li>
  <li>Make predictions about the future (ex. Will a customer click on an ad or not)</li>
  <li>Need labeled data (Historical data with labels etc.)</li>
</ul>

<p>####
<strong>Popular libraries</strong></p>

<ul>
  <li>scikit-learning (basic)</li>
  <li>TensorFlow</li>
  <li>keras</li>
</ul>

<hr />

<p>###
<strong>Exploratory data analysis</strong></p>

<p>####
<strong>Numerical EDA</strong></p>

<p>In this chapter, you’ll be working with a dataset obtained from the
 <a href="https://archive.ics.uci.edu/ml/datasets/Congressional+Voting+Records">UCI Machine Learning Repository</a>
 consisting of votes made by US House of Representatives Congressmen.</p>

<p>Your goal will be to predict their party affiliation (‘Democrat’ or ‘Republican’) based on how they voted on certain key issues.</p>

<p>Here, it’s worth noting that we have preprocessed this dataset to deal with missing values. This is so that your focus can be directed towards understanding how to train and evaluate supervised learning models.</p>

<p>Once you have mastered these fundamentals, you will be introduced to preprocessing techniques in Chapter 4 and have the chance to apply them there yourself – including on this very same dataset!</p>

<p>Before thinking about what supervised learning models you can apply to this, however, you need to perform Exploratory data analysis (EDA) in order to understand the structure of the data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
        party  infants  water  budget  physician  salvador  religious  \
0  republican        0      1       0          1         1          1
1  republican        0      1       0          1         1          1
2    democrat        0      1       1          0         1          1
3    democrat        0      1       1          0         1          1
4    democrat        1      1       1          0         1          1

   satellite  aid  missile  immigration  synfuels  education  superfund  \
0          0    0        0            1         0          1          1
1          0    0        0            0         0          1          1
2          0    0        0            0         1          0          1
3          0    0        0            0         1          0          1
4          0    0        0            0         1          0          1

   crime  duty_free_exports  eaa_rsa
0      1                  0        1
1      1                  0        1
2      1                  0        0
3      0                  0        1
4      1                  1        1

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 435 entries, 0 to 434
Data columns (total 17 columns):
party                435 non-null object
infants              435 non-null int64
water                435 non-null int64
budget               435 non-null int64
physician            435 non-null int64
salvador             435 non-null int64
religious            435 non-null int64
satellite            435 non-null int64
aid                  435 non-null int64
missile              435 non-null int64
immigration          435 non-null int64
synfuels             435 non-null int64
education            435 non-null int64
superfund            435 non-null int64
crime                435 non-null int64
duty_free_exports    435 non-null int64
eaa_rsa              435 non-null int64
dtypes: int64(16), object(1)
memory usage: 57.9+ KB

</code></pre></div></div>

<p>###
<strong>Visual EDA</strong></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture-21.png" alt="Desktop View" /></p>

<p>Above is a
 <code class="language-plaintext highlighter-rouge">countplot</code>
 of the
 <code class="language-plaintext highlighter-rouge">'education'</code>
 bill, generated from the following code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.figure()
sns.countplot(x='education', hue='party', data=df, palette='RdBu')
plt.xticks([0,1], ['No', 'Yes'])
plt.show()

</code></pre></div></div>

<p>In
 <code class="language-plaintext highlighter-rouge">sns.countplot()</code>
 , we specify the x-axis data to be
 <code class="language-plaintext highlighter-rouge">'education'</code>
 , and hue to be
 <code class="language-plaintext highlighter-rouge">'party'</code>
 . Recall that
 <code class="language-plaintext highlighter-rouge">'party'</code>
 is also our target variable. So the resulting plot shows the difference in voting behavior between the two parties for the
 <code class="language-plaintext highlighter-rouge">'education'</code>
 bill, with each party colored differently. We manually specified the color to be
 <code class="language-plaintext highlighter-rouge">'RdBu'</code>
 , as the Republican party has been traditionally associated with red, and the Democratic party with blue.</p>

<p>It seems like Democrats voted resoundingly
 <em>against</em>
 this bill, compared to Republicans.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.figure()
sns.countplot(x='missile', hue='party', data=df, palette='RdBu')
plt.xticks([0,1], ['No', 'Yes'])
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture1-20.png" alt="Desktop View" /></p>

<p>Democrats vote resoundingly in
 <em>favor</em>
 of missile, compared to Republicans.</p>

<hr />

<p>###
<strong>The classification challenge</strong></p>

<p>####
<strong>k-Nearest Neighbors: Fit</strong></p>

<p><a href="https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">k-nearest neighbors algorithm</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import KNeighborsClassifier from sklearn.neighbors
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="c1"># Create arrays for the features and the response variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'party'</span><span class="p">].</span><span class="n">values</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">'party'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>

<span class="c1"># Create a k-NN classifier with 6 neighbors
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

</code></pre></div></div>

<p>####
<strong>k-Nearest Neighbors: Predict</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import KNeighborsClassifier from sklearn.neighbors
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>

<span class="c1"># Create arrays for the features and the response variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'party'</span><span class="p">]</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="s">'party'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">).</span><span class="n">values</span>

<span class="c1"># Create a k-NN classifier with 6 neighbors: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Predict the labels for the training data X
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># Predict and print the label for the new data point X_new
</span><span class="n">new_prediction</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Prediction: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">new_prediction</span><span class="p">))</span>

<span class="c1"># Prediction: ['democrat']
</span>
</code></pre></div></div>

<p>How sure can you be of its predictions? In other words, how can you measure its performance?</p>

<hr />

<p>###
<strong>Measuring model performance</strong></p>

<p>####
<strong>The digits recognition dataset: MNIST</strong></p>

<p>In the following exercises, you’ll be working with the
 <a href="http://yann.lecun.com/exdb/mnist/">MNIST</a>
 digits recognition dataset, which has 10 classes, the digits 0 through 9! A reduced version of the MNIST dataset is one of scikit-learn’s included datasets, and that is the one we will use in this exercise.</p>

<p>Each sample in this scikit-learn dataset is an 8×8 image representing a handwritten digit. Each pixel is represented by an integer in the range 0 to 16, indicating varying levels of black.</p>

<p>It is a famous dataset in machine learning and computer vision, and frequently used as a benchmark to evaluate the performance of a new model.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn</span> <span class="kn">import</span> <span class="n">datasets</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="c1"># Load the digits dataset: digits
</span><span class="n">digits</span> <span class="o">=</span> <span class="n">datasets</span><span class="p">.</span><span class="n">load_digits</span><span class="p">()</span>

<span class="c1"># Print the keys and DESCR of the dataset
</span><span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
<span class="c1">#dict_keys(['data', 'target', 'target_names', 'images', 'DESCR'])
</span>
<span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">DESCR</span><span class="p">)</span>
<span class="o">/*</span>
<span class="n">Optical</span> <span class="n">Recognition</span> <span class="n">of</span> <span class="n">Handwritten</span> <span class="n">Digits</span> <span class="n">Data</span> <span class="n">Set</span>
<span class="o">===================================================</span>

<span class="n">Notes</span>
<span class="o">-----</span>
<span class="n">Data</span> <span class="n">Set</span> <span class="n">Characteristics</span><span class="p">:</span>
    <span class="p">:</span><span class="n">Number</span> <span class="n">of</span> <span class="n">Instances</span><span class="p">:</span> <span class="mi">5620</span>
    <span class="p">:</span><span class="n">Number</span> <span class="n">of</span> <span class="n">Attributes</span><span class="p">:</span> <span class="mi">64</span>
    <span class="p">:</span><span class="n">Attribute</span> <span class="n">Information</span><span class="p">:</span> <span class="mi">8</span><span class="n">x8</span> <span class="n">image</span> <span class="n">of</span> <span class="n">integer</span> <span class="n">pixels</span> <span class="ow">in</span> <span class="n">the</span> <span class="nb">range</span> <span class="mf">0.</span><span class="p">.</span><span class="mf">16.</span>
    <span class="p">:</span><span class="n">Missing</span> <span class="n">Attribute</span> <span class="n">Values</span><span class="p">:</span> <span class="bp">None</span>
    <span class="p">:</span><span class="n">Creator</span><span class="p">:</span> <span class="n">E</span><span class="p">.</span> <span class="n">Alpaydin</span> <span class="p">(</span><span class="n">alpaydin</span> <span class="s">'@'</span> <span class="n">boun</span><span class="p">.</span><span class="n">edu</span><span class="p">.</span><span class="n">tr</span><span class="p">)</span>
    <span class="p">:</span><span class="n">Date</span><span class="p">:</span> <span class="n">July</span><span class="p">;</span> <span class="mi">1998</span>
<span class="p">...</span>
<span class="o">*/</span>

<span class="c1"># Print the shape of the images and data keys
</span><span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">images</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">shape</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1797</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

<span class="c1"># Display digit 1010
</span><span class="n">plt</span><span class="p">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">images</span><span class="p">[</span><span class="mi">1010</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">gray_r</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">'nearest'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture2-19.png" alt="Desktop View" /></p>

<p>####
<strong>Train/Test Split + Fit/Predict/Accuracy</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Create feature and target arrays
</span><span class="n">X</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">data</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">digits</span><span class="p">.</span><span class="n">target</span>

<span class="c1"># Split into training and test set
#  Stratify the split according to the labels so that they are distributed in the training and test sets as they are in the original dataset.
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">stratify</span><span class="o">=</span><span class="n">y</span><span class="p">)</span>

<span class="c1"># Create a k-NN classifier with 7 neighbors: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Print the accuracy
</span><span class="k">print</span><span class="p">(</span><span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
<span class="c1"># 0.983333333333
</span>
</code></pre></div></div>

<p>Incredibly, this out of the box k-NN classifier with 7 neighbors has learned from the training data and predicted the labels of the images in the test set with 98% accuracy, and it did so in less than a second! This is one illustration of how incredibly useful machine learning techniques can be.</p>

<hr />

<p>####
<strong>Overfitting and underfitting</strong></p>

<p>In this exercise, you will compute and plot the training and testing accuracy scores for a variety of different neighbor values. By observing how the accuracy scores differ for the training and testing sets with different values of k, you will develop your intuition for overfitting and underfitting.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup arrays to store train and test accuracies
</span><span class="n">neighbors</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="n">train_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>
<span class="n">test_accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))</span>

<span class="c1"># Loop over different values of k
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">neighbors</span><span class="p">):</span>
    <span class="c1"># Setup a k-NN Classifier with k neighbors: knn
</span>    <span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># Fit the classifier to the training data
</span>    <span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1">#Compute accuracy on the training set
</span>    <span class="n">train_accuracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

    <span class="c1">#Compute accuracy on the testing set
</span>    <span class="n">test_accuracy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

<span class="c1"># Generate plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'k-NN: Varying Number of Neighbors'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">test_accuracy</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Testing Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">train_accuracy</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Training Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Number of Neighbors'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'Accuracy'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture3-18.png" alt="Desktop View" /></p>

<p>It looks like the test accuracy is highest when using 3 and 5 neighbors. Using 8 neighbors or more seems to result in a simple model that underfits the data.</p>

<hr />

<h1 id="2-regression-4"><strong>2. Regression</strong></h1>
<hr />

<p>###
<strong>Introduction to regression</strong></p>

<p>####
<strong>Importing data for supervised learning</strong></p>

<p>In this chapter, you will work with
 <a href="https://www.gapminder.org/data/">Gapminder</a>
 data that we have consolidated into one CSV file available in the workspace as
 <code class="language-plaintext highlighter-rouge">'gapminder.csv'</code>
 . Specifically, your goal will be to use this data to predict the life expectancy in a given country based on features such as the country’s GDP, fertility rate, and population.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import numpy and pandas
</span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Read the CSV file into a DataFrame: df
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'gapminder.csv'</span><span class="p">)</span>

<span class="c1"># Create arrays for features and target variable
</span><span class="n">y</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'life'</span><span class="p">].</span><span class="n">values</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'fertility'</span><span class="p">].</span><span class="n">values</span>

<span class="c1"># Print the dimensions of X and y before reshaping
</span><span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of y before reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of X before reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Dimensions of y before reshaping: (139,)
# Dimensions of X before reshaping: (139,)
</span>

<span class="c1"># Reshape X and y
</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="p">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the dimensions of X and y after reshaping
</span><span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of y after reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Dimensions of X after reshaping: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Dimensions of y after reshaping: (139, 1)
# Dimensions of X after reshaping: (139, 1)
</span>
</code></pre></div></div>

<p>####
<strong>Exploring the Gapminder data</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 139 entries, 0 to 138
Data columns (total 9 columns):
population         139 non-null float64
fertility          139 non-null float64
HIV                139 non-null float64
CO2                139 non-null float64
BMI_male           139 non-null float64
GDP                139 non-null float64
BMI_female         139 non-null float64
life               139 non-null float64
child_mortality    139 non-null float64
dtypes: float64(9)
memory usage: 9.9 KB

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
sns.heatmap(df.corr(), square=True, cmap='RdYlGn')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture4-17.png" alt="Desktop View" /></p>

<p>###
<strong>The basics of linear regression</strong></p>

<p>We suppose that y and x have a linear relationship that can be model by</p>

<p>y = ax + b</p>

<p>An linear regression is to find a, b that minimize the sum of the squared residual (= Ordinary Least Squares, OLS)</p>

<p>Why squared residual?</p>

<p>Residuals may be positive and negative.</p>

<p>They cancel each other. square residual can solve this problem.</p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture6-11.png" alt="Desktop View" /></p>

<p>green lines are residuals</p>

<p>When we have n variables of x,</p>

<p>y = a1<em>x1 + a2</em>x2 + … an*xn + b</p>

<p>we find a1, a2, … an, b that minimize the sum of the squared residual.</p>

<p>####
<strong>Fit &amp; predict for regression</strong></p>

<p>In this exercise, you will use the
 <code class="language-plaintext highlighter-rouge">'fertility'</code>
 feature of the Gapminder dataset. Since the goal is to predict life expectancy, the target variable here is
 <code class="language-plaintext highlighter-rouge">'life'</code>
 .</p>

<p>You will also compute and print the R2 score using sckit-learn’s
 <code class="language-plaintext highlighter-rouge">.score()</code>
 method.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import LinearRegression
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="c1"># Create the regressor: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Create the prediction space
</span><span class="n">prediction_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">)).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Fit the model to the data
</span><span class="n">reg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Compute predictions over the prediction space: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">prediction_space</span><span class="p">)</span>

<span class="c1"># Print R^2
</span><span class="k">print</span><span class="p">(</span><span class="n">reg</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_fertility</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
<span class="mf">0.619244216774</span>

<span class="c1"># Plot regression line
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">prediction_space</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'black'</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture7-12.png" alt="Desktop View" /></p>

<p>####
<strong>Train/test split for regression</strong></p>

<p>In this exercise, you will split the Gapminder dataset into training and testing sets, and then fit and predict a linear regression over
 <strong>all</strong>
 features. In addition to computing the R2 score, you will also compute the Root Mean Squared Error (RMSE), which is another commonly used metric to evaluate regression models.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the regressor: reg_all
</span><span class="n">reg_all</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Fit the regressor to the training data
</span><span class="n">reg_all</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict on the test data: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">reg_all</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print R^2 and RMSE
</span><span class="k">print</span><span class="p">(</span><span class="s">"R^2: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">reg_all</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="c1"># R^2: 0.838046873142936
</span>

<span class="n">rmse</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Root Mean Squared Error: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">rmse</span><span class="p">))</span>
<span class="c1"># Root Mean Squared Error: 3.2476010800377213
</span>

</code></pre></div></div>

<p>###
<strong>Cross-validation</strong></p>

<p>What is cross validation?</p>

<p><a href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)">https://en.wikipedia.org/wiki/Cross-validation_(statistics)</a></p>

<p>####
<strong>5-fold cross-validation</strong></p>

<p>In this exercise, you will practice 5-fold cross validation on the Gapminder data. By default, scikit-learn’s
 <code class="language-plaintext highlighter-rouge">cross_val_score()</code>
 function uses R2R2 as the metric of choice for regression.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Create a linear regression object: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Compute 5-fold cross-validation scores: cv_scores
</span><span class="n">cv_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Print the 5-fold cross-validation scores
</span><span class="k">print</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)</span>
<span class="c1"># [ 0.81720569  0.82917058  0.90214134  0.80633989  0.94495637]
</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Average 5-Fold CV Score: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cv_scores</span><span class="p">)))</span>
<span class="c1"># Average 5-Fold CV Score: 0.8599627722793232
</span>
</code></pre></div></div>

<p>####
<strong>K-Fold CV comparison</strong></p>

<p>Cross validation is essential but do not forget that the more folds you use, the more computationally expensive cross-validation becomes. In this exercise, you will explore this for yourself. Your job is to perform 3-fold cross-validation and then 10-fold cross-validation on the Gapminder dataset.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Create a linear regression object: reg
</span><span class="n">reg</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>

<span class="c1"># Perform 3-fold CV
</span><span class="n">cvscores_3</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvscores_3</span><span class="p">))</span>
<span class="c1"># 0.871871278262
</span>
<span class="c1"># Perform 10-fold CV
</span><span class="n">cvscores_10</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cvscores_10</span><span class="p">))</span>
<span class="c1"># 0.843612862013
</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
%timeit cross_val_score(reg, X, y, cv=3)
100 loops, best of 3: 8.73 ms per loop

%timeit cross_val_score(reg, X, y, cv=10)
10 loops, best of 3: 27.5 ms per loop

</code></pre></div></div>

<hr />

<p>###
<strong>Regularized regression</strong></p>

<p>####
<strong><a href="https://en.wikipedia.org/wiki/Lasso_(statistics)">Regularization I: Lasso</a></strong></p>

<p>In this exercise, you will fit a lasso regression to the Gapminder data you have been working with and plot the coefficients. Just as with the Boston data, you will find that the coefficients of some features are shrunk to 0, with only the most important ones remaining.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.columns
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality'],
      dtype='object')

X: ['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'child_mortality']
y: life

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import Lasso
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Lasso</span>

<span class="c1"># Instantiate a lasso regressor: lasso
</span><span class="n">lasso</span> <span class="o">=</span> <span class="n">Lasso</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Fit the regressor to the data
</span><span class="n">lasso</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Compute and print the coefficients
</span><span class="n">lasso_coef</span> <span class="o">=</span> <span class="n">lasso</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">).</span><span class="n">coef_</span>
<span class="k">print</span><span class="p">(</span><span class="n">lasso_coef</span><span class="p">)</span>
<span class="c1">#  [-0.         -0.         -0.          0.          0.          0.         -0.
</span>     <span class="o">-</span><span class="mf">0.07087587</span><span class="p">]</span>


<span class="c1"># Plot the coefficients
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_columns</span><span class="p">)),</span> <span class="n">lasso_coef</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df_columns</span><span class="p">)),</span> <span class="n">df_columns</span><span class="p">.</span><span class="n">values</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture8-9.png" alt="Desktop View" /></p>

<p>According to the lasso algorithm, it seems like
 <code class="language-plaintext highlighter-rouge">'child_mortality'</code>
 is the most important feature when predicting life expectancy.</p>

<p>####
<strong>Regularization II: Ridge</strong></p>

<p>Lasso is great for feature selection, but when building regression models, Ridge regression should be your first choice.</p>

<p>Recall that lasso performs regularization by adding to the loss function a penalty term of the
 <em>absolute</em>
 value of each coefficient multiplied by some alpha. This is also known as L1L1 regularization because the regularization term is the L1L1 norm of the coefficients. This is not the only way to regularize, however.</p>

<p>If instead you took the sum of the
 <em>squared</em>
 values of the coefficients multiplied by some alpha – like in Ridge regression – you would be computing the L2L2norm. In this exercise, you will practice fitting ridge regression models over a range of different alphas, and plot cross-validated R2R2 scores for each, using this function that we have defined for you, which plots the R2R2 score as well as standard error for each alpha:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def display_plot(cv_scores, cv_scores_std):
    fig = plt.figure()
    ax = fig.add_subplot(1,1,1)
    ax.plot(alpha_space, cv_scores)

    std_error = cv_scores_std / np.sqrt(10)

    ax.fill_between(alpha_space, cv_scores + std_error, cv_scores - std_error, alpha=0.2)
    ax.set_ylabel('CV Score +/- Std Error')
    ax.set_xlabel('Alpha')
    ax.axhline(np.max(cv_scores), linestyle='--', color='.5')
    ax.set_xlim([alpha_space[0], alpha_space[-1]])
    ax.set_xscale('log')
    plt.show()


</code></pre></div></div>

<p>Don’t worry about the specifics of the above function works. The motivation behind this exercise is for you to see how the R2R2 score varies with different alphas, and to understand the importance of selecting the right value for alpha. You’ll learn how to tune alpha in the next chapter.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Setup the array of alphas and lists to store scores
</span><span class="n">alpha_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">ridge_scores</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ridge_scores_std</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># Create a ridge regressor: ridge
</span><span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Compute scores over range of alphas
</span><span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">alpha_space</span><span class="p">:</span>

    <span class="c1"># Specify the alpha value to use: ridge.alpha
</span>    <span class="n">ridge</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>

    <span class="c1"># Perform 10-fold CV: ridge_cv_scores
</span>    <span class="n">ridge_cv_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

    <span class="c1"># Append the mean of ridge_cv_scores to ridge_scores
</span>    <span class="n">ridge_scores</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ridge_cv_scores</span><span class="p">))</span>

    <span class="c1"># Append the std of ridge_cv_scores to ridge_scores_std
</span>    <span class="n">ridge_scores_std</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">ridge_cv_scores</span><span class="p">))</span>

<span class="c1"># Display the plot
</span><span class="n">display_plot</span><span class="p">(</span><span class="n">ridge_scores</span><span class="p">,</span> <span class="n">ridge_scores_std</span><span class="p">)</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture9-8.png" alt="Desktop View" /></p>

<p>Notice how the cross-validation scores change with different alphas.</p>

<hr />

<h1 id="3-fine-tuning-your-model-4"><strong>3. Fine-tuning your model</strong></h1>
<hr />

<p>###
<strong>confusion matrix</strong></p>

<p>What is confusion matrix</p>

<p><a href="https://en.wikipedia.org/wiki/Confusion_matrix">https://en.wikipedia.org/wiki/Confusion_matrix</a></p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f02ea353bf60bfdd9557d2c98fe18c34cd8db835" alt="{\displaystyle \mathrm {TPR} ={\frac {\mathrm {TP} }{\mathrm {P} }}={\frac {\mathrm {TP} }{\mathrm {TP} +\mathrm {FN} }}=1-\mathrm {FNR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">sensitivity</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Precision_and_recall#Recall">recall</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Hit_rate">hit rate</a>
 , or
 <a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">true positive rate</a>
 (TPR)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8f2c867f0641e498ec8a59de63697a3a45d66b07" alt="{\displaystyle \mathrm {TNR} ={\frac {\mathrm {TN} }{\mathrm {N} }}={\frac {\mathrm {TN} }{\mathrm {TN} +\mathrm {FP} }}=1-\mathrm {FPR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Specificity_(tests)">specificity</a>
 ,
 <a href="https://en.wikipedia.org/wiki/Specificity_(tests)">selectivity</a>
 or
 <a href="https://en.wikipedia.org/wiki/Specificity_(tests)">true negative rate</a>
 (TNR)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d854b1544fc77735d575ce0d30e34d7f1eacf707" alt="{\displaystyle \mathrm {PPV} ={\frac {\mathrm {TP} }{\mathrm {TP} +\mathrm {FP} }}=1-\mathrm {FDR} }" /></p>

<p><a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision">precision</a>
 or
 <a href="https://en.wikipedia.org/wiki/Positive_predictive_value">positive predictive value</a>
 (PPV)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47deb47eb7ac214423d0a6afd05ec0af362fef9b" alt="{\displaystyle \mathrm {ACC} ={\frac {\mathrm {TP} +\mathrm {TN} }{\mathrm {P} +\mathrm {N} }}={\frac {\mathrm {TP} +\mathrm {TN} }{\mathrm {TP} +\mathrm {TN} +\mathrm {FP} +\mathrm {FN} }}}" /></p>

<p><a href="https://en.wikipedia.org/wiki/Accuracy">accuracy</a>
 (ACC)</p>

<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0e5f071c6418f444fadc9f5f9b0358beed3e094c" alt="{\displaystyle \mathrm {F} _{1}=2\cdot {\frac {\mathrm {PPV} \cdot \mathrm {TPR} }{\mathrm {PPV} +\mathrm {TPR} }}={\frac {2\mathrm {TP} }{2\mathrm {TP} +\mathrm {FP} +\mathrm {FN} }}}" /></p>

<p><a href="https://en.wikipedia.org/wiki/F1_score">F1 score</a>
 is the
 <a href="https://en.wikipedia.org/wiki/Harmonic_mean#Harmonic_mean_of_two_numbers">harmonic mean</a>
 of
 <a href="https://en.wikipedia.org/wiki/Information_retrieval#Precision">precision</a>
 and
 <a href="https://en.wikipedia.org/wiki/Sensitivity_(test)">sensitivity</a></p>

<p>####
<strong>illustration for TPR, TNR and PPV</strong></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/metric_example.png?w=1024" alt="Desktop View" /></p>

<p><a href="http://corysimon.github.io/articles/classification-metrics/">source</a></p>

<p>####
<strong>Metrics for classification</strong></p>

<p>In this exercise, you will dive more deeply into evaluating the performance of binary classifiers by computing a confusion matrix and generating a classification report.</p>

<p>Here, you’ll work with the
 <a href="https://www.kaggle.com/uciml/pima-indians-diabetes-database">PIMA Indians</a>
 dataset obtained from the UCI Machine Learning Repository. The goal is to predict whether or not a given female patient will contract diabetes based on features such as BMI, age, and number of pregnancies.</p>

<p>Therefore, it is a binary classification problem. A target value of
 <code class="language-plaintext highlighter-rouge">0</code>
 indicates that the patient does
 <em>not</em>
 have diabetes, while a value of
 <code class="language-plaintext highlighter-rouge">1</code>
 indicates that the patient
 <em>does</em>
 have diabetes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 768 entries, 0 to 767
Data columns (total 9 columns):
pregnancies    768 non-null int64
glucose        768 non-null int64
diastolic      768 non-null int64
triceps        768 non-null float64
insulin        768 non-null float64
bmi            768 non-null float64
dpf            768 non-null float64
age            768 non-null int64
diabetes       768 non-null int64
dtypes: float64(4), int64(5)
memory usage: 54.1 KB

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="kn">import</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">confusion_matrix</span>

<span class="c1"># Create training and test set
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Instantiate a k-NN classifier: knn
</span><span class="n">knn</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">knn</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test data: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">knn</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Generate the confusion matrix and classification report
</span><span class="k">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[[176  30]
 [ 52  50]]

             precision    recall  f1-score   support

          0       0.77      0.85      0.81       206
          1       0.62      0.49      0.55       102

avg / total       0.72      0.73      0.72       308

</code></pre></div></div>

<hr />

<p>###
<strong>Logistic regression and the ROC curve</strong></p>

<p>What is logistic regression?</p>

<p><a href="https://en.wikipedia.org/wiki/Logistic_regression">https://en.wikipedia.org/wiki/Logistic_regression</a></p>

<p>What is ROC?</p>

<p><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">Receiver operating characteristic</a></p>

<p>Further Reading:
 <a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.html#sphx-glr-auto-examples-model-selection-plot-roc-py">scikit-learn document</a></p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/roc_space-2.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Building a logistic regression model</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
X.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 768 entries, 0 to 767
Data columns (total 8 columns):
pregnancies    768 non-null int64
glucose        768 non-null int64
diastolic      768 non-null int64
triceps        768 non-null float64
insulin        768 non-null float64
bmi            768 non-null float64
dpf            768 non-null float64
age            768 non-null int64
dtypes: float64(4), int64(4)
memory usage: 48.1 KB


y
0      1
1      0
2      1
      ..

765    0
766    1
767    0
Name: diabetes, dtype: int64

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">classification_report</span><span class="p">,</span> <span class="n">confusion_matrix</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Fit the classifier to the training data
</span><span class="n">logreg</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print the confusion matrix and classification report
</span><span class="k">print</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
[[176  30]
 [ 35  67]]

             precision    recall  f1-score   support

          0       0.83      0.85      0.84       206
          1       0.69      0.66      0.67       102

avg / total       0.79      0.79      0.79       308

</code></pre></div></div>

<p>####
<strong>Plotting an ROC curve</strong></p>

<p><strong>.predict_proba()</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_curve</span>

<span class="c1"># Compute predicted probabilities: y_pred_prob
</span><span class="n">y_pred_prob</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Generate ROC curve values: fpr, tpr, thresholds
</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">,</span> <span class="n">thresholds</span> <span class="o">=</span> <span class="n">roc_curve</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_prob</span><span class="p">)</span>

<span class="c1"># Plot ROC curve
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s">'k--'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fpr</span><span class="p">,</span> <span class="n">tpr</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'False Positive Rate'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'True Positive Rate'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">'ROC Curve'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
logreg.predict_proba(X_test)
# False, True
# 0, 1
# Negative, Positive
array([[ 0.60409835,  0.39590165],
       [ 0.76042394,  0.23957606],
       [ 0.79670177,  0.20329823],
       ...
       [ 0.84686912,  0.15313088],
       [ 0.97617225,  0.02382775],
       [ 0.40380502,  0.59619498]])

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture1-21.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Precision-recall Curve</strong></p>

<p>There are other ways to visually evaluate model performance. One such way is the precision-recall curve, which is generated by plotting the precision and recall for different thresholds.</p>

<p>Note that here, the class is positive (1) if the individual
 <em>has</em>
 diabetes.</p>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture2-20.png?w=1024" alt="Desktop View" /></p>

<ul>
  <li>A recall of 1 corresponds to a classifier with a low threshold in which
 <em>all</em>
 females who contract diabetes were correctly classified as such, at the expense of many misclassifications of those who did
 <em>not</em>
 have diabetes.</li>
  <li>Precision is undefined for a classifier which makes
 <em>no</em>
 positive predictions, that is, classifies
 <em>everyone</em>
 as
 <em>not</em>
 having diabetes.</li>
  <li>When the threshold is very close to 1, precision is also 1, because the classifier is absolutely certain about its predictions.</li>
</ul>

<p>recall or sensitivity, TPR = 1 means all true positive are detected. We can predict all to positive to get a recall of 1.</p>

<p>precision, PPV = 1 means no false positive are detected. We can predict less positive to get a higher precision.</p>

<p>####
<strong>Area under the ROC curve</strong></p>

<p>####
<strong>AUC(</strong>
 Area Under the Curve
 <strong>) computation</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span><span class="n">df</span><span class="p">.</span><span class="n">head</span><span class="p">()</span>
   <span class="n">pregnancies</span>  <span class="n">glucose</span>  <span class="n">diastolic</span>   <span class="n">triceps</span>     <span class="n">insulin</span>   <span class="n">bmi</span>    <span class="n">dpf</span>  <span class="n">age</span>  \
<span class="mi">0</span>            <span class="mi">6</span>      <span class="mi">148</span>         <span class="mi">72</span>  <span class="mf">35.00000</span>  <span class="mf">155.548223</span>  <span class="mf">33.6</span>  <span class="mf">0.627</span>   <span class="mi">50</span>
<span class="mi">1</span>            <span class="mi">1</span>       <span class="mi">85</span>         <span class="mi">66</span>  <span class="mf">29.00000</span>  <span class="mf">155.548223</span>  <span class="mf">26.6</span>  <span class="mf">0.351</span>   <span class="mi">31</span>
<span class="mi">2</span>            <span class="mi">8</span>      <span class="mi">183</span>         <span class="mi">64</span>  <span class="mf">29.15342</span>  <span class="mf">155.548223</span>  <span class="mf">23.3</span>  <span class="mf">0.672</span>   <span class="mi">32</span>
<span class="mi">3</span>            <span class="mi">1</span>       <span class="mi">89</span>         <span class="mi">66</span>  <span class="mf">23.00000</span>   <span class="mf">94.000000</span>  <span class="mf">28.1</span>  <span class="mf">0.167</span>   <span class="mi">21</span>
<span class="mi">4</span>            <span class="mi">0</span>      <span class="mi">137</span>         <span class="mi">40</span>  <span class="mf">35.00000</span>  <span class="mf">168.000000</span>  <span class="mf">43.1</span>  <span class="mf">2.288</span>   <span class="mi">33</span>

   <span class="n">diabetes</span>
<span class="mi">0</span>         <span class="mi">1</span>
<span class="mi">1</span>         <span class="mi">0</span>
<span class="mi">2</span>         <span class="mi">1</span>
<span class="mi">3</span>         <span class="mi">0</span>
<span class="mi">4</span>         <span class="mi">1</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">roc_auc_score</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Compute predicted probabilities: y_pred_prob
</span><span class="n">y_pred_prob</span> <span class="o">=</span> <span class="n">logreg</span><span class="p">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Compute and print AUC score
</span><span class="k">print</span><span class="p">(</span><span class="s">"AUC: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred_prob</span><span class="p">)))</span>

<span class="c1"># Compute cross-validated AUC scores: cv_auc
</span><span class="n">cv_auc</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s">'roc_auc'</span><span class="p">)</span>

<span class="c1"># Print list of AUC scores
</span><span class="k">print</span><span class="p">(</span><span class="s">"AUC scores computed using 5-fold cross-validation: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv_auc</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
AUC: 0.8254806777079764

AUC scores computed using 5-fold cross-validation:
[ 0.80148148  0.8062963   0.81481481  0.86245283  0.8554717 ]

</code></pre></div></div>

<hr />

<p>###
<strong>Hyperparameter tuning</strong></p>

<p>####
<strong>Hyperparameter tuning with GridSearchCV</strong></p>

<p>You will now practice this yourself, but by using logistic regression on the diabetes dataset.</p>

<p>Like the alpha parameter of lasso and ridge regularization that you saw earlier, logistic regression also has a regularization parameter: CC. CC controls the
 <em>inverse</em>
 of the regularization strength, and this is what you will tune in this exercise. A large CC can lead to an
 <em>overfit</em>
 model, while a small CC can lead to an
 <em>underfit</em>
 model.</p>

<p>The hyperparameter space for CC has been setup for you. Your job is to use GridSearchCV and logistic regression to find the optimal CC in this hyperparameter space.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="c1"># Setup the hyperparameter grid
</span><span class="n">c_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'C'</span><span class="p">:</span> <span class="n">c_space</span><span class="p">}</span>

<span class="c1"># Instantiate a logistic regression classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Instantiate the GridSearchCV object: logreg_cv
</span><span class="n">logreg_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the data
</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Print the tuned parameters and score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Best score is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Logistic Regression Parameters: {'C': 3.7275937203149381}
Best score is 0.7708333333333334

</code></pre></div></div>

<p>####
<strong>Hyperparameter tuning with RandomizedSearchCV</strong></p>

<p>GridSearchCV can be computationally expensive, especially if you are searching over a large hyperparameter space and dealing with multiple hyperparameters. A solution to this is to use
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 , in which not all hyperparameter values are tried out. Instead, a fixed number of hyperparameter settings is sampled from specified probability distributions. You’ll practice using
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 in this exercise and see how this works.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="kn">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">RandomizedSearchCV</span>

<span class="c1"># Setup the parameters and distributions to sample from: param_dist
</span><span class="n">param_dist</span> <span class="o">=</span> <span class="p">{</span><span class="s">"max_depth"</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
              <span class="s">"max_features"</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="s">"min_samples_leaf"</span><span class="p">:</span> <span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
              <span class="s">"criterion"</span><span class="p">:</span> <span class="p">[</span><span class="s">"gini"</span><span class="p">,</span> <span class="s">"entropy"</span><span class="p">]}</span>

<span class="c1"># Instantiate a Decision Tree classifier: tree
</span><span class="n">tree</span> <span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">()</span>

<span class="c1"># Instantiate the RandomizedSearchCV object: tree_cv
</span><span class="n">tree_cv</span> <span class="o">=</span> <span class="n">RandomizedSearchCV</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">param_dist</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the data
</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Print the tuned parameters and score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Decision Tree Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Best score is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tree_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Decision Tree Parameters: {'criterion': 'entropy', 'max_depth': 3, 'max_features': 7, 'min_samples_leaf': 1}
Best score is 0.7317708333333334

</code></pre></div></div>

<p>Note that
 <code class="language-plaintext highlighter-rouge">RandomizedSearchCV</code>
 will never outperform
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 . Instead, it is valuable because it saves on computation time.</p>

<p>###
<strong>Hold-out set for final evaluation</strong></p>

<p>####
<strong>Hold-out set in practice I: Classification</strong></p>

<p>In addition to CC, logistic regression has a
 <code class="language-plaintext highlighter-rouge">'penalty'</code>
 hyperparameter which specifies whether to use
 <code class="language-plaintext highlighter-rouge">'l1'</code>
 or
 <code class="language-plaintext highlighter-rouge">'l2'</code>
 regularization. Your job in this exercise is to create a hold-out set, tune the
 <code class="language-plaintext highlighter-rouge">'C'</code>
 and
 <code class="language-plaintext highlighter-rouge">'penalty'</code>
 hyperparameters of a logistic regression classifier using
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 on the training set.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># diabetes data set
</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span>

<span class="c1"># Create the hyperparameter grid
</span><span class="n">c_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'C'</span><span class="p">:</span> <span class="n">c_space</span><span class="p">,</span> <span class="s">'penalty'</span><span class="p">:</span> <span class="p">[</span><span class="s">'l1'</span><span class="p">,</span> <span class="s">'l2'</span><span class="p">]}</span>

<span class="c1"># Instantiate the logistic regression classifier: logreg
</span><span class="n">logreg</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Instantiate the GridSearchCV object: logreg_cv
</span><span class="n">logreg_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">logreg</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the training data
</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Print the optimal parameters and best score
</span><span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Parameter: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned Logistic Regression Accuracy: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">logreg_cv</span><span class="p">.</span><span class="n">best_score_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned Logistic Regression Parameter: {'C': 0.43939705607607948, 'penalty': 'l1'}
Tuned Logistic Regression Accuracy: 0.7652173913043478

</code></pre></div></div>

<p>####
<strong>Hold-out set in practice II: Regression</strong></p>

<p>Remember lasso and ridge regression from the previous chapter? Lasso used the L1 penalty to regularize, while ridge used the L2 penalty. There is another type of regularized regression known as the elastic net. In elastic net regularization, the penalty term is a linear combination of the L1 and L2 penalties:</p>

<p><strong>a∗L1+b∗L2</strong></p>

<p>In scikit-learn, this term is represented by the
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 parameter: An
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 of
 <code class="language-plaintext highlighter-rouge">1</code>
 corresponds to an L1L1 penalty, and anything lower is a combination of L1L1 and L2L2.</p>

<p>In this exercise, you will
 <code class="language-plaintext highlighter-rouge">GridSearchCV</code>
 to tune the
 <code class="language-plaintext highlighter-rouge">'l1_ratio'</code>
 of an elastic net model trained on the Gapminder data. As in the previous exercise, use a hold-out set to evaluate your model’s performance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5
3   2975029.0       1.40  0.1   1.804106  25.35542   7383.0    132.8108  72.5
4  21370348.0       1.96  0.1  18.016313  27.56373  41312.0    117.3755  81.5

   child_mortality
0             29.5
1            192.0
2             15.4
3             20.0
4              5.2


</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">ElasticNet</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="kn">import</span> <span class="n">mean_squared_error</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">train_test_split</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the hyperparameter grid
</span><span class="n">l1_space</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">param_grid</span> <span class="o">=</span> <span class="p">{</span><span class="s">'l1_ratio'</span><span class="p">:</span> <span class="n">l1_space</span><span class="p">}</span>

<span class="c1"># Instantiate the ElasticNet regressor: elastic_net
</span><span class="n">elastic_net</span> <span class="o">=</span> <span class="n">ElasticNet</span><span class="p">()</span>

<span class="c1"># Setup the GridSearchCV object: gm_cv
</span><span class="n">gm_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">elastic_net</span><span class="p">,</span> <span class="n">param_grid</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Fit it to the training data
</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict on the test set and compute metrics
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">r2</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="n">mse</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet l1 ratio: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet R squared: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet MSE: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">mse</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Tuned ElasticNet l1 ratio: {'l1_ratio': 0.20689655172413793}
Tuned ElasticNet R squared: 0.8668305372460283
Tuned ElasticNet MSE: 10.05791413339844

</code></pre></div></div>

<hr />

<h2 id="preprocessing-and-pipelines-4"><strong>Preprocessing and pipelines</strong></h2>

<p>###
<strong>Preprocessing data</strong></p>

<p>####
<strong>Exploring categorical features</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5
3   2975029.0       1.40  0.1   1.804106  25.35542   7383.0    132.8108  72.5
4  21370348.0       1.96  0.1  18.016313  27.56373  41312.0    117.3755  81.5

   child_mortality                      Region
0             29.5  Middle East &amp; North Africa
1            192.0          Sub-Saharan Africa
2             15.4                     America
3             20.0       Europe &amp; Central Asia
4              5.2         East Asia &amp; Pacific

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import pandas
</span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="c1"># Read 'gapminder.csv' into a DataFrame: df
</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">'gapminder.csv'</span><span class="p">)</span>

<span class="c1"># Create a boxplot of life expectancy per region
</span><span class="n">df</span><span class="p">.</span><span class="n">boxplot</span><span class="p">(</span><span class="s">'life'</span><span class="p">,</span> <span class="s">'Region'</span><span class="p">,</span> <span class="n">rot</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/supervised-learning-with-scikit-learn/capture3-19.png?w=1024" alt="Desktop View" /></p>

<p>####
<strong>Creating dummy variables</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create dummy variables: df_region
</span><span class="n">df_region</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Print the columns of df_region
</span><span class="k">print</span><span class="p">(</span><span class="n">df_region</span><span class="p">.</span><span class="n">columns</span><span class="p">)</span>

<span class="c1"># Create dummy variables with drop_first=True: df_region
</span><span class="n">df_region</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">drop_first</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Print the new columns of df_region
</span><span class="k">print</span><span class="p">(</span><span class="n">df_region</span><span class="p">.</span><span class="n">columns</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality', 'Region_America',
       'Region_East Asia &amp; Pacific', 'Region_Europe &amp; Central Asia',
       'Region_Middle East &amp; North Africa', 'Region_South Asia',
       'Region_Sub-Saharan Africa'],
      dtype='object')

# Region_America has been dropped
Index(['population', 'fertility', 'HIV', 'CO2', 'BMI_male', 'GDP',
       'BMI_female', 'life', 'child_mortality', 'Region_East Asia &amp; Pacific',
       'Region_Europe &amp; Central Asia', 'Region_Middle East &amp; North Africa',
       'Region_South Asia', 'Region_Sub-Saharan Africa'],
      dtype='object')


df_region.head()
   population  fertility  HIV        CO2  BMI_male      GDP  BMI_female  life  \
0  34811059.0       2.73  0.1   3.328945  24.59620  12314.0    129.9049  75.3
1  19842251.0       6.43  2.0   1.474353  22.25083   7103.0    130.1247  58.3
2  40381860.0       2.24  0.5   4.785170  27.50170  14646.0    118.8915  75.5

   child_mortality  Region_East Asia &amp; Pacific  Region_Europe &amp; Central Asia  \
0             29.5                           0                             0
1            192.0                           0                             0
2             15.4                           0                             0

   Region_Middle East &amp; North Africa  Region_South Asia  \
0                                  1                  0
1                                  0                  0
2                                  0                  0

   Region_Sub-Saharan Africa
0                          0
1                          1
2                          0

</code></pre></div></div>

<p>####
<strong>Regression with categorical features</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">Ridge</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_val_score</span>

<span class="c1"># Instantiate a ridge regressor: ridge
</span><span class="n">ridge</span> <span class="o">=</span> <span class="n">Ridge</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c1"># Perform 5-fold cross-validation: ridge_cv
</span><span class="n">ridge_cv</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">ridge</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Print the cross-validated scores
</span><span class="k">print</span><span class="p">(</span><span class="n">ridge_cv</span><span class="p">)</span>
<span class="p">[</span> <span class="mf">0.86808336</span>  <span class="mf">0.80623545</span>  <span class="mf">0.84004203</span>  <span class="mf">0.7754344</span>   <span class="mf">0.87503712</span><span class="p">]</span>

</code></pre></div></div>

<hr />

<p>###
<strong>Handling missing data</strong></p>

<p>####
<strong>Dropping missing data</strong></p>

<p>Now, it’s time for you to take care of these yourself!</p>

<p>The unprocessed dataset has been loaded into a DataFrame
 <code class="language-plaintext highlighter-rouge">df</code>
 . Explore it in the IPython Shell with the
 <code class="language-plaintext highlighter-rouge">.head()</code>
 method. You will see that there are certain data points labeled with a
 <code class="language-plaintext highlighter-rouge">'?'</code>
 . These denote missing values. As you saw in the video, different datasets encode missing values in different ways. Sometimes it may be a
 <code class="language-plaintext highlighter-rouge">'9999'</code>
 , other times a
 <code class="language-plaintext highlighter-rouge">0</code>
 – real-world data can be very messy! If you’re lucky, the missing values will already be encoded as
 <code class="language-plaintext highlighter-rouge">NaN</code>
 . We use
 <code class="language-plaintext highlighter-rouge">NaN</code>
 because it is an efficient and simplified way of internally representing missing data, and it lets us take advantage of pandas methods such as
 <code class="language-plaintext highlighter-rouge">.dropna()</code>
 and
 <code class="language-plaintext highlighter-rouge">.fillna()</code>
 , as well as scikit-learn’s Imputation transformer
 <code class="language-plaintext highlighter-rouge">Imputer()</code>
 .</p>

<p>In this exercise, your job is to convert the
 <code class="language-plaintext highlighter-rouge">'?'</code>
 s to NaNs, and then drop the rows that contain them from the DataFrame.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head(3)
        party infants water budget physician salvador religious satellite aid  \
0  republican       0     1      0         1        1         1         0   0
1  republican       0     1      0         1        1         1         0   0
2    democrat       ?     1      1         ?        1         1         0   0

  missile immigration synfuels education superfund crime duty_free_exports  \
0       0           1        ?         1         1     1                 0
1       0           0        0         1         1     1                 0
2       0           0        1         0         1     1                 0

  eaa_rsa
0       1
1       ?
2       0

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Convert '?' to NaN
</span><span class="n">df</span><span class="p">[</span><span class="n">df</span> <span class="o">==</span> <span class="s">'?'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">nan</span>

<span class="c1"># Print the number of NaNs
</span><span class="k">print</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">isnull</span><span class="p">().</span><span class="nb">sum</span><span class="p">())</span>

<span class="c1"># Print shape of original DataFrame
</span><span class="k">print</span><span class="p">(</span><span class="s">"Shape of Original DataFrame: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>

<span class="c1"># Drop missing values and print shape of new DataFrame
</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="n">dropna</span><span class="p">()</span>

<span class="c1"># Print shape of new DataFrame
</span><span class="k">print</span><span class="p">(</span><span class="s">"Shape of DataFrame After Dropping All Rows with Missing Values: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">df</span><span class="p">.</span><span class="n">shape</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
party                  0
infants               12
water                 48
budget                11
physician             11
salvador              15
religious             11
satellite             14
aid                   15
missile               22
immigration            7
synfuels              21
education             31
superfund             25
crime                 17
duty_free_exports     28
eaa_rsa              104
dtype: int64
Shape of Original DataFrame: (435, 17)


Shape of DataFrame After Dropping All Rows with Missing Values: (232, 17)

</code></pre></div></div>

<p>When many values in your dataset are missing, if you drop them, you may end up throwing away valuable information along with the missing data. It’s better instead to develop an imputation strategy. This is where domain knowledge is useful, but in the absence of it, you can impute missing values with the mean or the median of the row or column that the missing value is in.</p>

<p>####
<strong>Imputing missing data in a ML Pipeline I</strong></p>

<p>As you’ve come to appreciate, there are many steps to building a model, from creating training and test sets, to fitting a classifier or regressor, to tuning its parameters, to evaluating its performance on new data. Imputation can be seen as the first step of this machine learning process, the entirety of which can be viewed within the context of a pipeline. Scikit-learn provides a pipeline constructor that allows you to piece together these steps into one process and thereby simplify your workflow.</p>

<p>You’ll now practice setting up a pipeline with two steps: the imputation step, followed by the instantiation of a classifier. You’ve seen three classifiers in this course so far: k-NN, logistic regression, and the decision tree. You will now be introduced to a fourth one – the Support Vector Machine, or
 <a href="http://scikit-learn.org/stable/modules/svm.html">SVM</a>
 .</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the Imputer module
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Imputer</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Setup the Imputation transformer: imp
# axis=0 for column
</span><span class="n">imp</span> <span class="o">=</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'most_frequent'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Instantiate the SVC classifier: clf
</span><span class="n">clf</span> <span class="o">=</span> <span class="n">SVC</span><span class="p">()</span>

<span class="c1"># Setup the pipeline with the required steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">imp</span><span class="p">),</span>
        <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">clf</span><span class="p">)]</span>

</code></pre></div></div>

<p>####
<strong>Imputing missing data in a ML Pipeline II</strong></p>

<p>Having setup the steps of the pipeline in the previous exercise, you will now use it on the voting dataset to classify a Congressman’s party affiliation.</p>

<p>What makes pipelines so incredibly useful is the simple interface that they provide. You can use the
 <code class="language-plaintext highlighter-rouge">.fit()</code>
 and
 <code class="language-plaintext highlighter-rouge">.predict()</code>
 methods on pipelines just as you did with your classifiers and regressors!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">Imputer</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="kn">import</span> <span class="n">SVC</span>

<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'most_frequent'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
        <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Create training and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Fit the pipeline to the train set
</span><span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute metrics
</span><span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
             precision    recall  f1-score   support

   democrat       0.99      0.96      0.98        85
 republican       0.94      0.98      0.96        46

avg / total       0.97      0.97      0.97       131

</code></pre></div></div>

<p>###
<strong>Centering and scaling</strong></p>

<p>####
<strong>Centering and scaling your data</strong></p>

<p>You will now explore scaling for yourself on a new dataset –
 <a href="https://archive.ics.uci.edu/ml/datasets/Wine+Quality">White Wine Quality</a>
 !</p>

<p>We have used the
 <code class="language-plaintext highlighter-rouge">'quality'</code>
 feature of the wine to create a binary target variable: If
 <code class="language-plaintext highlighter-rouge">'quality'</code>
 is less than
 <code class="language-plaintext highlighter-rouge">5</code>
 , the target variable is
 <code class="language-plaintext highlighter-rouge">1</code>
 , and otherwise, it is
 <code class="language-plaintext highlighter-rouge">0</code>
 .</p>

<p>Notice how some features seem to have different units of measurement.
 <code class="language-plaintext highlighter-rouge">'density'</code>
 , for instance, takes values between 0.98 and 1.04, while
 <code class="language-plaintext highlighter-rouge">'total sulfur dioxide'</code>
 ranges from 9 to 440. As a result, it may be worth scaling the features here. Your job in this exercise is to scale the features and compute the mean and standard deviation of the unscaled features compared to the scaled features.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># white wine quality data set
</span><span class="n">df</span><span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
   <span class="n">fixed</span> <span class="n">acidity</span>  <span class="n">volatile</span> <span class="n">acidity</span>  <span class="n">citric</span> <span class="n">acid</span>  <span class="n">residual</span> <span class="n">sugar</span>  <span class="n">chlorides</span>  \
<span class="mi">0</span>            <span class="mf">7.0</span>              <span class="mf">0.27</span>         <span class="mf">0.36</span>            <span class="mf">20.7</span>      <span class="mf">0.045</span>
<span class="mi">1</span>            <span class="mf">6.3</span>              <span class="mf">0.30</span>         <span class="mf">0.34</span>             <span class="mf">1.6</span>      <span class="mf">0.049</span>
<span class="mi">2</span>            <span class="mf">8.1</span>              <span class="mf">0.28</span>         <span class="mf">0.40</span>             <span class="mf">6.9</span>      <span class="mf">0.050</span>

   <span class="n">free</span> <span class="n">sulfur</span> <span class="n">dioxide</span>  <span class="n">total</span> <span class="n">sulfur</span> <span class="n">dioxide</span>  <span class="n">density</span>    <span class="n">pH</span>  <span class="n">sulphates</span>  \
<span class="mi">0</span>                 <span class="mf">45.0</span>                 <span class="mf">170.0</span>   <span class="mf">1.0010</span>  <span class="mf">3.00</span>       <span class="mf">0.45</span>
<span class="mi">1</span>                 <span class="mf">14.0</span>                 <span class="mf">132.0</span>   <span class="mf">0.9940</span>  <span class="mf">3.30</span>       <span class="mf">0.49</span>
<span class="mi">2</span>                 <span class="mf">30.0</span>                  <span class="mf">97.0</span>   <span class="mf">0.9951</span>  <span class="mf">3.26</span>       <span class="mf">0.44</span>

   <span class="n">alcohol</span>  <span class="n">quality</span>
<span class="mi">0</span>      <span class="mf">8.8</span>        <span class="mi">6</span>
<span class="mi">1</span>      <span class="mf">9.5</span>        <span class="mi">6</span>
<span class="mi">2</span>     <span class="mf">10.1</span>        <span class="mi">6</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import scale
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">scale</span>

<span class="c1"># Scale the features: X_scaled
</span><span class="n">X_scaled</span> <span class="o">=</span> <span class="n">scale</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

<span class="c1"># Print the mean and standard deviation of the unscaled features
</span><span class="k">print</span><span class="p">(</span><span class="s">"Mean of Unscaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Standard Deviation of Unscaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">)))</span>

<span class="c1"># Print the mean and standard deviation of the scaled features
</span><span class="k">print</span><span class="p">(</span><span class="s">"Mean of Scaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Standard Deviation of Scaled Features: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)))</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Mean of Unscaled Features: 18.432687072460002
Standard Deviation of Unscaled Features: 41.54494764094571

Mean of Scaled Features: 2.7314972981668206e-15
Standard Deviation of Scaled Features: 0.9999999999999999

</code></pre></div></div>

<p>####
<strong>Centering and scaling in a pipeline</strong></p>

<p>With regard to whether or not scaling is effective, the proof is in the pudding! See for yourself whether or not scaling the features of the White Wine Quality dataset has any impact on its performance.</p>

<p>You will use a k-NN classifier as part of a pipeline that includes scaling, and for the purposes of comparison, a k-NN classifier trained on the unscaled data has been provided.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Import the necessary modules
</span><span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>

<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
        <span class="p">(</span><span class="s">'knn'</span><span class="p">,</span> <span class="n">KNeighborsClassifier</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Fit the pipeline to the training set: knn_scaled
</span><span class="n">knn_scaled</span> <span class="o">=</span> <span class="n">pipeline</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Instantiate and fit a k-NN classifier to the unscaled data
</span><span class="n">knn_unscaled</span> <span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">().</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Compute and print metrics
</span><span class="k">print</span><span class="p">(</span><span class="s">'Accuracy with Scaling: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">knn_scaled</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Accuracy without Scaling: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">knn_unscaled</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>

<span class="n">Accuracy</span> <span class="k">with</span> <span class="n">Scaling</span><span class="p">:</span> <span class="mf">0.7700680272108843</span>
<span class="n">Accuracy</span> <span class="n">without</span> <span class="n">Scaling</span><span class="p">:</span> <span class="mf">0.6979591836734694</span>

</code></pre></div></div>

<p>It looks like scaling has significantly improved model performance!</p>

<hr />

<p>####
<strong>Bringing it all together I: Pipeline for classification</strong></p>

<p>It is time now to piece together everything you have learned so far into a pipeline for classification! Your job in this exercise is to build a pipeline that includes scaling and hyperparameter tuning to classify wine quality.</p>

<p>You’ll return to using the SVM classifier you were briefly introduced to earlier in this chapter. The hyperparameters you will tune are C and gamma. C controls the regularization strength. It is analogous to the C you tuned for logistic regression in Chapter 3, while gamma controls the kernel coefficient:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup the pipeline
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
         <span class="p">(</span><span class="s">'SVM'</span><span class="p">,</span> <span class="n">SVC</span><span class="p">())]</span>

<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Specify the hyperparameter space
</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">'SVM__C'</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
              <span class="s">'SVM__gamma'</span><span class="p">:[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]}</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">21</span><span class="p">)</span>

<span class="c1"># Instantiate the GridSearchCV object: cv
</span><span class="n">cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="c1"># Fit to the training set
</span><span class="n">cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Predict the labels of the test set: y_pred
</span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">cv</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>

<span class="c1"># Compute and print metrics
</span><span class="k">print</span><span class="p">(</span><span class="s">"Accuracy: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">classification_report</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned Model Parameters: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>


</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Accuracy: 0.7795918367346939
             precision    recall  f1-score   support

      False       0.83      0.85      0.84       662
       True       0.67      0.63      0.65       318

avg / total       0.78      0.78      0.78       980

Tuned Model Parameters: {'SVM__C': 10, 'SVM__gamma': 0.1}

</code></pre></div></div>

<p>####
<strong>Bringing it all together II: Pipeline for regression</strong></p>

<p>Your job is to build a pipeline that imputes the missing data, scales the features, and fits an ElasticNet to the Gapminder data. You will then tune the
 <code class="language-plaintext highlighter-rouge">l1_ratio</code>
 of your ElasticNet using GridSearchCV.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Setup the pipeline steps: steps
</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[(</span><span class="s">'imputation'</span><span class="p">,</span> <span class="n">Imputer</span><span class="p">(</span><span class="n">missing_values</span><span class="o">=</span><span class="s">'NaN'</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s">'mean'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
         <span class="p">(</span><span class="s">'scaler'</span><span class="p">,</span> <span class="n">StandardScaler</span><span class="p">()),</span>
         <span class="p">(</span><span class="s">'elasticnet'</span><span class="p">,</span> <span class="n">ElasticNet</span><span class="p">())]</span>

<span class="c1"># Create the pipeline: pipeline
</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>

<span class="c1"># Specify the hyperparameter space
</span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s">'elasticnet__l1_ratio'</span><span class="p">:</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">30</span><span class="p">)}</span>

<span class="c1"># Create train and test sets
</span><span class="n">X_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test_size</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Create the GridSearchCV object: gm_cv
</span><span class="n">gm_cv</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="c1"># Fit to the training set
</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>

<span class="c1"># Compute and print the metrics
</span><span class="n">r2</span> <span class="o">=</span> <span class="n">gm_cv</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet Alpha: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">gm_cv</span><span class="p">.</span><span class="n">best_params_</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Tuned ElasticNet R squared: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">r2</span><span class="p">))</span>

<span class="c1">#    Tuned ElasticNet Alpha: {'elasticnet__l1_ratio': 1.0}
#    Tuned ElasticNet R squared: 0.8862016570888217
</span>
</code></pre></div></div>

<p>The End.</p>

<p>Thank you for reading.</p>

