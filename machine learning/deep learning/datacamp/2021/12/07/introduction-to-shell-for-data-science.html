<h1 id="introduction-to-shell-for-data-science">Introduction to Shell for Data Science</h1>

<p>This is the memo of the 19th course of ‘Data Scientist with Python’ track.</p>

<p><strong>You can find the original course
 <a href="https://www.datacamp.com/courses/introduction-to-shell-for-data-science">HERE</a></strong>
 .</p>

<hr />

<h1 id="1-manipulating-files-and-directories"><strong>1. Manipulating files and directories</strong></h1>
<hr />

<p>#### 
<strong>How does the shell compare to a desktop interface?</strong></p>

<p>They are both interfaces for issuing commands to the operating system.</p>

<p>#### 
<strong>Some Basic commands: pwd, ls</strong></p>

<p>pwd —
 <strong>p</strong> 
 rint
 <strong>w</strong> 
 orking
 <strong>d</strong> 
 irectory</p>

<p>ls —
 <strong>l</strong> 
 i
 <strong>s</strong> 
 ting</p>

<p>#### 
<strong>Absolute Path vs. Relative Path</strong></p>

<p>The shell decides if a path is absolute or relative by looking at its first character: if it begins with
 <code class="language-plaintext highlighter-rouge">/</code> 
 , it is absolute, and if it doesn’t, it is relative.</p>

<p>#### 
<strong>Some Basic commands: cd</strong></p>

<p>cd — change directory</p>

<p>#### 
<strong>Directory Basic</strong></p>

<p>. — the current directory</p>

<p>.. — the directory above the one I’m currently in</p>

<p>~ — your home directory</p>

<p>#### 
<strong>Some Basic commands: cp, mv</strong></p>

<p>cp — copy</p>

<p>cp fileA fileB # copy fileA to fileB</p>

<p>cp fileA fileB fileC NewDirectory #copy fileA fileB fileC to NewDirectory</p>

<p>mv — move (when a new destination directory is specified)</p>

<p>mv – rename (when no new destination directory is specified)</p>

<p>same syntax as copy</p>

<p>mv fileA fileB # rename fileA to fileB</p>

<p>mv fileA fileB fileC NewDirectory #move fileA fileB fileC to NewDirectory</p>

<p><strong># caution: both cp and mv will overwrite the existing file</strong></p>

<p>#### 
<strong>Some Basic commands: rm, rmdir, mkdir</strong></p>

<p>rm — remove files</p>

<p>rm fileA fileB</p>

<p><strong># caution: if a file is removed, it’s removed forever</strong></p>

<p>rmdir — remove an empty directory</p>

<p>rmdir directoryA</p>

<p>mkdir — make a directory</p>

<p>mkdir directoryA</p>

<hr />

<h1 id="2-manipulating-data"><strong>2. Manipulating data</strong></h1>
<hr />

<p>#### 
<strong>Some Basic commands: cat</strong></p>

<p>cat — concatenate, show file contents</p>

<p>cat fileA</p>

<p>#### 
<strong>Some Basic commands: less</strong></p>

<p>less — is more, show file contents</p>

<p>less fileA fileB</p>

<p>when less fileA</p>

<p>space — page down</p>

<p><code class="language-plaintext highlighter-rouge">:n</code> 
 — to move to the next file</p>

<p><code class="language-plaintext highlighter-rouge">:p</code> 
 — to go back to the previous one</p>

<p><code class="language-plaintext highlighter-rouge">:q</code> 
 — to quit.</p>

<p>#### 
<strong>Some Basic commands: head</strong></p>

<p>head — display first 10 lines of a file</p>

<p>head fileA</p>

<p>#### 
<strong>Tips: tab completion</strong></p>

<p>If you start typing the name of a file and then press the tab key, the shell will do its best to auto-complete the path.</p>

<p>#### 
<strong>command-line flag</strong></p>

<p>head -n 3 fileA # display first n(n = 3 here) lines of a file</p>

<p>-n —
 <strong>n</strong> 
 umber of lines</p>

<p>#### 
<strong>ls -RF</strong></p>

<p>ls -RF directoryA</p>

<p>ls -FR directoryA</p>

<p>ls -F -R directoryA</p>

<p>ls -R -F directoryA</p>

<p>are all the same command</p>

<p>-R — recursive, list everything below a directory</p>

<p>-F — prints a / after the name of every directory and a * after the name of every runnable program.</p>

<p>#### 
<strong>Some Basic commands: man</strong></p>

<p>man — manual</p>

<p>man head</p>

<p><img src="/blog/assets/datacamp/introduction-to-shell-for-data-science/capture-20.png" alt="Desktop View" /></p>

<p><code class="language-plaintext highlighter-rouge">man</code> 
 automatically invokes
 <code class="language-plaintext highlighter-rouge">less</code> 
 , so you may need to press spacebar to page through the information and
 <code class="language-plaintext highlighter-rouge">:q</code> 
 to quit.</p>

<p>The one-line description under
 <code class="language-plaintext highlighter-rouge">NAME</code> 
 tells you briefly what the command does, and the summary under
 <code class="language-plaintext highlighter-rouge">SYNOPSIS</code> 
 lists all the flags it understands. Anything that is optional is shown in square brackets
 <code class="language-plaintext highlighter-rouge">[...]</code> 
 , either/or alternatives are separated by
 <code class="language-plaintext highlighter-rouge">|</code> 
 , and things that can be repeated are shown by
 <code class="language-plaintext highlighter-rouge">...</code> 
 , so
 <code class="language-plaintext highlighter-rouge">head</code> 
 ‘s manual page is telling you that you can
 <em>either</em> 
 give a line count with
 <code class="language-plaintext highlighter-rouge">-n</code> 
 or a byte count with
 <code class="language-plaintext highlighter-rouge">-c</code> 
 , and that you can give it any number of filenames.</p>

<p>#### 
<strong>Some Basic commands: tail</strong></p>

<p>tail — display last 10 lines of a file</p>

<p>tail -n 1 fileA # display last 1 lines of a fileA</p>

<p>tail -n +2 fileA # display from the 2nd lines to the end of a fileA</p>

<p>#### 
<strong>Some Basic commands: cut</strong></p>

<p>cut -f 2-5,8 -d , fileA.csv</p>

<p>-f 2-5, 8 — fields, select columns 2 through 5 and columns 8, using comma as the separator</p>

<p>-d , — delimiter, use ‘,’ as delimiter</p>

<p>cut -f2 -d , fileA.csv</p>

<p>cut -f 2 -d , fileA.csv</p>

<p>are the same.</p>

<p>Space is optional between -f and 2</p>

<p>#### 
<strong>repeat commands</strong></p>

<p>history — print a list of commands you have run recently</p>

<p>!some_command — run the last some_command again(ex. !cut)</p>

<p>!2 — run the 2nd command listed in history</p>

<p>#### 
<strong>Some Basic commands: grep</strong></p>

<p>grep patternA fileA</p>

<ul>
  <li>
    <dl>
      <dt><code class="language-plaintext highlighter-rouge">-c</code></dt>
      <dd>print a count of matching lines rather than the lines themselves</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><code class="language-plaintext highlighter-rouge">-h</code></dt>
      <dd>do
 <em>not</em> 
 print the names of files when searching multiple files</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><code class="language-plaintext highlighter-rouge">-i</code></dt>
      <dd>ignore case (e.g., treat “Regression” and “regression” as matches)</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><code class="language-plaintext highlighter-rouge">-l</code></dt>
      <dd>print the names of files that contain matches, not the matches</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><code class="language-plaintext highlighter-rouge">-n</code></dt>
      <dd>print line numbers for matching lines</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><code class="language-plaintext highlighter-rouge">-v</code></dt>
      <dd>invert the match, i.e., only show lines that
 <em>don’t</em> 
 match</dd>
    </dl>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ grep molar seasonal/autumn.csv
2017-02-01,molar
2017-05-25,molar

$ grep -nv molar seasonal/spring.csv
1:Date,Tooth
2:2017-01-25,wisdom
3:2017-02-19,canine
...
8:2017-03-14,incisor
10:2017-04-29,wisdom
11:2017-05-08,canine
...
22:2017-08-13,incisor
23:2017-08-13,wisdom

$ grep -c incisor seasonal/autumn.csv seasonal/winter.csv
seasonal/autumn.csv:3
seasonal/winter.csv:6

</code></pre></div></div>

<p>#### 
<strong>Some Basic commands: paste</strong></p>

<p>paste — to combine data files</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ paste -d , seasonal/autumn.csv seasonal/winter.csv
Date,Tooth,Date,Tooth2017-01-05,canine,2017-01-03,bicuspid
2017-01-17,wisdom,2017-01-05,incisor
2017-01-18,canine,2017-01-21,wisdom
...
2017-08-16,canine,2017-07-01,incisor
,2017-07-17,canine
,2017-08-10,incisor
...

# The last few rows have the wrong number of columns.

</code></pre></div></div>

<hr />

<h1 id="3-combining-tools"><strong>3. Combining tools</strong></h1>
<hr />

<p>#### 
<strong>Store a command’s output in a file</strong></p>

<p>some_command &gt; new_file</p>

<p>ex. tail -n 5 seasonal/winter.csv &gt; last.csv</p>

<p>#### 
<strong>combine commands</strong></p>

<table>
  <tbody>
    <tr>
      <td>command_A</td>
      <td>command_B</td>
      <td>…</td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ cut -f 2 -d , seasonal/summer.csv | grep -v Tooth
canine
wisdom
bicuspid
...

</code></pre></div></div>

<p>#### 
<strong>Some Basic commands: wc</strong></p>

<p>wc — word count, prints the number of characters, words, and lines in a file. You can make it print only one of these using
 <code class="language-plaintext highlighter-rouge">-c</code> 
 ,
 <code class="language-plaintext highlighter-rouge">-w</code> 
 , or
 <code class="language-plaintext highlighter-rouge">-l</code> 
 respectively.</p>

<table>
  <tbody>
    <tr>
      <td>$ grep 2017-07 seasonal/spring.csv</td>
      <td>wc -l</td>
    </tr>
  </tbody>
</table>

<p>#### 
<em>*wildcards: **</em></p>

<p><code class="language-plaintext highlighter-rouge">*</code> 
 , which means “match zero or more characters”.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ head -n 3 seasonal/s*.csv
==&gt; seasonal/spring.csv &lt;==
Date,Tooth
2017-01-25,wisdom
2017-02-19,canine

==&gt; seasonal/summer.csv &lt;==
Date,Tooth
2017-01-11,canine
2017-01-18,wisdom

</code></pre></div></div>

<p>#### 
<strong>wildcards: ?, [], {}</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">?</code> 
 matches a single character, so
 <code class="language-plaintext highlighter-rouge">201?.txt</code> 
 will match
 <code class="language-plaintext highlighter-rouge">2017.txt</code> 
 or
 <code class="language-plaintext highlighter-rouge">2018.txt</code> 
 , but not
 <code class="language-plaintext highlighter-rouge">2017-01.txt</code> 
 .</li>
  <li><code class="language-plaintext highlighter-rouge">[...]</code> 
 matches any one of the characters inside the square brackets, so
 <code class="language-plaintext highlighter-rouge">201[78].txt</code> 
 matches
 <code class="language-plaintext highlighter-rouge">2017.txt</code> 
 or
 <code class="language-plaintext highlighter-rouge">2018.txt</code> 
 , but not
 <code class="language-plaintext highlighter-rouge">2016.txt</code> 
 .</li>
  <li><code class="language-plaintext highlighter-rouge">{...}</code> 
 matches any of the comma-separated patterns inside the curly brackets, so
 <code class="language-plaintext highlighter-rouge">{*.txt, *.csv}</code> 
 matches any file whose name ends with
 <code class="language-plaintext highlighter-rouge">.txt</code> 
 or
 <code class="language-plaintext highlighter-rouge">.csv</code> 
 , but not files whose names end with
 <code class="language-plaintext highlighter-rouge">.pdf</code> 
 .</li>
</ul>

<p>#### 
<strong>Some Basic commands: sort</strong></p>

<p>sort — By default it does this in ascending alphabetical order</p>

<p><code class="language-plaintext highlighter-rouge">-n</code> 
 and
 <code class="language-plaintext highlighter-rouge">-r</code> 
 can be used to sort numerically and reverse the order of its output</p>

<p><code class="language-plaintext highlighter-rouge">-b</code> 
 tells it to ignore leading blanks</p>

<p><code class="language-plaintext highlighter-rouge">-f</code> 
 tells it to
 <strong>f</strong> 
 old case (i.e., be case-insensitive)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ sort -r  seasonal/summer.csv
Date,Tooth
2017-08-04,canine
2017-08-03,bicuspid
2017-08-02,canine
...

</code></pre></div></div>

<p>#### 
<strong>Some Basic commands: uniq</strong></p>

<p>uniq — remove duplicated lines</p>

<p>If a file contains:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
2017-07-03
2017-07-03
2017-08-03
2017-08-03

</code></pre></div></div>

<p>then
 <code class="language-plaintext highlighter-rouge">uniq</code> 
 will produce:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
2017-07-03
2017-08-03

</code></pre></div></div>

<p>but if it contains:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
2017-07-03
2017-08-03
2017-07-03
2017-08-03

</code></pre></div></div>

<p>then
 <code class="language-plaintext highlighter-rouge">uniq</code> 
 will print all four lines.</p>

<p>The reason is that
 <code class="language-plaintext highlighter-rouge">uniq</code> 
 is built to work with very large files. In order to remove non-adjacent lines from a file, it would have to keep the whole file in memory (or at least, all the unique lines seen so far). By only removing adjacent duplicates, it only has to keep the most recent unique line in memory.</p>

<ul>
  <li>get the second column from
 <code class="language-plaintext highlighter-rouge">seasonal/winter.csv</code> 
 ,</li>
  <li>remove the word “Tooth” from the output so that only tooth names are displayed</li>
  <li>sort the output so that all occurrences of a particular tooth name are adjacent</li>
  <li>display each tooth name once along with a count of how often it occurs</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ cut -d , -f 2 seasonal/winter.csv | grep -v Tooth | sort | uniq -c
      4 bicuspid
      7 canine
      6 incisor
      4 molar
      4 wisdom

</code></pre></div></div>

<p>#### 
<strong>stop a running program</strong></p>

<p><code class="language-plaintext highlighter-rouge">Ctrl</code> 
 +
 <code class="language-plaintext highlighter-rouge">C</code></p>

<p>#### 
<strong>Wrapping up</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ wc -l seasonal/*.csv  21 seasonal/autumn.csv
  24 seasonal/spring.csv  25 seasonal/summer.csv
  26 seasonal/winter.csv
  96 total

$ wc -l seasonal/*.csv | grep -v total
  21 seasonal/autumn.csv
  24 seasonal/spring.csv
  25 seasonal/summer.csv
  26 seasonal/winter.csv

$ wc -l seasonal/*.csv | grep -v total | sort -n | head -n 1
  21 seasonal/autumn.csv

</code></pre></div></div>

<hr />

<h1 id="4-batch-processing"><strong>4. Batch processing</strong></h1>
<hr />

<p>#### 
<strong>environment variables</strong></p>

<p>| 
 Variable
  | 
 Purpose
  | 
 Value
  |
| — | — | — |
| <code class="language-plaintext highlighter-rouge">HOME</code>  | 
 User’s home directory
  | <code class="language-plaintext highlighter-rouge">/home/repl</code>  |
| <code class="language-plaintext highlighter-rouge">PWD</code>  | 
 Present working directory
  | 
 Same as
 <code class="language-plaintext highlighter-rouge">pwd</code> 
 command
  |
| <code class="language-plaintext highlighter-rouge">SHELL</code>  | 
 Which shell program is being used
  | <code class="language-plaintext highlighter-rouge">/bin/bash</code>  |
| <code class="language-plaintext highlighter-rouge">USER</code>  | 
 User’s ID
  | <code class="language-plaintext highlighter-rouge">repl</code>  |</p>

<p>To get a complete list (which is quite long), you can type
 <code class="language-plaintext highlighter-rouge">set</code> 
 in the shell.</p>

<p>ex. HISTFILESIZE determines how many old commands are stored in your command history.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ set | grep HISTFILESIZE
HISTFILESIZE=2000

</code></pre></div></div>

<p>#### 
**print variable</p>

<p>echo $variable_name**</p>

<p>echo — prints its arguments.</p>

<p>To get the variable’s value, you must put a dollar sign
 <code class="language-plaintext highlighter-rouge">$</code> 
 in front of it.</p>

<p>This is true everywhere: to get the value of a variable called
 <code class="language-plaintext highlighter-rouge">X</code> 
 , you must write
 <code class="language-plaintext highlighter-rouge">$X</code> 
 . (This is so that the shell can tell whether you mean “a file named X” or “the value of a variable named X”.)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ echo $OSTYPE
linux-gnu

</code></pre></div></div>

<p>#### 
**shell variable</p>

<p>variable_name=value**</p>

<p>To create a shell variable, you simply assign a value to a name
 <em>without</em> 
 any spaces before or after the
 <code class="language-plaintext highlighter-rouge">=</code> 
 sign.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ testing=seasonal/winter.csv
$ head -n 1 $testing
Date,Tooth

</code></pre></div></div>

<p>#### 
<strong>loops</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for filetype in gif jpg png; do echo $filetype; done

</code></pre></div></div>

<p>it produces:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
gif
jpg
png

</code></pre></div></div>

<p>Notice these things about the loop:</p>

<ol>
  <li><strong>The structure is
 <code class="language-plaintext highlighter-rouge">for</code> 
 …variable…
 <code class="language-plaintext highlighter-rouge">in</code> 
 …list…
 <code class="language-plaintext highlighter-rouge">; do</code> 
 …body…
 <code class="language-plaintext highlighter-rouge">; done</code></strong></li>
  <li>The list of things the loop is to process (in our case, the words
 <code class="language-plaintext highlighter-rouge">gif</code> 
 ,
 <code class="language-plaintext highlighter-rouge">jpg</code> 
 , and
 <code class="language-plaintext highlighter-rouge">png</code> 
 ).</li>
  <li>The variable that keeps track of which thing the loop is currently processing (in our case,
 <code class="language-plaintext highlighter-rouge">filetype</code> 
 ).</li>
  <li>The body of the loop that does the processing (in our case,
 <code class="language-plaintext highlighter-rouge">echo $filetype</code> 
 ).</li>
</ol>

<p>Notice that the body uses
 <code class="language-plaintext highlighter-rouge">$filetype</code> 
 to get the variable’s value instead of just
 <code class="language-plaintext highlighter-rouge">filetype</code> 
 , just like it does with any other shell variable. Also notice where the semi-colons go: the first one comes between the list and the keyword
 <code class="language-plaintext highlighter-rouge">do</code> 
 , and the second comes between the body and the keyword
 <code class="language-plaintext highlighter-rouge">done</code> 
 .</p>

<p>#### 
<em>*loops with wildcard **</em></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ for filename in seasonal/*.csv; do echo $filename; doneseasonal/autumn.csv
seasonal/spring.csv
seasonal/summer.csv
seasonal/winter.csv

</code></pre></div></div>

<p>#### 
<strong>loops with variable $</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ files=seasonal/*.csv
$ for f in $files; do echo $f; done
seasonal/autumn.csv
seasonal/spring.csv
seasonal/summer.csv
seasonal/winter.csv

</code></pre></div></div>

<p>#### 
<strong>loops with pipe |</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ for file in seasonal/*.csv; do head -n 2 $file | tail -n 1; done
2017-01-05,canine
2017-01-25,wisdom
2017-01-11,canine
2017-01-03,bicuspid

$ for file in seasonal/*.csv; do grep -h 2017-07 $file; done
2017-07-10,incisor
2017-07-10,wisdom
2017-07-20,incisor
...

</code></pre></div></div>

<p>#### 
<strong>Avoiding use space in file_name</strong></p>

<p>use ‘ or ” if there is a space in file_name</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
mv 'July 2017.csv' '2017 July data.csv'

</code></pre></div></div>

<p>#### 
<strong>loops with several commands</strong></p>

<p>seperate commands with
 <strong>;</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ for f in seasonal/*.csv; do echo $f head -n 2 $f | tail -n 1; done
seasonal/autumn.csv head -n 2 seasonal/autumn.csv
seasonal/spring.csv head -n 2 seasonal/spring.csv
seasonal/summer.csv head -n 2 seasonal/summer.csv
seasonal/winter.csv head -n 2 seasonal/winter.csv

$ for f in seasonal/*.csv; do echo $f; head -n 2 $f | tail -n 1; done
seasonal/autumn.csv
2017-01-05,canine
seasonal/spring.csv
2017-01-25,wisdom
seasonal/summer.csv
2017-01-11,canine
seasonal/winter.csv
2017-01-03,bicuspid

</code></pre></div></div>

<hr />

<h1 id="5-creating-new-tools"><strong>5. Creating new tools</strong></h1>
<hr />

<p>#### 
<strong>Edit file with nano</strong></p>

<p>Unix has a bewildering variety of text editors. For this course, we will use a simple one called Nano. If you type
 <code class="language-plaintext highlighter-rouge">nano filename</code> 
 , it will open
 <code class="language-plaintext highlighter-rouge">filename</code> 
 for editing (or create it if it doesn’t already exist). You can move around with the arrow keys, delete characters using backspace, and do other operations with control-key combinations:</p>

<ul>
  <li>
    <dl>
      <dt><code class="language-plaintext highlighter-rouge">Ctrl</code> </dt>
      <dt> +</dt>
      <dt> <code class="language-plaintext highlighter-rouge">K</code></dt>
      <dd>delete a line.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><code class="language-plaintext highlighter-rouge">Ctrl</code> </dt>
      <dt> +</dt>
      <dt> <code class="language-plaintext highlighter-rouge">U</code></dt>
      <dd>un-delete a line.</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><code class="language-plaintext highlighter-rouge">Ctrl</code> </dt>
      <dt> +</dt>
      <dt> <code class="language-plaintext highlighter-rouge">O</code></dt>
      <dd>save the file (‘O’ stands for ‘output’).</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt><code class="language-plaintext highlighter-rouge">Ctrl</code> </dt>
      <dt> +</dt>
      <dt> <code class="language-plaintext highlighter-rouge">X</code></dt>
      <dd>exit the editor.</dd>
    </dl>
  </li>
</ul>

<p>#### 
<strong>Save history commands for future use</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ cp seasonal/s*.csv ~/
$ grep -hv Tooth s*.csv &gt; temp.csv
$ history | tail -n 3 &gt; steps.txt
$ cat steps.txt
    9  cp seasonal/s*.csv ~/
   10  grep -hv Tooth s*.csv &gt; temp.csv
   11  history | tail -n 3 &gt; steps.txt

</code></pre></div></div>

<p>#### 
<strong>run shell script</strong></p>

<p>run shell script using</p>

<p>bash script.sh</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ nano dates.sh
$ cat dates.sh
cut -d , -f 1 seasonal/*.csv
$ bash dates.sh
Date
2017-01-05
2017-01-17
2017-01-18
...

</code></pre></div></div>

<p>#### 
<strong>save a script output into a file</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ nano teeth.sh
$ cat teeth.sh
cut -d , -f 2 seasonal/*.csv | grep -v Tooth | sort | uniq -c
$ bash teeth.sh &gt; teeth.out
$ cat teeth.out
     15 bicuspid
     31 canine
     18 incisor
     11 molar
     17 wisdom

</code></pre></div></div>

<p>#### 
<strong>pass filenames to scripts $@</strong></p>

<p>if
 <code class="language-plaintext highlighter-rouge">unique-lines.sh</code> 
 contains this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
sort $@ | uniq

</code></pre></div></div>

<p>then when you run:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
bash unique-lines.sh seasonal/summer.csv

</code></pre></div></div>

<p>the shell replaces
 <code class="language-plaintext highlighter-rouge">$@</code> 
 with
 <code class="language-plaintext highlighter-rouge">seasonal/summer.csv</code> 
 and processes one file. If you run this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
bash unique-lines.sh seasonal/summer.csv seasonal/autumn.csv

</code></pre></div></div>

<p>it processes two data files, and so on.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ nano count-records.sh
$ cat count-records.sh
tail -q -n +2 $@ | wc -l

$ bash count-records.sh seasonal/*.csv &gt; num-records.out
$ head num-records.out
92

</code></pre></div></div>

<p>#### 
<strong>command-line parameters</strong></p>

<p>As well as
 <code class="language-plaintext highlighter-rouge">$@</code> 
 , the shell lets you use
 <code class="language-plaintext highlighter-rouge">$1</code> 
 ,
 <code class="language-plaintext highlighter-rouge">$2</code> 
 , and so on to refer to specific command-line parameters.</p>

<p>The script
 <code class="language-plaintext highlighter-rouge">get-field.sh</code> 
 is supposed to take a filename, the number of the row to select, the number of the column to select, and print just that field from a CSV file.</p>

<p>bash get-field.sh seasonal/summer.csv 4 2</p>

<p>should select the second field from line 4 of
 <code class="language-plaintext highlighter-rouge">seasonal/summer.csv</code> 
 .</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
head -n $2 $1 | tail -n 1 | cut -d , -f $3
bash get-field.sh seasonal/summer.csv 4 2

</code></pre></div></div>

<p>#### 
<strong>scripts with 2 or more lines</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ cat range.sh
wc -l $@ | grep -v total | sort -n | head -n 1
wc -l $@ | grep -v total | sort -nr | head -n 1
$ bash range.sh seasonal/*.csv &gt; range.out
$ head range.out
  21 seasonal/autumn.csv
  26 seasonal/winter.csv

</code></pre></div></div>

<p>#### 
<strong>scripts with loops</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
$ cat date-range.sh
# Print the first and last date from each data file.
for filename in $@
do
    cut -d , -f 1 $filename | grep -v Date | sort | head -n 1
    cut -d , -f 1 $filename | grep -v Date | sort | tail -n 1
done

$ bash date-range.sh seasonal/*.csv
2017-01-05
2017-08-16
2017-01-25
...

$ bash date-range.sh seasonal/*.csv | sort
2017-01-03
2017-01-05
2017-01-11
...

</code></pre></div></div>

<p>The End.</p>

<p>Thank you for reading.</p>

