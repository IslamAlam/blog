<h1 id="statistical-thinking-in-python-part-2">Statistical Thinking in Python (Part 2)</h1>

<h2 id="parameter-estimation-by-optimization">Parameter estimation by optimization</h2>

<p>###
 Optimal parameters</p>

<p>####
 How often do we get no-hitters?</p>

<p>The number of games played between each no-hitter in the modern era (1901-2015) of Major League Baseball is stored in the array
 <code class="language-plaintext highlighter-rouge">nohitter_times</code>
 .</p>

<p>If you assume that no-hitters are described as a Poisson process, then the time between no-hitters is Exponentially distributed. As you have seen, the Exponential distribution has a single parameter, which we will call ττ, the typical interval time. The value of the parameter ττ that makes the exponential distribution best match the data is the mean interval time (where time is in units of number of games) between no-hitters.</p>

<p>Compute the value of this parameter from the data. Then, use
 <code class="language-plaintext highlighter-rouge">np.random.exponential()</code>
 to “repeat” the history of Major League Baseball by drawing inter-no-hitter times from an exponential distribution with the ττ you found and plot the histogram as an approximation to the PDF.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Seed random number generator
</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Compute mean no-hitter time: tau
</span><span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">)</span>

<span class="c1"># Draw out of an exponential distribution with parameter tau: inter_nohitter_time
</span><span class="n">inter_nohitter_time</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

<span class="c1"># Plot the PDF and label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">inter_nohitter_time</span><span class="p">,</span>
             <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s">'step'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture-16.png" alt="Desktop View" /></p>

<p>We see the typical shape of the Exponential distribution, going from a maximum at 0 and decaying to the right.</p>

<p>####
 Do the data follow our story?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create an ECDF from real data: x, y
</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">)</span>

<span class="c1"># Create a CDF from theoretical samples: x_theor, y_theor
</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">inter_nohitter_time</span><span class="p">)</span>

<span class="c1"># Overlay the plots
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Margins and axis labels
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'CDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-15.png" alt="Desktop View" /></p>

<p>It looks like no-hitters in the modern era of Major League Baseball are Exponentially distributed. Based on the story of the Exponential distribution, this suggests that they are a random process; when a no-hitter will happen is independent of when the last no-hitter was.</p>

<p>####
 How is this parameter optimal?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the theoretical CDFs
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'CDF'</span><span class="p">)</span>

<span class="c1"># Take samples with half tau: samples_half
</span><span class="n">samples_half</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Take samples with double tau: samples_double
</span><span class="n">samples_double</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Generate CDFs from these samples
</span><span class="n">x_half</span><span class="p">,</span> <span class="n">y_half</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">samples_half</span><span class="p">)</span>
<span class="n">x_double</span><span class="p">,</span> <span class="n">y_double</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">samples_double</span><span class="p">)</span>

<span class="c1"># Plot these CDFs as lines
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_half</span><span class="p">,</span> <span class="n">y_half</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_double</span><span class="p">,</span> <span class="n">y_double</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-14.png" alt="Desktop View" /></p>

<p>red = half, purple = double</p>

<p>Notice how the value of tau given by the mean matches the data best. In this way, tau is an optimal parameter.</p>

<p>###
 Linear regression by least squares</p>

<p>####
 EDA of literacy/fertility data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the illiteracy rate versus fertility
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set the margins and label axes
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'percent illiterate'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Show the Pearson correlation coefficient
</span><span class="k">print</span><span class="p">(</span><span class="n">pearson_r</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">))</span>
<span class="mf">0.8041324026815344</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-13.png" alt="Desktop View" /></p>

<p>You can see the correlation between illiteracy and fertility by eye, and by the substantial Pearson correlation coefficient of 0.8. It is difficult to resolve in the scatter plot, but there are many points around near-zero illiteracy and about 1.8 children/woman.</p>

<p>####
 Linear regression</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the illiteracy rate versus fertility
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'percent illiterate'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>

<span class="c1"># Perform a linear regression using np.polyfit(): a, b
</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the results to the screen
</span><span class="k">print</span><span class="p">(</span><span class="s">'slope ='</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s">'children per woman / percent illiterate'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'intercept ='</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">'children per woman'</span><span class="p">)</span>

<span class="c1"># Make theoretical line to plot
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Add regression line to your plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Draw the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1"># slope = 0.04979854809063423 children per woman / percent illiterate
# intercept = 1.888050610636557 children per woman
</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture4-13.png" alt="Desktop View" /></p>

<p>####
 How is it optimal?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Specify slopes to consider: a_vals
</span><span class="n">a_vals</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="c1"># Initialize sum of square of residuals: rss
</span><span class="n">rss</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a_vals</span><span class="p">)</span>

<span class="c1"># Compute sum of square of residuals for each value of a_vals
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_vals</span><span class="p">):</span>
    <span class="n">rss</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">((</span><span class="n">fertility</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">illiteracy</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Plot the RSS
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">a_vals</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="s">'-'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'slope (children per woman / percent illiterate)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'sum of square of residuals'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture5-11.png" alt="Desktop View" /></p>

<p>Notice that the minimum on the plot, that is the value of the slope that gives the minimum sum of the square of the residuals, is the same value you got when performing the regression.</p>

<p>###
 The importance of EDA: Anscombe’s quartet</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture6-8.png" alt="Desktop View" /></p>

<p>####
 The importance of EDA</p>

<p>Why should exploratory data analysis be the first step in an analysis of data (after getting your data imported and cleaned, of course)?</p>

<ul>
  <li>You can be protected from misinterpretation of the type demonstrated by Anscombe’s quartet.</li>
  <li>EDA provides a good starting point for planning the rest of your analysis.</li>
  <li>EDA is not really any more difficult than any of the subsequent analysis, so there is no excuse for not exploring the data.</li>
</ul>

<p>####
 Linear regression on appropriate Anscombe data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Perform linear regression: a, b
</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the slope and intercept
</span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># Generate theoretical x and y data: x_theor, y_theor
</span><span class="n">x_theor</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
<span class="n">y_theor</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x_theor</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Plot the Anscombe data and theoretical line
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span> <span class="o">=</span> <span class="s">'none'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>

<span class="c1"># Label the axes
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture7-9.png" alt="Desktop View" /></p>

<p>####
 Linear regression on all Anscombe data</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for i in range(4):
    plt.subplot(2,2,i+1)

    # plot the scatter plot
    plt.plot(anscombe_x[i], anscombe_y[i], marker = '.', linestyle = 'none')

    # plot the regression line
    a, b = np.polyfit(anscombe_x[i], anscombe_y[i], deg=1)
    x_theor = np.array([np.min(anscombe_x[i]), np.max(anscombe_x[i])])
    y_theor = a * x_theor + b
    plt.plot(x_theor, y_theor)

    # add label
    plt.xlabel('x' + str(i+1))
    plt.ylabel('y' + str(i+1))

plt.show()

# slope1: 0.5000909090909095 intercept: 3.000090909090909
# slope2: 0.5000000000000004 intercept: 3.0009090909090896
# slope3: 0.4997272727272731 intercept: 3.0024545454545453
# slope4: 0.4999090909090908 intercept: 3.0017272727272735

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture8-6.png" alt="Desktop View" /></p>

<p>###
 Generating bootstrap replicates</p>

<p>####
 Getting the terminology down</p>

<p>If we have a data set with n repeated measurements, a
 <strong>bootstrap sample</strong>
 is an array of length n that was drawn from the original data with replacement.</p>

<p><strong>Bootstrap replicate</strong>
 is a single value of a statistic computed from a bootstrap sample.</p>

<p>####
 Visualizing bootstrap samples</p>

<p>np.random.choice()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for _ in range(50):
    # Generate bootstrap sample: bs_sample
    bs_sample = np.random.choice(rainfall, size=len(rainfall))

    # Compute and plot ECDF from bootstrap sample
    x, y = ecdf(bs_sample)
    _ = plt.plot(x, y, marker='.', linestyle='none',
                 color='gray', alpha=0.1)

# Compute and plot ECDF from original data
x, y = ecdf(rainfall)
_ = plt.plot(x, y, marker='.')

# Make margins and label axes
plt.margins(0.02)
_ = plt.xlabel('yearly rainfall (mm)')
_ = plt.ylabel('ECDF')

# Show the plot
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture9-5.png" alt="Desktop View" /></p>

<h2 id="bootstrap-confidence-intervals">Bootstrap confidence intervals</h2>

<p>####
 Generating many bootstrap replicates</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def bootstrap_replicate_1d(data, func):
    return func(np.random.choice(data, size=len(data)))

def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates

</code></pre></div></div>

<p>####
 Bootstrap replicates of the mean and the SEM (
 <strong>standard error of the mean</strong>
 )</p>

<p>In fact, it can be shown theoretically that under not-too-restrictive conditions, the value of the mean will always be Normally distributed. (This does not hold in general, just for the mean and a few other statistics.)</p>

<p>The standard deviation of this distribution, called the
 <strong>standard error of the mean</strong>
 , or SEM, is given by the standard deviation of the data divided by the square root of the number of data points. I.e., for a data set,
 <code class="language-plaintext highlighter-rouge">sem = np.std(data) / np.sqrt(len(data))</code>
 . Using hacker statistics, you get this same result without the need to derive it, but you will verify this result from your bootstrap replicates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Take 10,000 bootstrap replicates of the mean: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">rainfall</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute and print SEM
</span><span class="n">sem</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">rainfall</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rainfall</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">sem</span><span class="p">)</span>

<span class="c1"># Compute and print standard deviation of bootstrap replicates
</span><span class="n">bs_std</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bs_std</span><span class="p">)</span>

<span class="c1"># Make a histogram of the results
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'mean annual rainfall (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 10.51054915050619
# 10.465927071184412
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture10-5.png" alt="Desktop View" /></p>

<p>####
 Confidence intervals of rainfall data</p>

<p>Use the bootstrap replicates you just generated to compute the 95% confidence interval. That is, give the 2.5th and 97.5th percentile of your bootstrap replicates stored as
 <code class="language-plaintext highlighter-rouge">bs_replicates</code>
 . What is the 95% confidence interval?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
np.percentile(bs_replicates,2.5)
779.7699248120301

np.percentile(bs_replicates,97.5)
820.950432330827

</code></pre></div></div>

<p>####
 Bootstrap replicates of other statistics</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_reps(data, func, size=1):
    return np.array([bootstrap_replicate_1d(data, func) for _ in range(size)])

# Generate 10,000 bootstrap replicates of the variance: bs_replicates
bs_replicates = draw_bs_reps(rainfall, np.var, size=10000)

# Put the variance in units of square centimeters
bs_replicates /= 100

# Make a histogram of the results
_ = plt.hist(bs_replicates, bins=50, normed=True)
_ = plt.xlabel('variance of annual rainfall (sq. cm)')
_ = plt.ylabel('PDF')

# Show the plot
plt.show()


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture11-5.png" alt="Desktop View" /></p>

<p>This is not normally distributed, as it has a longer tail to the right. Note that you can also compute a confidence interval on the variance, or any other statistic, using
 <code class="language-plaintext highlighter-rouge">np.percentile()</code>
 with your bootstrap replicates.</p>

<p>####
 Confidence interval on the rate of no-hitters</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Draw bootstrap replicates of the mean no-hitter time (equal to tau): bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute the 95% confidence interval: conf_int
</span><span class="n">conf_int</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">])</span>

<span class="c1"># Print the confidence interval
</span><span class="k">print</span><span class="p">(</span><span class="s">'95% confidence interval ='</span><span class="p">,</span> <span class="n">conf_int</span><span class="p">,</span> <span class="s">'games'</span><span class="p">)</span>

<span class="c1"># Plot the histogram of the replicates
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s">'$\tau$ (games)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 95% confidence interval = [660.67280876 871.63077689] games
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture12-4.png" alt="Desktop View" /></p>

<p>This gives you an estimate of what the typical time between no-hitters is. It could be anywhere between 660 and 870 games.</p>

<p>###
 Pairs bootstrap</p>

<p>####
 A function to do pairs bootstrap</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, deg=1)

    return bs_slope_reps, bs_intercept_reps


</code></pre></div></div>

<p>####
 Pairs bootstrap of literacy/fertility data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Generate replicates of slope and intercept using pairs bootstrap
</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="n">bs_intercept_reps</span> <span class="o">=</span> <span class="n">draw_bs_pairs_linreg</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Compute and print 95% CI for slope
</span><span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">]))</span>

<span class="c1"># Plot the histogram
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'slope'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># [0.04378061 0.0551616 ]
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture13-4.png" alt="Desktop View" /></p>

<p>####
 Plotting bootstrap regressions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Generate array of x-values for bootstrap lines: x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>

<span class="c1"># Plot the bootstrap lines
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                 <span class="n">bs_slope_reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

<span class="c1"># Plot the data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Label axes, set the margins, and show the plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'illiteracy'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture14-3.png" alt="Desktop View" /></p>

<h2 id="introduction-to-hypothesis-testing">Introduction to hypothesis testing</h2>

<p>###
 Formulating and simulating a hypothesis</p>

<dl>
  <dt><strong>Null hypothesis</strong></dt>
  <dd>another name for the hypothesis you are testing</dd>
  <dt><strong>Permutation</strong></dt>
  <dd>random reordering of entries in an array</dd>
</dl>

<p>####
 Generating a permutation sample</p>

<p>np.random.permutation()</p>

<p>Permutation sampling is a great way to simulate the hypothesis that two variables have identical probability distributions. This is often a hypothesis you want to test, so in this exercise, you will write a function to generate a permutation sample from two data sets.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def permutation_sample(data1, data2):
    """Generate a permutation sample from two data sets."""

    # Concatenate the data sets: data
    data = np.concatenate((data1, data2))

    # Permute the concatenated array: permuted_data
    permuted_data = np.random.permutation(data)

    # Split the permuted array into two: perm_sample_1, perm_sample_2
    perm_sample_1 = permuted_data[:len(data1)]
    perm_sample_2 = permuted_data[len(data1):]

    return perm_sample_1, perm_sample_2

</code></pre></div></div>

<p>####
 Visualizing permutation sampling</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for _ in range(50):
    # Generate permutation samples
    perm_sample_1, perm_sample_2 = permutation_sample(rain_june, rain_november)


    # Compute ECDFs
    x_1, y_1 = ecdf(perm_sample_1)
    x_2, y_2 = ecdf(perm_sample_2)

    # Plot ECDFs of permutation sample
    _ = plt.plot(x_1, y_1, marker='.', linestyle='none',
                 color='red', alpha=0.02)
    _ = plt.plot(x_2, y_2, marker='.', linestyle='none',
                 color='blue', alpha=0.02)

# Create and plot ECDFs from original data
x_1, y_1 = ecdf(rain_june)
x_2, y_2 = ecdf(rain_november)
_ = plt.plot(x_1, y_1, marker='.', linestyle='none', color='red')
_ = plt.plot(x_2, y_2, marker='.', linestyle='none', color='blue')

# Label axes, set margin, and show plot
plt.margins(0.02)
_ = plt.xlabel('monthly rainfall (mm)')
_ = plt.ylabel('ECDF')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-16.png" alt="Desktop View" /></p>

<p>Notice that the permutation samples ECDFs overlap and give a purple haze. None of the ECDFs from the permutation samples overlap with the observed data, suggesting that the hypothesis is not commensurate with the data. June and November rainfall are not identically distributed.</p>

<p>###
 Test statistics and p-values</p>

<p>####
 Test statistics</p>

<p>When performing hypothesis tests, your choice of test statistic should be pertinent to the question you are seeking to answer in your hypothesis test.</p>

<p>The most important thing to consider is:
 <strong>What are you asking?</strong></p>

<p>####
 What is a p-value?</p>

<p>The p-value is generally a measure of the probability of observing a test statistic equally or more extreme than the one you observed, given that the null hypothesis is true.</p>

<p>####
 Generating permutation replicates</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># In most circumstances, func will be a function you write yourself.
</span><span class="k">def</span> <span class="nf">draw_perm_reps</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s">"""Generate multiple permutation replicates."""</span>

    <span class="c1"># Initialize array of replicates: perm_replicates
</span>    <span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="c1"># Generate permutation sample
</span>        <span class="n">perm_sample_1</span><span class="p">,</span> <span class="n">perm_sample_2</span> <span class="o">=</span> <span class="n">permutation_sample</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">)</span>

        <span class="c1"># Compute the test statistic
</span>        <span class="n">perm_replicates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">perm_sample_1</span><span class="p">,</span> <span class="n">perm_sample_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">perm_replicates</span>

</code></pre></div></div>

<p>####
 Look before you leap: EDA before hypothesis testing</p>

<p>Kleinteich and Gorb (
 <em>Sci. Rep.</em>
 ,
 <strong>4</strong>
 , 5225, 2014) performed an interesting experiment with South American horned frogs. They held a plate connected to a force transducer, along with a bait fly, in front of them. They then measured the impact force and adhesive force of the frog’s tongue when it struck the target.</p>

<p>Frog A is an adult and Frog B is a juvenile. The researchers measured the impact force of 20 strikes for each frog. In the next exercise, we will test the hypothesis that the two frogs have the same distribution of impact forces. But, remember, it is important to do EDA first! Let’s make a bee swarm plot for the data. They are stored in a Pandas data frame,
 <code class="language-plaintext highlighter-rouge">df</code>
 , where column
 <code class="language-plaintext highlighter-rouge">ID</code>
 is the identity of the frog and column
 <code class="language-plaintext highlighter-rouge">impact_force</code>
 is the impact force in Newtons (N).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   ID  impact_force
20  A         1.612
21  A         0.605
22  A         0.327
23  A         0.946
24  A         0.541

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make bee swarm plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">sns</span><span class="p">.</span><span class="n">swarmplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s">'ID'</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s">'impact_force'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'frog'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'impact force (N)'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-15.png" alt="Desktop View" /></p>

<p>Eyeballing it, it does not look like they come from the same distribution. Frog A, the adult, has three or four very hard strikes, and Frog B, the juvenile, has a couple weak ones. However, it is possible that with only 20 samples it might be too difficult to tell if they have difference distributions, so we should proceed with the hypothesis test.</p>

<p>####
 Permutation test on frog data</p>

<p>The average strike force of Frog A was 0.71 Newtons (N), and that of Frog B was 0.42 N for a difference of 0.29 N. It is possible the frogs strike with the same force and this observed difference was by chance. You will compute the probability of getting at least a 0.29 N difference in mean strike force under the hypothesis that the distributions of strike forces for the two frogs are identical. We use a permutation test with a test statistic of the difference of means to test this hypothesis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def diff_of_means(data_1, data_2):
    """Difference in means of two arrays."""

    # The difference of means of data_1, data_2: diff
    diff = np.mean(data_1) - np.mean(data_2)

    return diff

# Compute difference of mean impact force from experiment: empirical_diff_means
empirical_diff_means = diff_of_means(force_a, force_b)

# Draw 10,000 permutation replicates: perm_replicates
perm_replicates = draw_perm_reps(force_a, force_b,
                                 diff_of_means, size=10000)

# Compute p-value: p
p = np.sum(perm_replicates &gt;= empirical_diff_means) / len(perm_replicates)

# Print the result
print('p-value =', p)

# p-value = 0.0063
# p-value = 0.63%

</code></pre></div></div>

<p>The p-value tells you that there is about a 0.6% chance that you would get the difference of means observed in the experiment if frogs were exactly the same.</p>

<p>A p-value below 0.01 is typically said to be “statistically significant,” but: warning! warning! warning! You have computed a p-value; it is a number. I encourage you not to distill it to a yes-or-no phrase. p = 0.006 and p = 0.000000006 are both said to be “statistically significant,” but they are definitely not the same!</p>

<p>###
 Bootstrap hypothesis tests</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-14.png" alt="Desktop View" /></p>

<p>####
 A one-sample bootstrap hypothesis test</p>

<p>Another juvenile frog was studied, Frog C, and you want to see if Frog B and Frog C have similar impact forces. Unfortunately, you do not have Frog C’s impact forces available, but you know they have a mean of 0.55 N. Because you don’t have the original data, you cannot do a permutation test, and you cannot assess the hypothesis that the forces from Frog B and Frog C come from the same distribution. You will therefore test another, less restrictive hypothesis: The mean strike force of Frog B is equal to that of Frog C.</p>

<p>To set up the bootstrap hypothesis test, you will take the mean as our test statistic. Remember, your goal is to calculate the probability of getting a mean impact force less than or equal to what was observed for Frog B
 <em>if the hypothesis that the true mean of Frog B’s impact forces is equal to that of Frog C is true</em>
 . You first translate all of the data of Frog B such that the mean is 0.55 N. This involves adding the mean force of Frog C and subtracting the mean force of Frog B from each measurement of Frog B. This leaves other properties of Frog B’s distribution, such as the variance, unchanged.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make an array of translated impact forces: translated_force_b
</span><span class="n">translated_force_b</span> <span class="o">=</span> <span class="n">force_b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.55</span>

<span class="c1"># Take bootstrap replicates of Frog B's translated impact forces: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">translated_force_b</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute fraction of replicates that are less than the observed Frog B force: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_replicates</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10000</span>

<span class="c1"># Print the p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p = '</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p =  0.0046
# p = 0.46%
</span>
</code></pre></div></div>

<p>The low p-value suggests that the null hypothesis that Frog B and Frog C have the same mean impact force is false.</p>

<p>####
 A two-sample bootstrap hypothesis test for difference of means</p>

<p>We now want to test the hypothesis that Frog A and Frog B have the same mean impact force, but not necessarily the same distribution, which is also impossible with a permutation test.</p>

<p>To do the two-sample bootstrap test, we shift
 <em>both</em>
 arrays to have the same mean, since we are simulating the hypothesis that their means are, in fact, equal. We then draw bootstrap samples out of the shifted arrays and compute the difference in means. This constitutes a bootstrap replicate, and we generate many of them. The p-value is the fraction of replicates with a difference in means greater than or equal to what was observed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute mean of all forces: mean_force
</span><span class="n">mean_force</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">forces_concat</span><span class="p">)</span>

<span class="c1"># Generate shifted arrays
</span><span class="n">force_a_shifted</span> <span class="o">=</span> <span class="n">force_a</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_force</span>
<span class="n">force_b_shifted</span> <span class="o">=</span> <span class="n">force_b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_force</span>

<span class="c1"># Compute 10,000 bootstrap replicates from shifted arrays
</span><span class="n">bs_replicates_a</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">force_a_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_b</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">force_b_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Get replicates of difference of means: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">bs_replicates_a</span> <span class="o">-</span> <span class="n">bs_replicates_b</span>

<span class="c1"># Compute and print p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_replicates</span> <span class="o">&gt;=</span> <span class="n">empirical_diff_means</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="k">print</span><span class="p">(</span><span class="s">'p-value ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-value = 0.0043
# p-value = 0.43%
</span>
</code></pre></div></div>

<p>You got a similar result as when you did the permutation test. Nonetheless, remember that it is important to carefully think about what question you want to ask. Are you only interested in the mean impact force, or in the distribution of impact forces?</p>

<h2 id="hypothesis-test-examples">Hypothesis test examples</h2>

<p>###
 A/B testing</p>

<p>####
 The vote for the Civil Rights Act in 1964</p>

<p>The Civil Rights Act of 1964 was one of the most important pieces of legislation ever passed in the USA. Excluding “present” and “abstain” votes, 153 House Democrats and 136 Republicans voted yea. However, 91 Democrats and 35 Republicans voted nay. Did party affiliation make a difference in the vote?</p>

<p>To answer this question, you will evaluate the hypothesis that the party of a House member has no bearing on his or her vote. You will use the fraction of Democrats voting in favor as your test statistic and evaluate the probability of observing a fraction of Democrats voting in favor at least as small as the observed fraction of 153/244. (That’s right, at least as
 <em>small</em>
 as. In 1964, it was the
 <em>Democrats</em>
 who were less progressive on civil rights issues.) To do this, permute the party labels of the House voters and then arbitrarily divide them into “Democrats” and “Republicans” and compute the fraction of Democrats voting yea.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Construct arrays of data: dems, reps
</span><span class="n">dems</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">153</span> <span class="o">+</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">91</span><span class="p">)</span>
<span class="n">reps</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">136</span> <span class="o">+</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">35</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">frac_yea_dems</span><span class="p">(</span><span class="n">dems</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
    <span class="s">"""Compute fraction of Democrat yea votes."""</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">dems</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dems</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">frac</span>

<span class="c1"># Acquire permutation samples: perm_replicates
</span><span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">draw_perm_reps</span><span class="p">(</span><span class="n">dems</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">frac_yea_dems</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute and print p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">perm_replicates</span> <span class="o">&lt;=</span> <span class="mi">153</span><span class="o">/</span><span class="mi">244</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm_replicates</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'p-value ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-value = 0.0002
# p-value = 0.02%
</span>
</code></pre></div></div>

<p>This small p-value suggests that party identity had a lot to do with the voting. Importantly, the South had a higher fraction of Democrat representatives, and consequently also a more racist bias.</p>

<p>####
 What is equivalent?</p>

<p>You have experience matching a stories to probability distributions. Similarly, you use the same procedure for two different A/B tests if their stories match. In the Civil Rights Act example you just did, you performed an A/B test on voting data, which has a Yes/No type of outcome for each subject (in that case, a voter). Which of the following situations involving testing by a web-based company has an equivalent set up for an A/B test as the one you just did with the Civil Rights Act of 1964?</p>

<p>You measure the number of people who click on an ad on your company’s website before and after changing its color.</p>

<p>The “Democrats” are those who view the ad before the color change, and the “Republicans” are those who view it after.</p>

<p>####
 A time-on-website analog</p>

<p>It turns out that you already did a hypothesis test analogous to an A/B test where you are interested in how much time is spent on the website before and after an ad campaign. The frog tongue force (a continuous quantity like time on the website) is an analog. “Before” = Frog A and “after” = Frog B. Let’s practice this again with something that actually is a before/after scenario.</p>

<p>We return to the no-hitter data set. In 1920, Major League Baseball implemented important rule changes that ended the so-called dead ball era. Importantly, the pitcher was no longer allowed to spit on or scuff the ball, an activity that greatly favors pitchers. In this problem you will perform an A/B test to determine if these rule changes resulted in a slower rate of no-hitters (i.e., longer average time between no-hitters) using the difference in mean inter-no-hitter time as your test statistic. The inter-no-hitter times for the respective eras are stored in the arrays
 <code class="language-plaintext highlighter-rouge">nht_dead</code>
 and
 <code class="language-plaintext highlighter-rouge">nht_live</code>
 , where “nht” is meant to stand for “no-hitter time.”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def diff_of_means(data_1, data_2):
    """Difference in means of two arrays."""

    # The difference of means of data_1, data_2: diff
    diff = np.mean(data_1) - np.mean(data_2)

    return diff

def permutation_sample(data1, data2):
    """Generate a permutation sample from two data sets."""

    # Concatenate the data sets: data
    data = np.concatenate((data1, data2))

    # Permute the concatenated array: permuted_data
    permuted_data = np.random.permutation(data)

    # Split the permuted array into two: perm_sample_1, perm_sample_2
    perm_sample_1 = permuted_data[:len(data1)]
    perm_sample_2 = permuted_data[len(data1):]

    return perm_sample_1, perm_sample_2

def draw_perm_reps(data_1, data_2, func, size=1):
    """Generate multiple permutation replicates."""

    # Initialize array of replicates: perm_replicates
    perm_replicates = np.empty(size)

    for i in range(size):
        # Generate permutation sample
        perm_sample_1, perm_sample_2 = permutation_sample(data_1, data_2)

        # Compute the test statistic
        perm_replicates[i] = func(perm_sample_1, perm_sample_2)

    return perm_replicates



# Compute the observed difference in mean inter-no-hitter times: nht_diff_obs
nht_diff_obs = diff_of_means(nht_dead, nht_live)

# Acquire 10,000 permutation replicates of difference in mean no-hitter time: perm_replicates
perm_replicates = draw_perm_reps(nht_dead, nht_live, diff_of_means, size=10000)

# Compute and print the p-value: p
p = np.sum(perm_replicates &lt;= nht_diff_obs) /len(perm_replicates)
print('p-val =', p)

p-val = 0.0001

</code></pre></div></div>

<p>Your p-value is 0.0001, which means that only one out of your 10,000 replicates had a result as extreme as the actual difference between the dead ball and live ball eras. This suggests strong statistical significance. Watch out, though, you could very well have gotten zero replicates that were as extreme as the observed value. This just means that the p-value is quite small, almost certainly smaller than 0.001.</p>

<p>####
 What should you have done first?</p>

<p>That was a nice hypothesis test you just did to check out whether the rule changes in 1920 changed the rate of no-hitters. But what
 <em>should</em>
 you have done with the data first?</p>

<p>Performed EDA, perhaps plotting the ECDFs of inter-no-hitter times in the dead ball and live ball eras.</p>

<p>Always a good idea to do first! I encourage you to go ahead and plot the ECDFs right now. You will see by eye that the null hypothesis that the distributions are the same is almost certainly not true.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create and plot ECDFs
</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nht_dead</span><span class="p">)</span>
<span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nht_live</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>

<span class="c1"># Label axes, set margin, and show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-17.png" alt="Desktop View" /></p>

<p>###
 Test of correlation</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-16.png" alt="Desktop View" /></p>

<p>####
 Simulating a null hypothesis concerning correlation</p>

<p>The observed correlation between female illiteracy and fertility in the data set of 162 countries may just be by chance; the fertility of a given country may actually be totally independent of its illiteracy. You will test this null hypothesis in the next exercise.</p>

<p>To do the test, you need to simulate the data assuming the null hypothesis is true. Of the following choices, which is the best way to to do it?</p>

<p>Answer: Do a permutation test: Permute the illiteracy values but leave the fertility values fixed to generate a new set of (illiteracy, fertility) data.</p>

<p>This exactly simulates the null hypothesis and does so more efficiently than the last option. It is exact because it uses all data and eliminates any correlation because which illiteracy value pairs to which fertility value is shuffled.</p>

<p>Last option: Do a permutation test: Permute both the illiteracy and fertility values to generate a new set of (illiteracy, fertility data). This exactly simulates the null hypothesis and does so more efficiently than the last option. It is exact because it uses all data and eliminates any correlation because which illiteracy value pairs to which fertility value is shuffled.</p>

<p>####
 Hypothesis test on Pearson correlation</p>

<p>The observed correlation between female illiteracy and fertility may just be by chance; the fertility of a given country may actually be totally independent of its illiteracy. You will test this hypothesis. To do so, permute the illiteracy values but leave the fertility values fixed. This simulates the hypothesis that they are totally independent of each other. For each permutation, compute the Pearson correlation coefficient and assess how many of your permutation replicates have a Pearson correlation coefficient greater than the observed one.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def pearson_r(x, y):
    """Compute Pearson correlation coefficient between two arrays."""
    # Compute correlation matrix: corr_mat
    corr_mat = np.corrcoef(x, y)

    # Return entry [0,1]
    return corr_mat[0,1]

# Compute observed correlation: r_obs
r_obs = pearson_r(illiteracy, fertility)

# r_obs = 0.8041324026815344

# Initialize permutation replicates: perm_replicates
perm_replicates = np.empty(10000)

# Draw replicates
for i in range(10000):
    # Permute illiteracy measurments: illiteracy_permuted
    illiteracy_permuted = np.random.permutation(illiteracy)

    # Compute Pearson correlation
    perm_replicates[i] = pearson_r(illiteracy_permuted, fertility)

# Compute p-value: p
p = np.sum(perm_replicates &gt;= r_obs) /len(perm_replicates)
print('p-val =', p)

# p-val = 0.0

</code></pre></div></div>

<p>You got a p-value of zero. In hacker statistics, this means that your p-value is very low, since you never got a single replicate in the 10,000 you took that had a Pearson correlation greater than the observed one. You could try increasing the number of replicates you take to continue to move the upper bound on your p-value lower and lower.</p>

<p>####
 Do neonicotinoid insecticides have unintended consequences?</p>

<p>As a final exercise in hypothesis testing before we put everything together in our case study in the next chapter, you will investigate the effects of neonicotinoid insecticides on bee reproduction. These insecticides are very widely used in the United States to combat aphids and other pests that damage plants.</p>

<p>In a recent study, Straub, et al. (
 <a href="http://dx.doi.org/10.1098/rspb.2016.0506"><em>Proc. Roy. Soc. B</em>
 , 2016</a>
 ) investigated the effects of neonicotinoids on the sperm of pollinating bees. In this and the next exercise, you will study how the pesticide treatment affected the count of live sperm per half milliliter of semen.</p>

<p>First, we will do EDA, as usual. Plot ECDFs of the alive sperm count for untreated bees (stored in the Numpy array
 <code class="language-plaintext highlighter-rouge">control</code>
 ) and bees treated with pesticide (stored in the Numpy array
 <code class="language-plaintext highlighter-rouge">treated</code>
 ).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute x,y values for ECDFs
</span><span class="n">x_control</span><span class="p">,</span> <span class="n">y_control</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">control</span><span class="p">)</span>
<span class="n">x_treated</span><span class="p">,</span> <span class="n">y_treated</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">treated</span><span class="p">)</span>

<span class="c1"># Plot the ECDFs
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_control</span><span class="p">,</span> <span class="n">y_control</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_treated</span><span class="p">,</span> <span class="n">y_treated</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set the margins
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>

<span class="c1"># Add a legend
</span><span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'control'</span><span class="p">,</span> <span class="s">'treated'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Label axes and show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'millions of alive sperm per mL'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-15.png" alt="Desktop View" /></p>

<p>The ECDFs show a pretty clear difference between the treatment and control; treated bees have fewer alive sperm. Let’s now do a hypothesis test in the next exercise.</p>

<p>####
 Bootstrap hypothesis test on bee sperm counts</p>

<p>Now, you will test the following hypothesis:</p>

<p><strong>On average, male bees treated with neonicotinoid insecticide have the same number of active sperm per milliliter of semen than do untreated male bees.</strong></p>

<p>You will use the difference of means as your test statistic.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def bootstrap_replicate_1d(data, func):
    return func(np.random.choice(data, size=len(data)))

def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates


# Compute the difference in mean sperm count: diff_means
diff_means = np.mean(control) - np.mean(treated)

# Compute mean of pooled data: mean_count
mean_count = np.mean(np.concatenate((control, treated)))

# Generate shifted data sets
control_shifted = control - np.mean(control) + mean_count
treated_shifted = treated - np.mean(treated) + mean_count

# Generate bootstrap replicates
bs_reps_control = draw_bs_reps(control_shifted,
                       np.mean, size=10000)
bs_reps_treated = draw_bs_reps(treated_shifted,
                       np.mean, size=10000)

# Get replicates of difference of means: bs_replicates
bs_replicates = bs_reps_control - bs_reps_treated

# Compute and print p-value: p
p = np.sum(bs_replicates &gt;= np.mean(control) - np.mean(treated)) \
            / len(bs_replicates)
print('p-value =', p)

# p-value = 0.0

</code></pre></div></div>

<p>The p-value is small, most likely less than 0.0001, since you never saw a bootstrap replicated with a difference of means at least as extreme as what was observed. In fact, when I did the calculation with 10 million replicates, I got a p-value of
 <code class="language-plaintext highlighter-rouge">2e-05</code></p>

<h2 id="putting-it-all-together-a-case-study">Putting it all together: a case study</h2>

<p>###
 Finch beaks and the need for statistics</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture4-14.png" alt="Desktop View" /></p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture5-12.png" alt="Desktop View" /></p>

<p>####
 EDA of beak depths of Darwin’s finches</p>

<p>For your first foray into the Darwin finch data, you will study how the beak depth (the distance, top to bottom, of a closed beak) of the finch species
 <em>Geospiza scandens</em>
 has changed over time. The Grants have noticed some changes of beak geometry depending on the types of seeds available on the island, and they also noticed that there was some interbreeding with another major species on Daphne Major,
 <em>Geospiza fortis</em>
 . These effects can lead to changes in the species over time.</p>

<p>In the next few problems, you will look at the beak depth of
 <em>G. scandens</em>
 on Daphne Major in 1975 and in 2012. To start with, let’s plot all of the beak depth measurements in 1975 and 2012 in a bee swarm plot.</p>

<p>The data are stored in a pandas DataFrame called
 <code class="language-plaintext highlighter-rouge">df</code>
 with columns
 <code class="language-plaintext highlighter-rouge">'year'</code>
 and
 <code class="language-plaintext highlighter-rouge">'beak_depth'</code>
 . The units of beak depth are millimeters (mm).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   beak_depth  year
0         8.4  1975
1         8.8  1975
2         8.4  1975
3         8.0  1975
4         7.9  1975

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create bee swarm plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">sns</span><span class="p">.</span><span class="n">swarmplot</span><span class="p">(</span><span class="s">'year'</span><span class="p">,</span> <span class="s">'beak_depth'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Label the axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'year'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture6-9.png" alt="Desktop View" /></p>

<p>It is kind of hard to see if there is a clear difference between the 1975 and 2012 data set. Eyeballing it, it appears as though the mean of the 2012 data set might be slightly higher, and it might have a bigger variance.</p>

<p>####
 ECDFs of beak depths</p>

<p>While bee swarm plots are useful, we found that ECDFs are often even better when doing EDA. Plot the ECDFs for the 1975 and 2012 beak depth measurements on the same plot.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute ECDFs
</span><span class="n">x_1975</span><span class="p">,</span> <span class="n">y_1975</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">bd_1975</span><span class="p">)</span>
<span class="n">x_2012</span><span class="p">,</span> <span class="n">y_2012</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">bd_2012</span><span class="p">)</span>

<span class="c1"># Plot the ECDFs
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1975</span><span class="p">,</span> <span class="n">y_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2012</span><span class="p">,</span> <span class="n">y_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set margins
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>

<span class="c1"># Add axis labels and legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture7-10.png" alt="Desktop View" /></p>

<p>The differences are much clearer in the ECDF. The mean is larger in the 2012 data, and the variance does appear larger as well.</p>

<p>####
 Parameter estimates of beak depths</p>

<p>Estimate the
 <em>difference</em>
 of the mean beak depth of the
 <em>G. scandens</em>
 samples from 1975 and 2012 and report a 95% confidence interval.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates


# Compute the difference of the sample means: mean_diff
mean_diff = np.mean(bd_2012) - np.mean(bd_1975)

# Get bootstrap replicates of means
bs_replicates_1975 = draw_bs_reps(bd_1975, np.mean, size=10000)
bs_replicates_2012 = draw_bs_reps(bd_2012, np.mean, size=10000)

# Compute samples of difference of means: bs_diff_replicates
bs_diff_replicates = bs_replicates_2012 - bs_replicates_1975

# Compute 95% confidence interval: conf_int
conf_int = np.percentile(bs_diff_replicates, [2.5, 97.5])

# Print the results
print('difference of means =', mean_diff, 'mm')
print('95% confidence interval =', conf_int, 'mm')

# difference of means = 0.22622047244094645 mm
# 95% confidence interval = [0.05633521 0.39190544] mm

</code></pre></div></div>

<p>####
 Hypothesis test: Are beaks deeper in 2012?</p>

<p>Your plot of the ECDF and determination of the confidence interval make it pretty clear that the beaks of
 <em>G. scandens</em>
 on Daphne Major have gotten deeper. But is it possible that this effect is just due to random chance? In other words, what is the probability that we would get the observed difference in mean beak depth if the means were the same?</p>

<p>Be careful! The hypothesis we are testing is
 <em>not</em>
 that the beak depths come from the same distribution. For that we could use a permutation test.
 <strong>The hypothesis is that the means are equal.</strong>
 To perform this hypothesis test, we need to shift the two data sets so that they have the same mean and then use bootstrap sampling to compute the difference of means.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute mean of combined data set: combined_mean
</span><span class="n">combined_mean</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">bd_1975</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">)))</span>

<span class="c1"># Shift the samples
# why shift the mean?
# to make np.mean(bd_1975_shifted) - np.mean(bd_2012_shifted) = 0 #1
# why make #1 = 0?
# because our hypothesis is "beak depth are the same in 1975 and 2012"
</span><span class="n">bd_1975_shifted</span> <span class="o">=</span> <span class="n">bd_1975</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bd_1975</span><span class="p">)</span> <span class="o">+</span> <span class="n">combined_mean</span>
<span class="n">bd_2012_shifted</span> <span class="o">=</span> <span class="n">bd_2012</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bd_2012</span><span class="p">)</span> <span class="o">+</span> <span class="n">combined_mean</span>

<span class="c1"># Get bootstrap replicates of shifted data sets
</span><span class="n">bs_replicates_1975</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">bd_1975_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_2012</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">bd_2012_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute replicates of difference of means: bs_diff_replicates
</span><span class="n">bs_diff_replicates</span> <span class="o">=</span> <span class="n">bs_replicates_2012</span> <span class="o">-</span> <span class="n">bs_replicates_1975</span>

<span class="c1"># Compute the p-value
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_diff_replicates</span> <span class="o">&gt;=</span> <span class="n">mean_diff</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs_diff_replicates</span><span class="p">)</span>

<span class="c1"># Print p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p = 0.0034
# p = 0.34%
</span>
</code></pre></div></div>

<p>We get a p-value of 0.0034, which suggests that there is a statistically significant difference. But remember: it is very important to know how different they are! In the previous exercise, you got a difference of 0.2 mm between the means. You should combine this with the statistical significance. Changing by 0.2 mm in 37 years is substantial by evolutionary standards. If it kept changing at that rate, the beak depth would double in only 400 years.</p>

<p>###
 Variation of beak shapes</p>

<p>####
 EDA of beak length and depth</p>

<p>The beak length data are stored as
 <code class="language-plaintext highlighter-rouge">bl_1975</code>
 and
 <code class="language-plaintext highlighter-rouge">bl_2012</code>
 , again with units of millimeters (mm). You still have the beak depth data stored in
 <code class="language-plaintext highlighter-rouge">bd_1975</code>
 and
 <code class="language-plaintext highlighter-rouge">bd_2012</code>
 . Make scatter plots of beak depth (y-axis) versus beak length (x-axis) for the 1975 and 2012 specimens.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plot of 1975 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_1975</span><span class="p">,</span> <span class="n">bd_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'None'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Make scatter plot of 2012 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_2012</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s">'None'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes and make legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak length (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture8-7.png" alt="Desktop View" /></p>

<p>In looking at the plot, we see that beaks got deeper (the red points are higher up in the y-direction), but not really longer. If anything, they got a bit shorter, since the red dots are to the left of the blue dots. So, it does not look like the beaks kept the same shape; they became shorter and deeper.</p>

<p>####
 Linear regressions</p>

<p>Perform a linear regression for both the 1975 and 2012 data. Then, perform pairs bootstrap estimates for the regression parameters. Report 95% confidence intervals on the slope and intercept of the regression line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, deg=1)

    return bs_slope_reps, bs_intercept_reps


# Compute the linear regressions
slope_1975, intercept_1975 = np.polyfit(bl_1975, bd_1975, deg=1)
slope_2012, intercept_2012 = np.polyfit(bl_2012, bd_2012, deg=1)

# Perform pairs bootstrap for the linear regressions
bs_slope_reps_1975, bs_intercept_reps_1975 = draw_bs_pairs_linreg(bl_1975, bd_1975, size=1000)
bs_slope_reps_2012, bs_intercept_reps_2012 = draw_bs_pairs_linreg(bl_2012, bd_2012, size=1000)

# Compute confidence intervals of slopes
slope_conf_int_1975 = np.percentile(bs_slope_reps_1975, [2.5, 97.5])
slope_conf_int_2012 = np.percentile(bs_slope_reps_2012, [2.5, 97.5])
intercept_conf_int_1975 = np.percentile(bs_intercept_reps_1975, [2.5, 97.5])
intercept_conf_int_2012 = np.percentile(bs_intercept_reps_2012, [2.5, 97.5])


# Print the results
print('1975: slope =', slope_1975,
      'conf int =', slope_conf_int_1975)
print('1975: intercept =', intercept_1975,
      'conf int =', intercept_conf_int_1975)
print('2012: slope =', slope_2012,
      'conf int =', slope_conf_int_2012)
print('2012: intercept =', intercept_2012,
      'conf int =', intercept_conf_int_2012)

#   1975: slope = 0.4652051691605937 conf int = [0.33851226 0.59306491]
#   1975: intercept = 2.3908752365842263 conf int = [0.64892945 4.18037063]
#   2012: slope = 0.462630358835313 conf int = [0.33137479 0.60695527]
#   2012: intercept = 2.977247498236019 conf int = [1.06792753 4.70599387]

</code></pre></div></div>

<p>It looks like they have the same slope, but different intercepts.</p>

<p>####
 Displaying the linear regression results</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plot of 1975 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_1975</span><span class="p">,</span> <span class="n">bd_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Make scatter plot of 2012 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_2012</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes and make legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak length (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>

<span class="c1"># Generate x-values for bootstrap lines: x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">17</span><span class="p">])</span>

<span class="c1"># Plot the bootstrap lines
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bs_slope_reps_1975</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps_1975</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bs_slope_reps_2012</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps_2012</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

<span class="c1"># Draw the plot again
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture9-6.png" alt="Desktop View" /></p>

<p>####
 Beak length to depth ratio</p>

<p>The linear regressions showed interesting information about the beak geometry. The slope was the same in 1975 and 2012, suggesting that for every millimeter gained in beak length, the birds gained about half a millimeter in depth in both years. However, if we are interested in the shape of the beak, we want to compare the
 <em>ratio</em>
 of beak length to beak depth. Let’s make that comparison.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute length-to-depth ratios
</span><span class="n">ratio_1975</span> <span class="o">=</span> <span class="n">bl_1975</span> <span class="o">/</span> <span class="n">bd_1975</span>
<span class="n">ratio_2012</span> <span class="o">=</span> <span class="n">bl_2012</span> <span class="o">/</span> <span class="n">bd_2012</span>

<span class="c1"># Compute means
</span><span class="n">mean_ratio_1975</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratio_1975</span><span class="p">)</span>
<span class="n">mean_ratio_2012</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratio_2012</span><span class="p">)</span>

<span class="c1"># Generate bootstrap replicates of the means
</span><span class="n">bs_replicates_1975</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">ratio_1975</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_2012</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">ratio_2012</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute the 99% confidence intervals
</span><span class="n">conf_int_1975</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates_1975</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">])</span>
<span class="n">conf_int_2012</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates_2012</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">])</span>

<span class="c1"># Print the results
</span><span class="k">print</span><span class="p">(</span><span class="s">'1975: mean ratio ='</span><span class="p">,</span> <span class="n">mean_ratio_1975</span><span class="p">,</span>
      <span class="s">'conf int ='</span><span class="p">,</span> <span class="n">conf_int_1975</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'2012: mean ratio ='</span><span class="p">,</span> <span class="n">mean_ratio_2012</span><span class="p">,</span>
      <span class="s">'conf int ='</span><span class="p">,</span> <span class="n">conf_int_2012</span><span class="p">)</span>

<span class="c1"># 1975: mean ratio = 1.5788823771858533 conf int = [1.55668803 1.60073509]
# 2012: mean ratio = 1.4658342276847767 conf int = [1.44363932 1.48729149]
</span>
</code></pre></div></div>

<p>####
 How different is the ratio?</p>

<p>In the previous exercise, you computed the mean beak length to depth ratio with 99% confidence intervals for 1975 and for 2012. The results of that calculation are shown graphically in the plot accompanying this problem. In addition to these results, what would you say about the ratio of beak length to depth?</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture10-6.png" alt="Desktop View" /></p>

<p>The mean beak length-to-depth ratio decreased by about 0.1, or 7%, from 1975 to 2012. The 99% confidence intervals are not even close to overlapping, so this is a real change. The beak shape changed.</p>

<p>###
 Calculation of heritability</p>

<p>####
 EDA of heritability</p>

<p>The array
 <code class="language-plaintext highlighter-rouge">bd_parent_scandens</code>
 contains the average beak depth (in mm) of two parents of the species
 <code class="language-plaintext highlighter-rouge">G. scandens</code>
 . The array
 <code class="language-plaintext highlighter-rouge">bd_offspring_scandens</code>
 contains the average beak depth of the offspring of the respective parents. The arrays
 <code class="language-plaintext highlighter-rouge">bd_parent_fortis</code>
 and
 <code class="language-plaintext highlighter-rouge">bd_offspring_fortis</code>
 contain the same information about measurements from
 <em>G. fortis</em>
 birds.</p>

<p>Make a scatter plot of the average offspring beak depth (y-axis) versus average parental beak depth (x-axis) for both species. Use the
 <code class="language-plaintext highlighter-rouge">alpha=0.5</code>
 keyword argument to help you see overlapping points.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plots
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bd_parent_fortis</span><span class="p">,</span> <span class="n">bd_offspring_fortis</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bd_parent_scandens</span><span class="p">,</span> <span class="n">bd_offspring_scandens</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'parental beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'offspring beak depth (mm)'</span><span class="p">)</span>

<span class="c1"># Add legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'G. fortis'</span><span class="p">,</span> <span class="s">'G. scandens'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture11-6.png" alt="Desktop View" /></p>

<p>It appears as though there is a stronger correlation in
 <em>G. fortis</em>
 than than in
 <em>G. scandens</em>
 . This suggests that beak depth is more strongly inherited in
 <em>G. fortis</em>
 . We’ll quantify this correlation next.</p>

<p>####
 Correlation of offspring and parental data</p>

<p>In an effort to quantify the correlation between offspring and parent beak depths, we would like to compute statistics, such as the Pearson correlation coefficient, between parents and offspring. To get confidence intervals on this, we need to do a pairs bootstrap.</p>

<p>You have
 <a href="https://campus.datacamp.com/courses/statistical-thinking-in-python-part-2/bootstrap-confidence-intervals?ex=12">already written</a>
 a function to do pairs bootstrap to get estimates for parameters derived from linear regression. Your task in this exercise is to make a new function with call signature
 <code class="language-plaintext highlighter-rouge">draw_bs_pairs(x, y, func, size=1)</code>
 that performs pairs bootstrap and computes a single statistic on pairs samples defined. The statistic of interest is computed by calling
 <code class="language-plaintext highlighter-rouge">func(bs_x, bs_y)</code>
 . In the next exercise, you will use
 <code class="language-plaintext highlighter-rouge">pearson_r</code>
 for
 <code class="language-plaintext highlighter-rouge">func</code>
 .</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs(x, y, func, size=1):
    """Perform pairs bootstrap for a single statistic."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_replicates[i] = func(bs_x, bs_y)

    return bs_replicates


</code></pre></div></div>

<p>####
 Pearson correlation of offspring and parental data</p>

<p>The Pearson correlation coefficient seems like a useful measure of how strongly the beak depth of parents are inherited by their offspring. Compute the Pearson correlation coefficient between parental and offspring beak depths for
 <em>G. scandens</em>
 . Do the same for
 <em>G. fortis</em>
 . Then, use the function you wrote in the last exercise to compute a 95% confidence interval using pairs bootstrap.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def pearson_r(x, y):
    """Compute Pearson correlation coefficient between two arrays."""
    # Compute correlation matrix: corr_mat
    corr_mat = np.corrcoef(x, y)

    # Return entry [0,1]
    return corr_mat[0,1]


# Compute the Pearson correlation coefficients
r_scandens = pearson_r(bd_parent_scandens, bd_offspring_scandens)
r_fortis = pearson_r(bd_parent_fortis, bd_offspring_fortis)

# Acquire 1000 bootstrap replicates of Pearson r
bs_replicates_scandens = draw_bs_pairs(bd_parent_scandens, bd_offspring_scandens, pearson_r, size=1000)

bs_replicates_fortis = draw_bs_pairs(bd_parent_fortis, bd_offspring_fortis, pearson_r, size=1000)


# Compute 95% confidence intervals
conf_int_scandens = np.percentile(bs_replicates_scandens, [2.5, 97.5])
conf_int_fortis = np.percentile(bs_replicates_fortis, [2.5, 97.5])

# Print results
print('G. scandens:', r_scandens, conf_int_scandens)
print('G. fortis:', r_fortis, conf_int_fortis)

#    G. scandens: 0.4117063629401258 [0.26564228 0.54388972]
#    G. fortis: 0.7283412395518487 [0.6694112  0.77840616]

</code></pre></div></div>

<p>It is clear from the confidence intervals that beak depth of the offspring of
 <em>G. fortis</em>
 parents is more strongly correlated with their offspring than their
 <em>G. scandens</em>
 counterparts.</p>

<p>####
 Measuring heritability</p>

<p>Remember that the Pearson correlation coefficient is the ratio of the covariance to the geometric mean of the variances of the two data sets. This is a measure of the correlation between parents and offspring, but might not be the best estimate of heritability. If we stop and think, it makes more sense to define heritability as the ratio of the covariance between parent and offspring to the
 <em>variance of the parents alone</em>
 . In this exercise, you will estimate the heritability and perform a pairs bootstrap calculation to get the 95% confidence interval.</p>

<p>This exercise highlights a very important point. Statistical inference (and data analysis in general) is not a plug-n-chug enterprise. You need to think carefully about the questions you are seeking to answer with your data and analyze them appropriately. If you are interested in how heritable traits are, the quantity we defined as the heritability is more apt than the off-the-shelf statistic, the Pearson correlation coefficient.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def heritability(parents, offspring):
    """Compute the heritability from parent and offspring samples."""
    covariance_matrix = np.cov(parents, offspring)
    return covariance_matrix[0,1] / covariance_matrix[0,0]

# Compute the heritability
heritability_scandens = heritability(bd_parent_scandens, bd_offspring_scandens)
heritability_fortis = heritability(bd_parent_fortis, bd_offspring_fortis)

# Acquire 1000 bootstrap replicates of heritability
replicates_scandens = draw_bs_pairs(
        bd_parent_scandens, bd_offspring_scandens, heritability, size=1000)

replicates_fortis = draw_bs_pairs(
        bd_parent_fortis, bd_offspring_fortis, heritability, size=1000)


# Compute 95% confidence intervals
conf_int_scandens = np.percentile(replicates_scandens, [2.5, 97.5])
conf_int_fortis = np.percentile(replicates_fortis, [2.5, 97.5])

# Print results
print('G. scandens:', heritability_scandens, conf_int_scandens)
print('G. fortis:', heritability_fortis, conf_int_fortis)


#   G. scandens: 0.5485340868685982 [0.34395487 0.75638267]
#   G. fortis: 0.7229051911438159 [0.64655013 0.79688342]

</code></pre></div></div>

<p>Here again, we see that
 <em>G. fortis</em>
 has stronger heritability than
 <em>G. scandens</em>
 . This suggests that the traits of
 <em>G. fortis</em>
 may be strongly incorporated into
 <em>G. scandens</em>
 by introgressive hybridization.</p>

<p>####
 Is beak depth heritable at all in G. scandens?</p>

<p>The heritability of beak depth in
 <em>G. scandens</em>
 seems low. It could be that this observed heritability was just achieved by chance and
 <strong>beak depth is actually not really heritable in the species</strong>
 . You will test that hypothesis here. To do this, you will do a pairs permutation test.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Initialize array of replicates: perm_replicates
</span><span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Draw replicates
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="c1"># Permute parent beak depths
</span>    <span class="n">bd_parent_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">bd_parent_scandens</span><span class="p">)</span>
    <span class="n">perm_replicates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">heritability</span><span class="p">(</span><span class="n">bd_parent_permuted</span><span class="p">,</span>
                                      <span class="n">bd_offspring_scandens</span><span class="p">)</span>

<span class="c1"># Compute p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">perm_replicates</span> <span class="o">&gt;=</span> <span class="n">heritability_scandens</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm_replicates</span><span class="p">)</span>

<span class="c1"># Print the p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p-val ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-val = 0.0
</span>
</code></pre></div></div>

<p>You get a p-value of zero, which means that none of the 10,000 permutation pairs replicates you drew had a heritability high enough to match that which was observed. This strongly suggests that beak depth is heritable in
 <em>G. scandens</em>
 , just not as much as in
 <em>G. fortis</em>
 . If you like, you can plot a histogram of the heritability replicates to get a feel for how extreme of a value of heritability you might expect by chance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.hist(perm_replicates)
plt.axvline(x=heritability_scandens, color = 'red')
plt.text(heritability_scandens, 1500, 'heritability_scandens', ha='center', va='center',rotation='vertical', backgroundcolor='white')
plt.show()

</code></pre></div></div>

<h2 id="parameter-estimation-by-optimization-1">Parameter estimation by optimization</h2>

<p>###
 Optimal parameters</p>

<p>####
 How often do we get no-hitters?</p>

<p>The number of games played between each no-hitter in the modern era (1901-2015) of Major League Baseball is stored in the array
 <code class="language-plaintext highlighter-rouge">nohitter_times</code>
 .</p>

<p>If you assume that no-hitters are described as a Poisson process, then the time between no-hitters is Exponentially distributed. As you have seen, the Exponential distribution has a single parameter, which we will call ττ, the typical interval time. The value of the parameter ττ that makes the exponential distribution best match the data is the mean interval time (where time is in units of number of games) between no-hitters.</p>

<p>Compute the value of this parameter from the data. Then, use
 <code class="language-plaintext highlighter-rouge">np.random.exponential()</code>
 to “repeat” the history of Major League Baseball by drawing inter-no-hitter times from an exponential distribution with the ττ you found and plot the histogram as an approximation to the PDF.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Seed random number generator
</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Compute mean no-hitter time: tau
</span><span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">)</span>

<span class="c1"># Draw out of an exponential distribution with parameter tau: inter_nohitter_time
</span><span class="n">inter_nohitter_time</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

<span class="c1"># Plot the PDF and label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">inter_nohitter_time</span><span class="p">,</span>
             <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s">'step'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture-16.png" alt="Desktop View" /></p>

<p>We see the typical shape of the Exponential distribution, going from a maximum at 0 and decaying to the right.</p>

<p>####
 Do the data follow our story?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create an ECDF from real data: x, y
</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">)</span>

<span class="c1"># Create a CDF from theoretical samples: x_theor, y_theor
</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">inter_nohitter_time</span><span class="p">)</span>

<span class="c1"># Overlay the plots
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Margins and axis labels
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'CDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-15.png" alt="Desktop View" /></p>

<p>It looks like no-hitters in the modern era of Major League Baseball are Exponentially distributed. Based on the story of the Exponential distribution, this suggests that they are a random process; when a no-hitter will happen is independent of when the last no-hitter was.</p>

<p>####
 How is this parameter optimal?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the theoretical CDFs
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'CDF'</span><span class="p">)</span>

<span class="c1"># Take samples with half tau: samples_half
</span><span class="n">samples_half</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Take samples with double tau: samples_double
</span><span class="n">samples_double</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Generate CDFs from these samples
</span><span class="n">x_half</span><span class="p">,</span> <span class="n">y_half</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">samples_half</span><span class="p">)</span>
<span class="n">x_double</span><span class="p">,</span> <span class="n">y_double</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">samples_double</span><span class="p">)</span>

<span class="c1"># Plot these CDFs as lines
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_half</span><span class="p">,</span> <span class="n">y_half</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_double</span><span class="p">,</span> <span class="n">y_double</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-14.png" alt="Desktop View" /></p>

<p>red = half, purple = double</p>

<p>Notice how the value of tau given by the mean matches the data best. In this way, tau is an optimal parameter.</p>

<p>###
 Linear regression by least squares</p>

<p>####
 EDA of literacy/fertility data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the illiteracy rate versus fertility
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set the margins and label axes
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'percent illiterate'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Show the Pearson correlation coefficient
</span><span class="k">print</span><span class="p">(</span><span class="n">pearson_r</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">))</span>
<span class="mf">0.8041324026815344</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-13.png" alt="Desktop View" /></p>

<p>You can see the correlation between illiteracy and fertility by eye, and by the substantial Pearson correlation coefficient of 0.8. It is difficult to resolve in the scatter plot, but there are many points around near-zero illiteracy and about 1.8 children/woman.</p>

<p>####
 Linear regression</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the illiteracy rate versus fertility
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'percent illiterate'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>

<span class="c1"># Perform a linear regression using np.polyfit(): a, b
</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the results to the screen
</span><span class="k">print</span><span class="p">(</span><span class="s">'slope ='</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s">'children per woman / percent illiterate'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'intercept ='</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">'children per woman'</span><span class="p">)</span>

<span class="c1"># Make theoretical line to plot
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Add regression line to your plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Draw the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1"># slope = 0.04979854809063423 children per woman / percent illiterate
# intercept = 1.888050610636557 children per woman
</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture4-13.png" alt="Desktop View" /></p>

<p>####
 How is it optimal?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Specify slopes to consider: a_vals
</span><span class="n">a_vals</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="c1"># Initialize sum of square of residuals: rss
</span><span class="n">rss</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a_vals</span><span class="p">)</span>

<span class="c1"># Compute sum of square of residuals for each value of a_vals
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_vals</span><span class="p">):</span>
    <span class="n">rss</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">((</span><span class="n">fertility</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">illiteracy</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Plot the RSS
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">a_vals</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="s">'-'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'slope (children per woman / percent illiterate)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'sum of square of residuals'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture5-11.png" alt="Desktop View" /></p>

<p>Notice that the minimum on the plot, that is the value of the slope that gives the minimum sum of the square of the residuals, is the same value you got when performing the regression.</p>

<p>###
 The importance of EDA: Anscombe’s quartet</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture6-8.png" alt="Desktop View" /></p>

<p>####
 The importance of EDA</p>

<p>Why should exploratory data analysis be the first step in an analysis of data (after getting your data imported and cleaned, of course)?</p>

<ul>
  <li>You can be protected from misinterpretation of the type demonstrated by Anscombe’s quartet.</li>
  <li>EDA provides a good starting point for planning the rest of your analysis.</li>
  <li>EDA is not really any more difficult than any of the subsequent analysis, so there is no excuse for not exploring the data.</li>
</ul>

<p>####
 Linear regression on appropriate Anscombe data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Perform linear regression: a, b
</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the slope and intercept
</span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># Generate theoretical x and y data: x_theor, y_theor
</span><span class="n">x_theor</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
<span class="n">y_theor</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x_theor</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Plot the Anscombe data and theoretical line
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span> <span class="o">=</span> <span class="s">'none'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>

<span class="c1"># Label the axes
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture7-9.png" alt="Desktop View" /></p>

<p>####
 Linear regression on all Anscombe data</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for i in range(4):
    plt.subplot(2,2,i+1)

    # plot the scatter plot
    plt.plot(anscombe_x[i], anscombe_y[i], marker = '.', linestyle = 'none')

    # plot the regression line
    a, b = np.polyfit(anscombe_x[i], anscombe_y[i], deg=1)
    x_theor = np.array([np.min(anscombe_x[i]), np.max(anscombe_x[i])])
    y_theor = a * x_theor + b
    plt.plot(x_theor, y_theor)

    # add label
    plt.xlabel('x' + str(i+1))
    plt.ylabel('y' + str(i+1))

plt.show()

# slope1: 0.5000909090909095 intercept: 3.000090909090909
# slope2: 0.5000000000000004 intercept: 3.0009090909090896
# slope3: 0.4997272727272731 intercept: 3.0024545454545453
# slope4: 0.4999090909090908 intercept: 3.0017272727272735

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture8-6.png" alt="Desktop View" /></p>

<p>###
 Generating bootstrap replicates</p>

<p>####
 Getting the terminology down</p>

<p>If we have a data set with n repeated measurements, a
 <strong>bootstrap sample</strong>
 is an array of length n that was drawn from the original data with replacement.</p>

<p><strong>Bootstrap replicate</strong>
 is a single value of a statistic computed from a bootstrap sample.</p>

<p>####
 Visualizing bootstrap samples</p>

<p>np.random.choice()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for _ in range(50):
    # Generate bootstrap sample: bs_sample
    bs_sample = np.random.choice(rainfall, size=len(rainfall))

    # Compute and plot ECDF from bootstrap sample
    x, y = ecdf(bs_sample)
    _ = plt.plot(x, y, marker='.', linestyle='none',
                 color='gray', alpha=0.1)

# Compute and plot ECDF from original data
x, y = ecdf(rainfall)
_ = plt.plot(x, y, marker='.')

# Make margins and label axes
plt.margins(0.02)
_ = plt.xlabel('yearly rainfall (mm)')
_ = plt.ylabel('ECDF')

# Show the plot
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture9-5.png" alt="Desktop View" /></p>

<h2 id="bootstrap-confidence-intervals-1">Bootstrap confidence intervals</h2>

<p>####
 Generating many bootstrap replicates</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def bootstrap_replicate_1d(data, func):
    return func(np.random.choice(data, size=len(data)))

def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates

</code></pre></div></div>

<p>####
 Bootstrap replicates of the mean and the SEM (
 <strong>standard error of the mean</strong>
 )</p>

<p>In fact, it can be shown theoretically that under not-too-restrictive conditions, the value of the mean will always be Normally distributed. (This does not hold in general, just for the mean and a few other statistics.)</p>

<p>The standard deviation of this distribution, called the
 <strong>standard error of the mean</strong>
 , or SEM, is given by the standard deviation of the data divided by the square root of the number of data points. I.e., for a data set,
 <code class="language-plaintext highlighter-rouge">sem = np.std(data) / np.sqrt(len(data))</code>
 . Using hacker statistics, you get this same result without the need to derive it, but you will verify this result from your bootstrap replicates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Take 10,000 bootstrap replicates of the mean: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">rainfall</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute and print SEM
</span><span class="n">sem</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">rainfall</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rainfall</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">sem</span><span class="p">)</span>

<span class="c1"># Compute and print standard deviation of bootstrap replicates
</span><span class="n">bs_std</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bs_std</span><span class="p">)</span>

<span class="c1"># Make a histogram of the results
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'mean annual rainfall (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 10.51054915050619
# 10.465927071184412
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture10-5.png" alt="Desktop View" /></p>

<p>####
 Confidence intervals of rainfall data</p>

<p>Use the bootstrap replicates you just generated to compute the 95% confidence interval. That is, give the 2.5th and 97.5th percentile of your bootstrap replicates stored as
 <code class="language-plaintext highlighter-rouge">bs_replicates</code>
 . What is the 95% confidence interval?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
np.percentile(bs_replicates,2.5)
779.7699248120301

np.percentile(bs_replicates,97.5)
820.950432330827

</code></pre></div></div>

<p>####
 Bootstrap replicates of other statistics</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_reps(data, func, size=1):
    return np.array([bootstrap_replicate_1d(data, func) for _ in range(size)])

# Generate 10,000 bootstrap replicates of the variance: bs_replicates
bs_replicates = draw_bs_reps(rainfall, np.var, size=10000)

# Put the variance in units of square centimeters
bs_replicates /= 100

# Make a histogram of the results
_ = plt.hist(bs_replicates, bins=50, normed=True)
_ = plt.xlabel('variance of annual rainfall (sq. cm)')
_ = plt.ylabel('PDF')

# Show the plot
plt.show()


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture11-5.png" alt="Desktop View" /></p>

<p>This is not normally distributed, as it has a longer tail to the right. Note that you can also compute a confidence interval on the variance, or any other statistic, using
 <code class="language-plaintext highlighter-rouge">np.percentile()</code>
 with your bootstrap replicates.</p>

<p>####
 Confidence interval on the rate of no-hitters</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Draw bootstrap replicates of the mean no-hitter time (equal to tau): bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute the 95% confidence interval: conf_int
</span><span class="n">conf_int</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">])</span>

<span class="c1"># Print the confidence interval
</span><span class="k">print</span><span class="p">(</span><span class="s">'95% confidence interval ='</span><span class="p">,</span> <span class="n">conf_int</span><span class="p">,</span> <span class="s">'games'</span><span class="p">)</span>

<span class="c1"># Plot the histogram of the replicates
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s">'$\tau$ (games)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 95% confidence interval = [660.67280876 871.63077689] games
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture12-4.png" alt="Desktop View" /></p>

<p>This gives you an estimate of what the typical time between no-hitters is. It could be anywhere between 660 and 870 games.</p>

<p>###
 Pairs bootstrap</p>

<p>####
 A function to do pairs bootstrap</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, deg=1)

    return bs_slope_reps, bs_intercept_reps


</code></pre></div></div>

<p>####
 Pairs bootstrap of literacy/fertility data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Generate replicates of slope and intercept using pairs bootstrap
</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="n">bs_intercept_reps</span> <span class="o">=</span> <span class="n">draw_bs_pairs_linreg</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Compute and print 95% CI for slope
</span><span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">]))</span>

<span class="c1"># Plot the histogram
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'slope'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># [0.04378061 0.0551616 ]
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture13-4.png" alt="Desktop View" /></p>

<p>####
 Plotting bootstrap regressions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Generate array of x-values for bootstrap lines: x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>

<span class="c1"># Plot the bootstrap lines
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                 <span class="n">bs_slope_reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

<span class="c1"># Plot the data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Label axes, set the margins, and show the plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'illiteracy'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture14-3.png" alt="Desktop View" /></p>

<h2 id="introduction-to-hypothesis-testing-1">Introduction to hypothesis testing</h2>

<p>###
 Formulating and simulating a hypothesis</p>

<dl>
  <dt><strong>Null hypothesis</strong></dt>
  <dd>another name for the hypothesis you are testing</dd>
  <dt><strong>Permutation</strong></dt>
  <dd>random reordering of entries in an array</dd>
</dl>

<p>####
 Generating a permutation sample</p>

<p>np.random.permutation()</p>

<p>Permutation sampling is a great way to simulate the hypothesis that two variables have identical probability distributions. This is often a hypothesis you want to test, so in this exercise, you will write a function to generate a permutation sample from two data sets.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def permutation_sample(data1, data2):
    """Generate a permutation sample from two data sets."""

    # Concatenate the data sets: data
    data = np.concatenate((data1, data2))

    # Permute the concatenated array: permuted_data
    permuted_data = np.random.permutation(data)

    # Split the permuted array into two: perm_sample_1, perm_sample_2
    perm_sample_1 = permuted_data[:len(data1)]
    perm_sample_2 = permuted_data[len(data1):]

    return perm_sample_1, perm_sample_2

</code></pre></div></div>

<p>####
 Visualizing permutation sampling</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for _ in range(50):
    # Generate permutation samples
    perm_sample_1, perm_sample_2 = permutation_sample(rain_june, rain_november)


    # Compute ECDFs
    x_1, y_1 = ecdf(perm_sample_1)
    x_2, y_2 = ecdf(perm_sample_2)

    # Plot ECDFs of permutation sample
    _ = plt.plot(x_1, y_1, marker='.', linestyle='none',
                 color='red', alpha=0.02)
    _ = plt.plot(x_2, y_2, marker='.', linestyle='none',
                 color='blue', alpha=0.02)

# Create and plot ECDFs from original data
x_1, y_1 = ecdf(rain_june)
x_2, y_2 = ecdf(rain_november)
_ = plt.plot(x_1, y_1, marker='.', linestyle='none', color='red')
_ = plt.plot(x_2, y_2, marker='.', linestyle='none', color='blue')

# Label axes, set margin, and show plot
plt.margins(0.02)
_ = plt.xlabel('monthly rainfall (mm)')
_ = plt.ylabel('ECDF')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-16.png" alt="Desktop View" /></p>

<p>Notice that the permutation samples ECDFs overlap and give a purple haze. None of the ECDFs from the permutation samples overlap with the observed data, suggesting that the hypothesis is not commensurate with the data. June and November rainfall are not identically distributed.</p>

<p>###
 Test statistics and p-values</p>

<p>####
 Test statistics</p>

<p>When performing hypothesis tests, your choice of test statistic should be pertinent to the question you are seeking to answer in your hypothesis test.</p>

<p>The most important thing to consider is:
 <strong>What are you asking?</strong></p>

<p>####
 What is a p-value?</p>

<p>The p-value is generally a measure of the probability of observing a test statistic equally or more extreme than the one you observed, given that the null hypothesis is true.</p>

<p>####
 Generating permutation replicates</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># In most circumstances, func will be a function you write yourself.
</span><span class="k">def</span> <span class="nf">draw_perm_reps</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s">"""Generate multiple permutation replicates."""</span>

    <span class="c1"># Initialize array of replicates: perm_replicates
</span>    <span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="c1"># Generate permutation sample
</span>        <span class="n">perm_sample_1</span><span class="p">,</span> <span class="n">perm_sample_2</span> <span class="o">=</span> <span class="n">permutation_sample</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">)</span>

        <span class="c1"># Compute the test statistic
</span>        <span class="n">perm_replicates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">perm_sample_1</span><span class="p">,</span> <span class="n">perm_sample_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">perm_replicates</span>

</code></pre></div></div>

<p>####
 Look before you leap: EDA before hypothesis testing</p>

<p>Kleinteich and Gorb (
 <em>Sci. Rep.</em>
 ,
 <strong>4</strong>
 , 5225, 2014) performed an interesting experiment with South American horned frogs. They held a plate connected to a force transducer, along with a bait fly, in front of them. They then measured the impact force and adhesive force of the frog’s tongue when it struck the target.</p>

<p>Frog A is an adult and Frog B is a juvenile. The researchers measured the impact force of 20 strikes for each frog. In the next exercise, we will test the hypothesis that the two frogs have the same distribution of impact forces. But, remember, it is important to do EDA first! Let’s make a bee swarm plot for the data. They are stored in a Pandas data frame,
 <code class="language-plaintext highlighter-rouge">df</code>
 , where column
 <code class="language-plaintext highlighter-rouge">ID</code>
 is the identity of the frog and column
 <code class="language-plaintext highlighter-rouge">impact_force</code>
 is the impact force in Newtons (N).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   ID  impact_force
20  A         1.612
21  A         0.605
22  A         0.327
23  A         0.946
24  A         0.541

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make bee swarm plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">sns</span><span class="p">.</span><span class="n">swarmplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s">'ID'</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s">'impact_force'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'frog'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'impact force (N)'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-15.png" alt="Desktop View" /></p>

<p>Eyeballing it, it does not look like they come from the same distribution. Frog A, the adult, has three or four very hard strikes, and Frog B, the juvenile, has a couple weak ones. However, it is possible that with only 20 samples it might be too difficult to tell if they have difference distributions, so we should proceed with the hypothesis test.</p>

<p>####
 Permutation test on frog data</p>

<p>The average strike force of Frog A was 0.71 Newtons (N), and that of Frog B was 0.42 N for a difference of 0.29 N. It is possible the frogs strike with the same force and this observed difference was by chance. You will compute the probability of getting at least a 0.29 N difference in mean strike force under the hypothesis that the distributions of strike forces for the two frogs are identical. We use a permutation test with a test statistic of the difference of means to test this hypothesis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def diff_of_means(data_1, data_2):
    """Difference in means of two arrays."""

    # The difference of means of data_1, data_2: diff
    diff = np.mean(data_1) - np.mean(data_2)

    return diff

# Compute difference of mean impact force from experiment: empirical_diff_means
empirical_diff_means = diff_of_means(force_a, force_b)

# Draw 10,000 permutation replicates: perm_replicates
perm_replicates = draw_perm_reps(force_a, force_b,
                                 diff_of_means, size=10000)

# Compute p-value: p
p = np.sum(perm_replicates &gt;= empirical_diff_means) / len(perm_replicates)

# Print the result
print('p-value =', p)

# p-value = 0.0063
# p-value = 0.63%

</code></pre></div></div>

<p>The p-value tells you that there is about a 0.6% chance that you would get the difference of means observed in the experiment if frogs were exactly the same.</p>

<p>A p-value below 0.01 is typically said to be “statistically significant,” but: warning! warning! warning! You have computed a p-value; it is a number. I encourage you not to distill it to a yes-or-no phrase. p = 0.006 and p = 0.000000006 are both said to be “statistically significant,” but they are definitely not the same!</p>

<p>###
 Bootstrap hypothesis tests</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-14.png" alt="Desktop View" /></p>

<p>####
 A one-sample bootstrap hypothesis test</p>

<p>Another juvenile frog was studied, Frog C, and you want to see if Frog B and Frog C have similar impact forces. Unfortunately, you do not have Frog C’s impact forces available, but you know they have a mean of 0.55 N. Because you don’t have the original data, you cannot do a permutation test, and you cannot assess the hypothesis that the forces from Frog B and Frog C come from the same distribution. You will therefore test another, less restrictive hypothesis: The mean strike force of Frog B is equal to that of Frog C.</p>

<p>To set up the bootstrap hypothesis test, you will take the mean as our test statistic. Remember, your goal is to calculate the probability of getting a mean impact force less than or equal to what was observed for Frog B
 <em>if the hypothesis that the true mean of Frog B’s impact forces is equal to that of Frog C is true</em>
 . You first translate all of the data of Frog B such that the mean is 0.55 N. This involves adding the mean force of Frog C and subtracting the mean force of Frog B from each measurement of Frog B. This leaves other properties of Frog B’s distribution, such as the variance, unchanged.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make an array of translated impact forces: translated_force_b
</span><span class="n">translated_force_b</span> <span class="o">=</span> <span class="n">force_b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.55</span>

<span class="c1"># Take bootstrap replicates of Frog B's translated impact forces: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">translated_force_b</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute fraction of replicates that are less than the observed Frog B force: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_replicates</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10000</span>

<span class="c1"># Print the p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p = '</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p =  0.0046
# p = 0.46%
</span>
</code></pre></div></div>

<p>The low p-value suggests that the null hypothesis that Frog B and Frog C have the same mean impact force is false.</p>

<p>####
 A two-sample bootstrap hypothesis test for difference of means</p>

<p>We now want to test the hypothesis that Frog A and Frog B have the same mean impact force, but not necessarily the same distribution, which is also impossible with a permutation test.</p>

<p>To do the two-sample bootstrap test, we shift
 <em>both</em>
 arrays to have the same mean, since we are simulating the hypothesis that their means are, in fact, equal. We then draw bootstrap samples out of the shifted arrays and compute the difference in means. This constitutes a bootstrap replicate, and we generate many of them. The p-value is the fraction of replicates with a difference in means greater than or equal to what was observed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute mean of all forces: mean_force
</span><span class="n">mean_force</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">forces_concat</span><span class="p">)</span>

<span class="c1"># Generate shifted arrays
</span><span class="n">force_a_shifted</span> <span class="o">=</span> <span class="n">force_a</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_force</span>
<span class="n">force_b_shifted</span> <span class="o">=</span> <span class="n">force_b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_force</span>

<span class="c1"># Compute 10,000 bootstrap replicates from shifted arrays
</span><span class="n">bs_replicates_a</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">force_a_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_b</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">force_b_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Get replicates of difference of means: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">bs_replicates_a</span> <span class="o">-</span> <span class="n">bs_replicates_b</span>

<span class="c1"># Compute and print p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_replicates</span> <span class="o">&gt;=</span> <span class="n">empirical_diff_means</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="k">print</span><span class="p">(</span><span class="s">'p-value ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-value = 0.0043
# p-value = 0.43%
</span>
</code></pre></div></div>

<p>You got a similar result as when you did the permutation test. Nonetheless, remember that it is important to carefully think about what question you want to ask. Are you only interested in the mean impact force, or in the distribution of impact forces?</p>

<h2 id="hypothesis-test-examples-1">Hypothesis test examples</h2>

<p>###
 A/B testing</p>

<p>####
 The vote for the Civil Rights Act in 1964</p>

<p>The Civil Rights Act of 1964 was one of the most important pieces of legislation ever passed in the USA. Excluding “present” and “abstain” votes, 153 House Democrats and 136 Republicans voted yea. However, 91 Democrats and 35 Republicans voted nay. Did party affiliation make a difference in the vote?</p>

<p>To answer this question, you will evaluate the hypothesis that the party of a House member has no bearing on his or her vote. You will use the fraction of Democrats voting in favor as your test statistic and evaluate the probability of observing a fraction of Democrats voting in favor at least as small as the observed fraction of 153/244. (That’s right, at least as
 <em>small</em>
 as. In 1964, it was the
 <em>Democrats</em>
 who were less progressive on civil rights issues.) To do this, permute the party labels of the House voters and then arbitrarily divide them into “Democrats” and “Republicans” and compute the fraction of Democrats voting yea.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Construct arrays of data: dems, reps
</span><span class="n">dems</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">153</span> <span class="o">+</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">91</span><span class="p">)</span>
<span class="n">reps</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">136</span> <span class="o">+</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">35</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">frac_yea_dems</span><span class="p">(</span><span class="n">dems</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
    <span class="s">"""Compute fraction of Democrat yea votes."""</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">dems</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dems</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">frac</span>

<span class="c1"># Acquire permutation samples: perm_replicates
</span><span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">draw_perm_reps</span><span class="p">(</span><span class="n">dems</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">frac_yea_dems</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute and print p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">perm_replicates</span> <span class="o">&lt;=</span> <span class="mi">153</span><span class="o">/</span><span class="mi">244</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm_replicates</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'p-value ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-value = 0.0002
# p-value = 0.02%
</span>
</code></pre></div></div>

<p>This small p-value suggests that party identity had a lot to do with the voting. Importantly, the South had a higher fraction of Democrat representatives, and consequently also a more racist bias.</p>

<p>####
 What is equivalent?</p>

<p>You have experience matching a stories to probability distributions. Similarly, you use the same procedure for two different A/B tests if their stories match. In the Civil Rights Act example you just did, you performed an A/B test on voting data, which has a Yes/No type of outcome for each subject (in that case, a voter). Which of the following situations involving testing by a web-based company has an equivalent set up for an A/B test as the one you just did with the Civil Rights Act of 1964?</p>

<p>You measure the number of people who click on an ad on your company’s website before and after changing its color.</p>

<p>The “Democrats” are those who view the ad before the color change, and the “Republicans” are those who view it after.</p>

<p>####
 A time-on-website analog</p>

<p>It turns out that you already did a hypothesis test analogous to an A/B test where you are interested in how much time is spent on the website before and after an ad campaign. The frog tongue force (a continuous quantity like time on the website) is an analog. “Before” = Frog A and “after” = Frog B. Let’s practice this again with something that actually is a before/after scenario.</p>

<p>We return to the no-hitter data set. In 1920, Major League Baseball implemented important rule changes that ended the so-called dead ball era. Importantly, the pitcher was no longer allowed to spit on or scuff the ball, an activity that greatly favors pitchers. In this problem you will perform an A/B test to determine if these rule changes resulted in a slower rate of no-hitters (i.e., longer average time between no-hitters) using the difference in mean inter-no-hitter time as your test statistic. The inter-no-hitter times for the respective eras are stored in the arrays
 <code class="language-plaintext highlighter-rouge">nht_dead</code>
 and
 <code class="language-plaintext highlighter-rouge">nht_live</code>
 , where “nht” is meant to stand for “no-hitter time.”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def diff_of_means(data_1, data_2):
    """Difference in means of two arrays."""

    # The difference of means of data_1, data_2: diff
    diff = np.mean(data_1) - np.mean(data_2)

    return diff

def permutation_sample(data1, data2):
    """Generate a permutation sample from two data sets."""

    # Concatenate the data sets: data
    data = np.concatenate((data1, data2))

    # Permute the concatenated array: permuted_data
    permuted_data = np.random.permutation(data)

    # Split the permuted array into two: perm_sample_1, perm_sample_2
    perm_sample_1 = permuted_data[:len(data1)]
    perm_sample_2 = permuted_data[len(data1):]

    return perm_sample_1, perm_sample_2

def draw_perm_reps(data_1, data_2, func, size=1):
    """Generate multiple permutation replicates."""

    # Initialize array of replicates: perm_replicates
    perm_replicates = np.empty(size)

    for i in range(size):
        # Generate permutation sample
        perm_sample_1, perm_sample_2 = permutation_sample(data_1, data_2)

        # Compute the test statistic
        perm_replicates[i] = func(perm_sample_1, perm_sample_2)

    return perm_replicates



# Compute the observed difference in mean inter-no-hitter times: nht_diff_obs
nht_diff_obs = diff_of_means(nht_dead, nht_live)

# Acquire 10,000 permutation replicates of difference in mean no-hitter time: perm_replicates
perm_replicates = draw_perm_reps(nht_dead, nht_live, diff_of_means, size=10000)

# Compute and print the p-value: p
p = np.sum(perm_replicates &lt;= nht_diff_obs) /len(perm_replicates)
print('p-val =', p)

p-val = 0.0001

</code></pre></div></div>

<p>Your p-value is 0.0001, which means that only one out of your 10,000 replicates had a result as extreme as the actual difference between the dead ball and live ball eras. This suggests strong statistical significance. Watch out, though, you could very well have gotten zero replicates that were as extreme as the observed value. This just means that the p-value is quite small, almost certainly smaller than 0.001.</p>

<p>####
 What should you have done first?</p>

<p>That was a nice hypothesis test you just did to check out whether the rule changes in 1920 changed the rate of no-hitters. But what
 <em>should</em>
 you have done with the data first?</p>

<p>Performed EDA, perhaps plotting the ECDFs of inter-no-hitter times in the dead ball and live ball eras.</p>

<p>Always a good idea to do first! I encourage you to go ahead and plot the ECDFs right now. You will see by eye that the null hypothesis that the distributions are the same is almost certainly not true.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create and plot ECDFs
</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nht_dead</span><span class="p">)</span>
<span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nht_live</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>

<span class="c1"># Label axes, set margin, and show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-17.png" alt="Desktop View" /></p>

<p>###
 Test of correlation</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-16.png" alt="Desktop View" /></p>

<p>####
 Simulating a null hypothesis concerning correlation</p>

<p>The observed correlation between female illiteracy and fertility in the data set of 162 countries may just be by chance; the fertility of a given country may actually be totally independent of its illiteracy. You will test this null hypothesis in the next exercise.</p>

<p>To do the test, you need to simulate the data assuming the null hypothesis is true. Of the following choices, which is the best way to to do it?</p>

<p>Answer: Do a permutation test: Permute the illiteracy values but leave the fertility values fixed to generate a new set of (illiteracy, fertility) data.</p>

<p>This exactly simulates the null hypothesis and does so more efficiently than the last option. It is exact because it uses all data and eliminates any correlation because which illiteracy value pairs to which fertility value is shuffled.</p>

<p>Last option: Do a permutation test: Permute both the illiteracy and fertility values to generate a new set of (illiteracy, fertility data). This exactly simulates the null hypothesis and does so more efficiently than the last option. It is exact because it uses all data and eliminates any correlation because which illiteracy value pairs to which fertility value is shuffled.</p>

<p>####
 Hypothesis test on Pearson correlation</p>

<p>The observed correlation between female illiteracy and fertility may just be by chance; the fertility of a given country may actually be totally independent of its illiteracy. You will test this hypothesis. To do so, permute the illiteracy values but leave the fertility values fixed. This simulates the hypothesis that they are totally independent of each other. For each permutation, compute the Pearson correlation coefficient and assess how many of your permutation replicates have a Pearson correlation coefficient greater than the observed one.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def pearson_r(x, y):
    """Compute Pearson correlation coefficient between two arrays."""
    # Compute correlation matrix: corr_mat
    corr_mat = np.corrcoef(x, y)

    # Return entry [0,1]
    return corr_mat[0,1]

# Compute observed correlation: r_obs
r_obs = pearson_r(illiteracy, fertility)

# r_obs = 0.8041324026815344

# Initialize permutation replicates: perm_replicates
perm_replicates = np.empty(10000)

# Draw replicates
for i in range(10000):
    # Permute illiteracy measurments: illiteracy_permuted
    illiteracy_permuted = np.random.permutation(illiteracy)

    # Compute Pearson correlation
    perm_replicates[i] = pearson_r(illiteracy_permuted, fertility)

# Compute p-value: p
p = np.sum(perm_replicates &gt;= r_obs) /len(perm_replicates)
print('p-val =', p)

# p-val = 0.0

</code></pre></div></div>

<p>You got a p-value of zero. In hacker statistics, this means that your p-value is very low, since you never got a single replicate in the 10,000 you took that had a Pearson correlation greater than the observed one. You could try increasing the number of replicates you take to continue to move the upper bound on your p-value lower and lower.</p>

<p>####
 Do neonicotinoid insecticides have unintended consequences?</p>

<p>As a final exercise in hypothesis testing before we put everything together in our case study in the next chapter, you will investigate the effects of neonicotinoid insecticides on bee reproduction. These insecticides are very widely used in the United States to combat aphids and other pests that damage plants.</p>

<p>In a recent study, Straub, et al. (
 <a href="http://dx.doi.org/10.1098/rspb.2016.0506"><em>Proc. Roy. Soc. B</em>
 , 2016</a>
 ) investigated the effects of neonicotinoids on the sperm of pollinating bees. In this and the next exercise, you will study how the pesticide treatment affected the count of live sperm per half milliliter of semen.</p>

<p>First, we will do EDA, as usual. Plot ECDFs of the alive sperm count for untreated bees (stored in the Numpy array
 <code class="language-plaintext highlighter-rouge">control</code>
 ) and bees treated with pesticide (stored in the Numpy array
 <code class="language-plaintext highlighter-rouge">treated</code>
 ).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute x,y values for ECDFs
</span><span class="n">x_control</span><span class="p">,</span> <span class="n">y_control</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">control</span><span class="p">)</span>
<span class="n">x_treated</span><span class="p">,</span> <span class="n">y_treated</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">treated</span><span class="p">)</span>

<span class="c1"># Plot the ECDFs
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_control</span><span class="p">,</span> <span class="n">y_control</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_treated</span><span class="p">,</span> <span class="n">y_treated</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set the margins
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>

<span class="c1"># Add a legend
</span><span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'control'</span><span class="p">,</span> <span class="s">'treated'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Label axes and show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'millions of alive sperm per mL'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-15.png" alt="Desktop View" /></p>

<p>The ECDFs show a pretty clear difference between the treatment and control; treated bees have fewer alive sperm. Let’s now do a hypothesis test in the next exercise.</p>

<p>####
 Bootstrap hypothesis test on bee sperm counts</p>

<p>Now, you will test the following hypothesis:</p>

<p><strong>On average, male bees treated with neonicotinoid insecticide have the same number of active sperm per milliliter of semen than do untreated male bees.</strong></p>

<p>You will use the difference of means as your test statistic.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def bootstrap_replicate_1d(data, func):
    return func(np.random.choice(data, size=len(data)))

def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates


# Compute the difference in mean sperm count: diff_means
diff_means = np.mean(control) - np.mean(treated)

# Compute mean of pooled data: mean_count
mean_count = np.mean(np.concatenate((control, treated)))

# Generate shifted data sets
control_shifted = control - np.mean(control) + mean_count
treated_shifted = treated - np.mean(treated) + mean_count

# Generate bootstrap replicates
bs_reps_control = draw_bs_reps(control_shifted,
                       np.mean, size=10000)
bs_reps_treated = draw_bs_reps(treated_shifted,
                       np.mean, size=10000)

# Get replicates of difference of means: bs_replicates
bs_replicates = bs_reps_control - bs_reps_treated

# Compute and print p-value: p
p = np.sum(bs_replicates &gt;= np.mean(control) - np.mean(treated)) \
            / len(bs_replicates)
print('p-value =', p)

# p-value = 0.0

</code></pre></div></div>

<p>The p-value is small, most likely less than 0.0001, since you never saw a bootstrap replicated with a difference of means at least as extreme as what was observed. In fact, when I did the calculation with 10 million replicates, I got a p-value of
 <code class="language-plaintext highlighter-rouge">2e-05</code></p>

<h2 id="putting-it-all-together-a-case-study-1">Putting it all together: a case study</h2>

<p>###
 Finch beaks and the need for statistics</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture4-14.png" alt="Desktop View" /></p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture5-12.png" alt="Desktop View" /></p>

<p>####
 EDA of beak depths of Darwin’s finches</p>

<p>For your first foray into the Darwin finch data, you will study how the beak depth (the distance, top to bottom, of a closed beak) of the finch species
 <em>Geospiza scandens</em>
 has changed over time. The Grants have noticed some changes of beak geometry depending on the types of seeds available on the island, and they also noticed that there was some interbreeding with another major species on Daphne Major,
 <em>Geospiza fortis</em>
 . These effects can lead to changes in the species over time.</p>

<p>In the next few problems, you will look at the beak depth of
 <em>G. scandens</em>
 on Daphne Major in 1975 and in 2012. To start with, let’s plot all of the beak depth measurements in 1975 and 2012 in a bee swarm plot.</p>

<p>The data are stored in a pandas DataFrame called
 <code class="language-plaintext highlighter-rouge">df</code>
 with columns
 <code class="language-plaintext highlighter-rouge">'year'</code>
 and
 <code class="language-plaintext highlighter-rouge">'beak_depth'</code>
 . The units of beak depth are millimeters (mm).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   beak_depth  year
0         8.4  1975
1         8.8  1975
2         8.4  1975
3         8.0  1975
4         7.9  1975

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create bee swarm plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">sns</span><span class="p">.</span><span class="n">swarmplot</span><span class="p">(</span><span class="s">'year'</span><span class="p">,</span> <span class="s">'beak_depth'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Label the axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'year'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture6-9.png" alt="Desktop View" /></p>

<p>It is kind of hard to see if there is a clear difference between the 1975 and 2012 data set. Eyeballing it, it appears as though the mean of the 2012 data set might be slightly higher, and it might have a bigger variance.</p>

<p>####
 ECDFs of beak depths</p>

<p>While bee swarm plots are useful, we found that ECDFs are often even better when doing EDA. Plot the ECDFs for the 1975 and 2012 beak depth measurements on the same plot.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute ECDFs
</span><span class="n">x_1975</span><span class="p">,</span> <span class="n">y_1975</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">bd_1975</span><span class="p">)</span>
<span class="n">x_2012</span><span class="p">,</span> <span class="n">y_2012</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">bd_2012</span><span class="p">)</span>

<span class="c1"># Plot the ECDFs
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1975</span><span class="p">,</span> <span class="n">y_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2012</span><span class="p">,</span> <span class="n">y_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set margins
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>

<span class="c1"># Add axis labels and legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture7-10.png" alt="Desktop View" /></p>

<p>The differences are much clearer in the ECDF. The mean is larger in the 2012 data, and the variance does appear larger as well.</p>

<p>####
 Parameter estimates of beak depths</p>

<p>Estimate the
 <em>difference</em>
 of the mean beak depth of the
 <em>G. scandens</em>
 samples from 1975 and 2012 and report a 95% confidence interval.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates


# Compute the difference of the sample means: mean_diff
mean_diff = np.mean(bd_2012) - np.mean(bd_1975)

# Get bootstrap replicates of means
bs_replicates_1975 = draw_bs_reps(bd_1975, np.mean, size=10000)
bs_replicates_2012 = draw_bs_reps(bd_2012, np.mean, size=10000)

# Compute samples of difference of means: bs_diff_replicates
bs_diff_replicates = bs_replicates_2012 - bs_replicates_1975

# Compute 95% confidence interval: conf_int
conf_int = np.percentile(bs_diff_replicates, [2.5, 97.5])

# Print the results
print('difference of means =', mean_diff, 'mm')
print('95% confidence interval =', conf_int, 'mm')

# difference of means = 0.22622047244094645 mm
# 95% confidence interval = [0.05633521 0.39190544] mm

</code></pre></div></div>

<p>####
 Hypothesis test: Are beaks deeper in 2012?</p>

<p>Your plot of the ECDF and determination of the confidence interval make it pretty clear that the beaks of
 <em>G. scandens</em>
 on Daphne Major have gotten deeper. But is it possible that this effect is just due to random chance? In other words, what is the probability that we would get the observed difference in mean beak depth if the means were the same?</p>

<p>Be careful! The hypothesis we are testing is
 <em>not</em>
 that the beak depths come from the same distribution. For that we could use a permutation test.
 <strong>The hypothesis is that the means are equal.</strong>
 To perform this hypothesis test, we need to shift the two data sets so that they have the same mean and then use bootstrap sampling to compute the difference of means.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute mean of combined data set: combined_mean
</span><span class="n">combined_mean</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">bd_1975</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">)))</span>

<span class="c1"># Shift the samples
# why shift the mean?
# to make np.mean(bd_1975_shifted) - np.mean(bd_2012_shifted) = 0 #1
# why make #1 = 0?
# because our hypothesis is "beak depth are the same in 1975 and 2012"
</span><span class="n">bd_1975_shifted</span> <span class="o">=</span> <span class="n">bd_1975</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bd_1975</span><span class="p">)</span> <span class="o">+</span> <span class="n">combined_mean</span>
<span class="n">bd_2012_shifted</span> <span class="o">=</span> <span class="n">bd_2012</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bd_2012</span><span class="p">)</span> <span class="o">+</span> <span class="n">combined_mean</span>

<span class="c1"># Get bootstrap replicates of shifted data sets
</span><span class="n">bs_replicates_1975</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">bd_1975_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_2012</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">bd_2012_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute replicates of difference of means: bs_diff_replicates
</span><span class="n">bs_diff_replicates</span> <span class="o">=</span> <span class="n">bs_replicates_2012</span> <span class="o">-</span> <span class="n">bs_replicates_1975</span>

<span class="c1"># Compute the p-value
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_diff_replicates</span> <span class="o">&gt;=</span> <span class="n">mean_diff</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs_diff_replicates</span><span class="p">)</span>

<span class="c1"># Print p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p = 0.0034
# p = 0.34%
</span>
</code></pre></div></div>

<p>We get a p-value of 0.0034, which suggests that there is a statistically significant difference. But remember: it is very important to know how different they are! In the previous exercise, you got a difference of 0.2 mm between the means. You should combine this with the statistical significance. Changing by 0.2 mm in 37 years is substantial by evolutionary standards. If it kept changing at that rate, the beak depth would double in only 400 years.</p>

<p>###
 Variation of beak shapes</p>

<p>####
 EDA of beak length and depth</p>

<p>The beak length data are stored as
 <code class="language-plaintext highlighter-rouge">bl_1975</code>
 and
 <code class="language-plaintext highlighter-rouge">bl_2012</code>
 , again with units of millimeters (mm). You still have the beak depth data stored in
 <code class="language-plaintext highlighter-rouge">bd_1975</code>
 and
 <code class="language-plaintext highlighter-rouge">bd_2012</code>
 . Make scatter plots of beak depth (y-axis) versus beak length (x-axis) for the 1975 and 2012 specimens.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plot of 1975 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_1975</span><span class="p">,</span> <span class="n">bd_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'None'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Make scatter plot of 2012 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_2012</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s">'None'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes and make legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak length (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture8-7.png" alt="Desktop View" /></p>

<p>In looking at the plot, we see that beaks got deeper (the red points are higher up in the y-direction), but not really longer. If anything, they got a bit shorter, since the red dots are to the left of the blue dots. So, it does not look like the beaks kept the same shape; they became shorter and deeper.</p>

<p>####
 Linear regressions</p>

<p>Perform a linear regression for both the 1975 and 2012 data. Then, perform pairs bootstrap estimates for the regression parameters. Report 95% confidence intervals on the slope and intercept of the regression line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, deg=1)

    return bs_slope_reps, bs_intercept_reps


# Compute the linear regressions
slope_1975, intercept_1975 = np.polyfit(bl_1975, bd_1975, deg=1)
slope_2012, intercept_2012 = np.polyfit(bl_2012, bd_2012, deg=1)

# Perform pairs bootstrap for the linear regressions
bs_slope_reps_1975, bs_intercept_reps_1975 = draw_bs_pairs_linreg(bl_1975, bd_1975, size=1000)
bs_slope_reps_2012, bs_intercept_reps_2012 = draw_bs_pairs_linreg(bl_2012, bd_2012, size=1000)

# Compute confidence intervals of slopes
slope_conf_int_1975 = np.percentile(bs_slope_reps_1975, [2.5, 97.5])
slope_conf_int_2012 = np.percentile(bs_slope_reps_2012, [2.5, 97.5])
intercept_conf_int_1975 = np.percentile(bs_intercept_reps_1975, [2.5, 97.5])
intercept_conf_int_2012 = np.percentile(bs_intercept_reps_2012, [2.5, 97.5])


# Print the results
print('1975: slope =', slope_1975,
      'conf int =', slope_conf_int_1975)
print('1975: intercept =', intercept_1975,
      'conf int =', intercept_conf_int_1975)
print('2012: slope =', slope_2012,
      'conf int =', slope_conf_int_2012)
print('2012: intercept =', intercept_2012,
      'conf int =', intercept_conf_int_2012)

#   1975: slope = 0.4652051691605937 conf int = [0.33851226 0.59306491]
#   1975: intercept = 2.3908752365842263 conf int = [0.64892945 4.18037063]
#   2012: slope = 0.462630358835313 conf int = [0.33137479 0.60695527]
#   2012: intercept = 2.977247498236019 conf int = [1.06792753 4.70599387]

</code></pre></div></div>

<p>It looks like they have the same slope, but different intercepts.</p>

<p>####
 Displaying the linear regression results</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plot of 1975 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_1975</span><span class="p">,</span> <span class="n">bd_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Make scatter plot of 2012 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_2012</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes and make legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak length (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>

<span class="c1"># Generate x-values for bootstrap lines: x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">17</span><span class="p">])</span>

<span class="c1"># Plot the bootstrap lines
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bs_slope_reps_1975</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps_1975</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bs_slope_reps_2012</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps_2012</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

<span class="c1"># Draw the plot again
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture9-6.png" alt="Desktop View" /></p>

<p>####
 Beak length to depth ratio</p>

<p>The linear regressions showed interesting information about the beak geometry. The slope was the same in 1975 and 2012, suggesting that for every millimeter gained in beak length, the birds gained about half a millimeter in depth in both years. However, if we are interested in the shape of the beak, we want to compare the
 <em>ratio</em>
 of beak length to beak depth. Let’s make that comparison.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute length-to-depth ratios
</span><span class="n">ratio_1975</span> <span class="o">=</span> <span class="n">bl_1975</span> <span class="o">/</span> <span class="n">bd_1975</span>
<span class="n">ratio_2012</span> <span class="o">=</span> <span class="n">bl_2012</span> <span class="o">/</span> <span class="n">bd_2012</span>

<span class="c1"># Compute means
</span><span class="n">mean_ratio_1975</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratio_1975</span><span class="p">)</span>
<span class="n">mean_ratio_2012</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratio_2012</span><span class="p">)</span>

<span class="c1"># Generate bootstrap replicates of the means
</span><span class="n">bs_replicates_1975</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">ratio_1975</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_2012</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">ratio_2012</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute the 99% confidence intervals
</span><span class="n">conf_int_1975</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates_1975</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">])</span>
<span class="n">conf_int_2012</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates_2012</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">])</span>

<span class="c1"># Print the results
</span><span class="k">print</span><span class="p">(</span><span class="s">'1975: mean ratio ='</span><span class="p">,</span> <span class="n">mean_ratio_1975</span><span class="p">,</span>
      <span class="s">'conf int ='</span><span class="p">,</span> <span class="n">conf_int_1975</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'2012: mean ratio ='</span><span class="p">,</span> <span class="n">mean_ratio_2012</span><span class="p">,</span>
      <span class="s">'conf int ='</span><span class="p">,</span> <span class="n">conf_int_2012</span><span class="p">)</span>

<span class="c1"># 1975: mean ratio = 1.5788823771858533 conf int = [1.55668803 1.60073509]
# 2012: mean ratio = 1.4658342276847767 conf int = [1.44363932 1.48729149]
</span>
</code></pre></div></div>

<p>####
 How different is the ratio?</p>

<p>In the previous exercise, you computed the mean beak length to depth ratio with 99% confidence intervals for 1975 and for 2012. The results of that calculation are shown graphically in the plot accompanying this problem. In addition to these results, what would you say about the ratio of beak length to depth?</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture10-6.png" alt="Desktop View" /></p>

<p>The mean beak length-to-depth ratio decreased by about 0.1, or 7%, from 1975 to 2012. The 99% confidence intervals are not even close to overlapping, so this is a real change. The beak shape changed.</p>

<p>###
 Calculation of heritability</p>

<p>####
 EDA of heritability</p>

<p>The array
 <code class="language-plaintext highlighter-rouge">bd_parent_scandens</code>
 contains the average beak depth (in mm) of two parents of the species
 <code class="language-plaintext highlighter-rouge">G. scandens</code>
 . The array
 <code class="language-plaintext highlighter-rouge">bd_offspring_scandens</code>
 contains the average beak depth of the offspring of the respective parents. The arrays
 <code class="language-plaintext highlighter-rouge">bd_parent_fortis</code>
 and
 <code class="language-plaintext highlighter-rouge">bd_offspring_fortis</code>
 contain the same information about measurements from
 <em>G. fortis</em>
 birds.</p>

<p>Make a scatter plot of the average offspring beak depth (y-axis) versus average parental beak depth (x-axis) for both species. Use the
 <code class="language-plaintext highlighter-rouge">alpha=0.5</code>
 keyword argument to help you see overlapping points.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plots
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bd_parent_fortis</span><span class="p">,</span> <span class="n">bd_offspring_fortis</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bd_parent_scandens</span><span class="p">,</span> <span class="n">bd_offspring_scandens</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'parental beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'offspring beak depth (mm)'</span><span class="p">)</span>

<span class="c1"># Add legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'G. fortis'</span><span class="p">,</span> <span class="s">'G. scandens'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture11-6.png" alt="Desktop View" /></p>

<p>It appears as though there is a stronger correlation in
 <em>G. fortis</em>
 than than in
 <em>G. scandens</em>
 . This suggests that beak depth is more strongly inherited in
 <em>G. fortis</em>
 . We’ll quantify this correlation next.</p>

<p>####
 Correlation of offspring and parental data</p>

<p>In an effort to quantify the correlation between offspring and parent beak depths, we would like to compute statistics, such as the Pearson correlation coefficient, between parents and offspring. To get confidence intervals on this, we need to do a pairs bootstrap.</p>

<p>You have
 <a href="https://campus.datacamp.com/courses/statistical-thinking-in-python-part-2/bootstrap-confidence-intervals?ex=12">already written</a>
 a function to do pairs bootstrap to get estimates for parameters derived from linear regression. Your task in this exercise is to make a new function with call signature
 <code class="language-plaintext highlighter-rouge">draw_bs_pairs(x, y, func, size=1)</code>
 that performs pairs bootstrap and computes a single statistic on pairs samples defined. The statistic of interest is computed by calling
 <code class="language-plaintext highlighter-rouge">func(bs_x, bs_y)</code>
 . In the next exercise, you will use
 <code class="language-plaintext highlighter-rouge">pearson_r</code>
 for
 <code class="language-plaintext highlighter-rouge">func</code>
 .</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs(x, y, func, size=1):
    """Perform pairs bootstrap for a single statistic."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_replicates[i] = func(bs_x, bs_y)

    return bs_replicates


</code></pre></div></div>

<p>####
 Pearson correlation of offspring and parental data</p>

<p>The Pearson correlation coefficient seems like a useful measure of how strongly the beak depth of parents are inherited by their offspring. Compute the Pearson correlation coefficient between parental and offspring beak depths for
 <em>G. scandens</em>
 . Do the same for
 <em>G. fortis</em>
 . Then, use the function you wrote in the last exercise to compute a 95% confidence interval using pairs bootstrap.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def pearson_r(x, y):
    """Compute Pearson correlation coefficient between two arrays."""
    # Compute correlation matrix: corr_mat
    corr_mat = np.corrcoef(x, y)

    # Return entry [0,1]
    return corr_mat[0,1]


# Compute the Pearson correlation coefficients
r_scandens = pearson_r(bd_parent_scandens, bd_offspring_scandens)
r_fortis = pearson_r(bd_parent_fortis, bd_offspring_fortis)

# Acquire 1000 bootstrap replicates of Pearson r
bs_replicates_scandens = draw_bs_pairs(bd_parent_scandens, bd_offspring_scandens, pearson_r, size=1000)

bs_replicates_fortis = draw_bs_pairs(bd_parent_fortis, bd_offspring_fortis, pearson_r, size=1000)


# Compute 95% confidence intervals
conf_int_scandens = np.percentile(bs_replicates_scandens, [2.5, 97.5])
conf_int_fortis = np.percentile(bs_replicates_fortis, [2.5, 97.5])

# Print results
print('G. scandens:', r_scandens, conf_int_scandens)
print('G. fortis:', r_fortis, conf_int_fortis)

#    G. scandens: 0.4117063629401258 [0.26564228 0.54388972]
#    G. fortis: 0.7283412395518487 [0.6694112  0.77840616]

</code></pre></div></div>

<p>It is clear from the confidence intervals that beak depth of the offspring of
 <em>G. fortis</em>
 parents is more strongly correlated with their offspring than their
 <em>G. scandens</em>
 counterparts.</p>

<p>####
 Measuring heritability</p>

<p>Remember that the Pearson correlation coefficient is the ratio of the covariance to the geometric mean of the variances of the two data sets. This is a measure of the correlation between parents and offspring, but might not be the best estimate of heritability. If we stop and think, it makes more sense to define heritability as the ratio of the covariance between parent and offspring to the
 <em>variance of the parents alone</em>
 . In this exercise, you will estimate the heritability and perform a pairs bootstrap calculation to get the 95% confidence interval.</p>

<p>This exercise highlights a very important point. Statistical inference (and data analysis in general) is not a plug-n-chug enterprise. You need to think carefully about the questions you are seeking to answer with your data and analyze them appropriately. If you are interested in how heritable traits are, the quantity we defined as the heritability is more apt than the off-the-shelf statistic, the Pearson correlation coefficient.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def heritability(parents, offspring):
    """Compute the heritability from parent and offspring samples."""
    covariance_matrix = np.cov(parents, offspring)
    return covariance_matrix[0,1] / covariance_matrix[0,0]

# Compute the heritability
heritability_scandens = heritability(bd_parent_scandens, bd_offspring_scandens)
heritability_fortis = heritability(bd_parent_fortis, bd_offspring_fortis)

# Acquire 1000 bootstrap replicates of heritability
replicates_scandens = draw_bs_pairs(
        bd_parent_scandens, bd_offspring_scandens, heritability, size=1000)

replicates_fortis = draw_bs_pairs(
        bd_parent_fortis, bd_offspring_fortis, heritability, size=1000)


# Compute 95% confidence intervals
conf_int_scandens = np.percentile(replicates_scandens, [2.5, 97.5])
conf_int_fortis = np.percentile(replicates_fortis, [2.5, 97.5])

# Print results
print('G. scandens:', heritability_scandens, conf_int_scandens)
print('G. fortis:', heritability_fortis, conf_int_fortis)


#   G. scandens: 0.5485340868685982 [0.34395487 0.75638267]
#   G. fortis: 0.7229051911438159 [0.64655013 0.79688342]

</code></pre></div></div>

<p>Here again, we see that
 <em>G. fortis</em>
 has stronger heritability than
 <em>G. scandens</em>
 . This suggests that the traits of
 <em>G. fortis</em>
 may be strongly incorporated into
 <em>G. scandens</em>
 by introgressive hybridization.</p>

<p>####
 Is beak depth heritable at all in G. scandens?</p>

<p>The heritability of beak depth in
 <em>G. scandens</em>
 seems low. It could be that this observed heritability was just achieved by chance and
 <strong>beak depth is actually not really heritable in the species</strong>
 . You will test that hypothesis here. To do this, you will do a pairs permutation test.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Initialize array of replicates: perm_replicates
</span><span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Draw replicates
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="c1"># Permute parent beak depths
</span>    <span class="n">bd_parent_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">bd_parent_scandens</span><span class="p">)</span>
    <span class="n">perm_replicates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">heritability</span><span class="p">(</span><span class="n">bd_parent_permuted</span><span class="p">,</span>
                                      <span class="n">bd_offspring_scandens</span><span class="p">)</span>

<span class="c1"># Compute p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">perm_replicates</span> <span class="o">&gt;=</span> <span class="n">heritability_scandens</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm_replicates</span><span class="p">)</span>

<span class="c1"># Print the p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p-val ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-val = 0.0
</span>
</code></pre></div></div>

<p>You get a p-value of zero, which means that none of the 10,000 permutation pairs replicates you drew had a heritability high enough to match that which was observed. This strongly suggests that beak depth is heritable in
 <em>G. scandens</em>
 , just not as much as in
 <em>G. fortis</em>
 . If you like, you can plot a histogram of the heritability replicates to get a feel for how extreme of a value of heritability you might expect by chance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.hist(perm_replicates)
plt.axvline(x=heritability_scandens, color = 'red')
plt.text(heritability_scandens, 1500, 'heritability_scandens', ha='center', va='center',rotation='vertical', backgroundcolor='white')
plt.show()

</code></pre></div></div>

<h2 id="parameter-estimation-by-optimization-2">Parameter estimation by optimization</h2>

<p>###
 Optimal parameters</p>

<p>####
 How often do we get no-hitters?</p>

<p>The number of games played between each no-hitter in the modern era (1901-2015) of Major League Baseball is stored in the array
 <code class="language-plaintext highlighter-rouge">nohitter_times</code>
 .</p>

<p>If you assume that no-hitters are described as a Poisson process, then the time between no-hitters is Exponentially distributed. As you have seen, the Exponential distribution has a single parameter, which we will call ττ, the typical interval time. The value of the parameter ττ that makes the exponential distribution best match the data is the mean interval time (where time is in units of number of games) between no-hitters.</p>

<p>Compute the value of this parameter from the data. Then, use
 <code class="language-plaintext highlighter-rouge">np.random.exponential()</code>
 to “repeat” the history of Major League Baseball by drawing inter-no-hitter times from an exponential distribution with the ττ you found and plot the histogram as an approximation to the PDF.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Seed random number generator
</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Compute mean no-hitter time: tau
</span><span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">)</span>

<span class="c1"># Draw out of an exponential distribution with parameter tau: inter_nohitter_time
</span><span class="n">inter_nohitter_time</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

<span class="c1"># Plot the PDF and label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">inter_nohitter_time</span><span class="p">,</span>
             <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s">'step'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture-16.png" alt="Desktop View" /></p>

<p>We see the typical shape of the Exponential distribution, going from a maximum at 0 and decaying to the right.</p>

<p>####
 Do the data follow our story?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create an ECDF from real data: x, y
</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">)</span>

<span class="c1"># Create a CDF from theoretical samples: x_theor, y_theor
</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">inter_nohitter_time</span><span class="p">)</span>

<span class="c1"># Overlay the plots
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Margins and axis labels
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'CDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-15.png" alt="Desktop View" /></p>

<p>It looks like no-hitters in the modern era of Major League Baseball are Exponentially distributed. Based on the story of the Exponential distribution, this suggests that they are a random process; when a no-hitter will happen is independent of when the last no-hitter was.</p>

<p>####
 How is this parameter optimal?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the theoretical CDFs
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'CDF'</span><span class="p">)</span>

<span class="c1"># Take samples with half tau: samples_half
</span><span class="n">samples_half</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Take samples with double tau: samples_double
</span><span class="n">samples_double</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Generate CDFs from these samples
</span><span class="n">x_half</span><span class="p">,</span> <span class="n">y_half</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">samples_half</span><span class="p">)</span>
<span class="n">x_double</span><span class="p">,</span> <span class="n">y_double</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">samples_double</span><span class="p">)</span>

<span class="c1"># Plot these CDFs as lines
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_half</span><span class="p">,</span> <span class="n">y_half</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_double</span><span class="p">,</span> <span class="n">y_double</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-14.png" alt="Desktop View" /></p>

<p>red = half, purple = double</p>

<p>Notice how the value of tau given by the mean matches the data best. In this way, tau is an optimal parameter.</p>

<p>###
 Linear regression by least squares</p>

<p>####
 EDA of literacy/fertility data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the illiteracy rate versus fertility
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set the margins and label axes
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'percent illiterate'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Show the Pearson correlation coefficient
</span><span class="k">print</span><span class="p">(</span><span class="n">pearson_r</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">))</span>
<span class="mf">0.8041324026815344</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-13.png" alt="Desktop View" /></p>

<p>You can see the correlation between illiteracy and fertility by eye, and by the substantial Pearson correlation coefficient of 0.8. It is difficult to resolve in the scatter plot, but there are many points around near-zero illiteracy and about 1.8 children/woman.</p>

<p>####
 Linear regression</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the illiteracy rate versus fertility
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'percent illiterate'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>

<span class="c1"># Perform a linear regression using np.polyfit(): a, b
</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the results to the screen
</span><span class="k">print</span><span class="p">(</span><span class="s">'slope ='</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s">'children per woman / percent illiterate'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'intercept ='</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">'children per woman'</span><span class="p">)</span>

<span class="c1"># Make theoretical line to plot
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Add regression line to your plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Draw the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1"># slope = 0.04979854809063423 children per woman / percent illiterate
# intercept = 1.888050610636557 children per woman
</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture4-13.png" alt="Desktop View" /></p>

<p>####
 How is it optimal?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Specify slopes to consider: a_vals
</span><span class="n">a_vals</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="c1"># Initialize sum of square of residuals: rss
</span><span class="n">rss</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a_vals</span><span class="p">)</span>

<span class="c1"># Compute sum of square of residuals for each value of a_vals
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_vals</span><span class="p">):</span>
    <span class="n">rss</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">((</span><span class="n">fertility</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">illiteracy</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Plot the RSS
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">a_vals</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="s">'-'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'slope (children per woman / percent illiterate)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'sum of square of residuals'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture5-11.png" alt="Desktop View" /></p>

<p>Notice that the minimum on the plot, that is the value of the slope that gives the minimum sum of the square of the residuals, is the same value you got when performing the regression.</p>

<p>###
 The importance of EDA: Anscombe’s quartet</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture6-8.png" alt="Desktop View" /></p>

<p>####
 The importance of EDA</p>

<p>Why should exploratory data analysis be the first step in an analysis of data (after getting your data imported and cleaned, of course)?</p>

<ul>
  <li>You can be protected from misinterpretation of the type demonstrated by Anscombe’s quartet.</li>
  <li>EDA provides a good starting point for planning the rest of your analysis.</li>
  <li>EDA is not really any more difficult than any of the subsequent analysis, so there is no excuse for not exploring the data.</li>
</ul>

<p>####
 Linear regression on appropriate Anscombe data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Perform linear regression: a, b
</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the slope and intercept
</span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># Generate theoretical x and y data: x_theor, y_theor
</span><span class="n">x_theor</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
<span class="n">y_theor</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x_theor</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Plot the Anscombe data and theoretical line
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span> <span class="o">=</span> <span class="s">'none'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>

<span class="c1"># Label the axes
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture7-9.png" alt="Desktop View" /></p>

<p>####
 Linear regression on all Anscombe data</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for i in range(4):
    plt.subplot(2,2,i+1)

    # plot the scatter plot
    plt.plot(anscombe_x[i], anscombe_y[i], marker = '.', linestyle = 'none')

    # plot the regression line
    a, b = np.polyfit(anscombe_x[i], anscombe_y[i], deg=1)
    x_theor = np.array([np.min(anscombe_x[i]), np.max(anscombe_x[i])])
    y_theor = a * x_theor + b
    plt.plot(x_theor, y_theor)

    # add label
    plt.xlabel('x' + str(i+1))
    plt.ylabel('y' + str(i+1))

plt.show()

# slope1: 0.5000909090909095 intercept: 3.000090909090909
# slope2: 0.5000000000000004 intercept: 3.0009090909090896
# slope3: 0.4997272727272731 intercept: 3.0024545454545453
# slope4: 0.4999090909090908 intercept: 3.0017272727272735

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture8-6.png" alt="Desktop View" /></p>

<p>###
 Generating bootstrap replicates</p>

<p>####
 Getting the terminology down</p>

<p>If we have a data set with n repeated measurements, a
 <strong>bootstrap sample</strong>
 is an array of length n that was drawn from the original data with replacement.</p>

<p><strong>Bootstrap replicate</strong>
 is a single value of a statistic computed from a bootstrap sample.</p>

<p>####
 Visualizing bootstrap samples</p>

<p>np.random.choice()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for _ in range(50):
    # Generate bootstrap sample: bs_sample
    bs_sample = np.random.choice(rainfall, size=len(rainfall))

    # Compute and plot ECDF from bootstrap sample
    x, y = ecdf(bs_sample)
    _ = plt.plot(x, y, marker='.', linestyle='none',
                 color='gray', alpha=0.1)

# Compute and plot ECDF from original data
x, y = ecdf(rainfall)
_ = plt.plot(x, y, marker='.')

# Make margins and label axes
plt.margins(0.02)
_ = plt.xlabel('yearly rainfall (mm)')
_ = plt.ylabel('ECDF')

# Show the plot
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture9-5.png" alt="Desktop View" /></p>

<h2 id="bootstrap-confidence-intervals-2">Bootstrap confidence intervals</h2>

<p>####
 Generating many bootstrap replicates</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def bootstrap_replicate_1d(data, func):
    return func(np.random.choice(data, size=len(data)))

def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates

</code></pre></div></div>

<p>####
 Bootstrap replicates of the mean and the SEM (
 <strong>standard error of the mean</strong>
 )</p>

<p>In fact, it can be shown theoretically that under not-too-restrictive conditions, the value of the mean will always be Normally distributed. (This does not hold in general, just for the mean and a few other statistics.)</p>

<p>The standard deviation of this distribution, called the
 <strong>standard error of the mean</strong>
 , or SEM, is given by the standard deviation of the data divided by the square root of the number of data points. I.e., for a data set,
 <code class="language-plaintext highlighter-rouge">sem = np.std(data) / np.sqrt(len(data))</code>
 . Using hacker statistics, you get this same result without the need to derive it, but you will verify this result from your bootstrap replicates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Take 10,000 bootstrap replicates of the mean: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">rainfall</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute and print SEM
</span><span class="n">sem</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">rainfall</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rainfall</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">sem</span><span class="p">)</span>

<span class="c1"># Compute and print standard deviation of bootstrap replicates
</span><span class="n">bs_std</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bs_std</span><span class="p">)</span>

<span class="c1"># Make a histogram of the results
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'mean annual rainfall (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 10.51054915050619
# 10.465927071184412
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture10-5.png" alt="Desktop View" /></p>

<p>####
 Confidence intervals of rainfall data</p>

<p>Use the bootstrap replicates you just generated to compute the 95% confidence interval. That is, give the 2.5th and 97.5th percentile of your bootstrap replicates stored as
 <code class="language-plaintext highlighter-rouge">bs_replicates</code>
 . What is the 95% confidence interval?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
np.percentile(bs_replicates,2.5)
779.7699248120301

np.percentile(bs_replicates,97.5)
820.950432330827

</code></pre></div></div>

<p>####
 Bootstrap replicates of other statistics</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_reps(data, func, size=1):
    return np.array([bootstrap_replicate_1d(data, func) for _ in range(size)])

# Generate 10,000 bootstrap replicates of the variance: bs_replicates
bs_replicates = draw_bs_reps(rainfall, np.var, size=10000)

# Put the variance in units of square centimeters
bs_replicates /= 100

# Make a histogram of the results
_ = plt.hist(bs_replicates, bins=50, normed=True)
_ = plt.xlabel('variance of annual rainfall (sq. cm)')
_ = plt.ylabel('PDF')

# Show the plot
plt.show()


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture11-5.png" alt="Desktop View" /></p>

<p>This is not normally distributed, as it has a longer tail to the right. Note that you can also compute a confidence interval on the variance, or any other statistic, using
 <code class="language-plaintext highlighter-rouge">np.percentile()</code>
 with your bootstrap replicates.</p>

<p>####
 Confidence interval on the rate of no-hitters</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Draw bootstrap replicates of the mean no-hitter time (equal to tau): bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute the 95% confidence interval: conf_int
</span><span class="n">conf_int</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">])</span>

<span class="c1"># Print the confidence interval
</span><span class="k">print</span><span class="p">(</span><span class="s">'95% confidence interval ='</span><span class="p">,</span> <span class="n">conf_int</span><span class="p">,</span> <span class="s">'games'</span><span class="p">)</span>

<span class="c1"># Plot the histogram of the replicates
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s">'$\tau$ (games)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 95% confidence interval = [660.67280876 871.63077689] games
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture12-4.png" alt="Desktop View" /></p>

<p>This gives you an estimate of what the typical time between no-hitters is. It could be anywhere between 660 and 870 games.</p>

<p>###
 Pairs bootstrap</p>

<p>####
 A function to do pairs bootstrap</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, deg=1)

    return bs_slope_reps, bs_intercept_reps


</code></pre></div></div>

<p>####
 Pairs bootstrap of literacy/fertility data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Generate replicates of slope and intercept using pairs bootstrap
</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="n">bs_intercept_reps</span> <span class="o">=</span> <span class="n">draw_bs_pairs_linreg</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Compute and print 95% CI for slope
</span><span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">]))</span>

<span class="c1"># Plot the histogram
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'slope'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># [0.04378061 0.0551616 ]
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture13-4.png" alt="Desktop View" /></p>

<p>####
 Plotting bootstrap regressions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Generate array of x-values for bootstrap lines: x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>

<span class="c1"># Plot the bootstrap lines
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                 <span class="n">bs_slope_reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

<span class="c1"># Plot the data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Label axes, set the margins, and show the plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'illiteracy'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture14-3.png" alt="Desktop View" /></p>

<h2 id="introduction-to-hypothesis-testing-2">Introduction to hypothesis testing</h2>

<p>###
 Formulating and simulating a hypothesis</p>

<dl>
  <dt><strong>Null hypothesis</strong></dt>
  <dd>another name for the hypothesis you are testing</dd>
  <dt><strong>Permutation</strong></dt>
  <dd>random reordering of entries in an array</dd>
</dl>

<p>####
 Generating a permutation sample</p>

<p>np.random.permutation()</p>

<p>Permutation sampling is a great way to simulate the hypothesis that two variables have identical probability distributions. This is often a hypothesis you want to test, so in this exercise, you will write a function to generate a permutation sample from two data sets.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def permutation_sample(data1, data2):
    """Generate a permutation sample from two data sets."""

    # Concatenate the data sets: data
    data = np.concatenate((data1, data2))

    # Permute the concatenated array: permuted_data
    permuted_data = np.random.permutation(data)

    # Split the permuted array into two: perm_sample_1, perm_sample_2
    perm_sample_1 = permuted_data[:len(data1)]
    perm_sample_2 = permuted_data[len(data1):]

    return perm_sample_1, perm_sample_2

</code></pre></div></div>

<p>####
 Visualizing permutation sampling</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for _ in range(50):
    # Generate permutation samples
    perm_sample_1, perm_sample_2 = permutation_sample(rain_june, rain_november)


    # Compute ECDFs
    x_1, y_1 = ecdf(perm_sample_1)
    x_2, y_2 = ecdf(perm_sample_2)

    # Plot ECDFs of permutation sample
    _ = plt.plot(x_1, y_1, marker='.', linestyle='none',
                 color='red', alpha=0.02)
    _ = plt.plot(x_2, y_2, marker='.', linestyle='none',
                 color='blue', alpha=0.02)

# Create and plot ECDFs from original data
x_1, y_1 = ecdf(rain_june)
x_2, y_2 = ecdf(rain_november)
_ = plt.plot(x_1, y_1, marker='.', linestyle='none', color='red')
_ = plt.plot(x_2, y_2, marker='.', linestyle='none', color='blue')

# Label axes, set margin, and show plot
plt.margins(0.02)
_ = plt.xlabel('monthly rainfall (mm)')
_ = plt.ylabel('ECDF')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-16.png" alt="Desktop View" /></p>

<p>Notice that the permutation samples ECDFs overlap and give a purple haze. None of the ECDFs from the permutation samples overlap with the observed data, suggesting that the hypothesis is not commensurate with the data. June and November rainfall are not identically distributed.</p>

<p>###
 Test statistics and p-values</p>

<p>####
 Test statistics</p>

<p>When performing hypothesis tests, your choice of test statistic should be pertinent to the question you are seeking to answer in your hypothesis test.</p>

<p>The most important thing to consider is:
 <strong>What are you asking?</strong></p>

<p>####
 What is a p-value?</p>

<p>The p-value is generally a measure of the probability of observing a test statistic equally or more extreme than the one you observed, given that the null hypothesis is true.</p>

<p>####
 Generating permutation replicates</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># In most circumstances, func will be a function you write yourself.
</span><span class="k">def</span> <span class="nf">draw_perm_reps</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s">"""Generate multiple permutation replicates."""</span>

    <span class="c1"># Initialize array of replicates: perm_replicates
</span>    <span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="c1"># Generate permutation sample
</span>        <span class="n">perm_sample_1</span><span class="p">,</span> <span class="n">perm_sample_2</span> <span class="o">=</span> <span class="n">permutation_sample</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">)</span>

        <span class="c1"># Compute the test statistic
</span>        <span class="n">perm_replicates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">perm_sample_1</span><span class="p">,</span> <span class="n">perm_sample_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">perm_replicates</span>

</code></pre></div></div>

<p>####
 Look before you leap: EDA before hypothesis testing</p>

<p>Kleinteich and Gorb (
 <em>Sci. Rep.</em>
 ,
 <strong>4</strong>
 , 5225, 2014) performed an interesting experiment with South American horned frogs. They held a plate connected to a force transducer, along with a bait fly, in front of them. They then measured the impact force and adhesive force of the frog’s tongue when it struck the target.</p>

<p>Frog A is an adult and Frog B is a juvenile. The researchers measured the impact force of 20 strikes for each frog. In the next exercise, we will test the hypothesis that the two frogs have the same distribution of impact forces. But, remember, it is important to do EDA first! Let’s make a bee swarm plot for the data. They are stored in a Pandas data frame,
 <code class="language-plaintext highlighter-rouge">df</code>
 , where column
 <code class="language-plaintext highlighter-rouge">ID</code>
 is the identity of the frog and column
 <code class="language-plaintext highlighter-rouge">impact_force</code>
 is the impact force in Newtons (N).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   ID  impact_force
20  A         1.612
21  A         0.605
22  A         0.327
23  A         0.946
24  A         0.541

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make bee swarm plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">sns</span><span class="p">.</span><span class="n">swarmplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s">'ID'</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s">'impact_force'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'frog'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'impact force (N)'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-15.png" alt="Desktop View" /></p>

<p>Eyeballing it, it does not look like they come from the same distribution. Frog A, the adult, has three or four very hard strikes, and Frog B, the juvenile, has a couple weak ones. However, it is possible that with only 20 samples it might be too difficult to tell if they have difference distributions, so we should proceed with the hypothesis test.</p>

<p>####
 Permutation test on frog data</p>

<p>The average strike force of Frog A was 0.71 Newtons (N), and that of Frog B was 0.42 N for a difference of 0.29 N. It is possible the frogs strike with the same force and this observed difference was by chance. You will compute the probability of getting at least a 0.29 N difference in mean strike force under the hypothesis that the distributions of strike forces for the two frogs are identical. We use a permutation test with a test statistic of the difference of means to test this hypothesis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def diff_of_means(data_1, data_2):
    """Difference in means of two arrays."""

    # The difference of means of data_1, data_2: diff
    diff = np.mean(data_1) - np.mean(data_2)

    return diff

# Compute difference of mean impact force from experiment: empirical_diff_means
empirical_diff_means = diff_of_means(force_a, force_b)

# Draw 10,000 permutation replicates: perm_replicates
perm_replicates = draw_perm_reps(force_a, force_b,
                                 diff_of_means, size=10000)

# Compute p-value: p
p = np.sum(perm_replicates &gt;= empirical_diff_means) / len(perm_replicates)

# Print the result
print('p-value =', p)

# p-value = 0.0063
# p-value = 0.63%

</code></pre></div></div>

<p>The p-value tells you that there is about a 0.6% chance that you would get the difference of means observed in the experiment if frogs were exactly the same.</p>

<p>A p-value below 0.01 is typically said to be “statistically significant,” but: warning! warning! warning! You have computed a p-value; it is a number. I encourage you not to distill it to a yes-or-no phrase. p = 0.006 and p = 0.000000006 are both said to be “statistically significant,” but they are definitely not the same!</p>

<p>###
 Bootstrap hypothesis tests</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-14.png" alt="Desktop View" /></p>

<p>####
 A one-sample bootstrap hypothesis test</p>

<p>Another juvenile frog was studied, Frog C, and you want to see if Frog B and Frog C have similar impact forces. Unfortunately, you do not have Frog C’s impact forces available, but you know they have a mean of 0.55 N. Because you don’t have the original data, you cannot do a permutation test, and you cannot assess the hypothesis that the forces from Frog B and Frog C come from the same distribution. You will therefore test another, less restrictive hypothesis: The mean strike force of Frog B is equal to that of Frog C.</p>

<p>To set up the bootstrap hypothesis test, you will take the mean as our test statistic. Remember, your goal is to calculate the probability of getting a mean impact force less than or equal to what was observed for Frog B
 <em>if the hypothesis that the true mean of Frog B’s impact forces is equal to that of Frog C is true</em>
 . You first translate all of the data of Frog B such that the mean is 0.55 N. This involves adding the mean force of Frog C and subtracting the mean force of Frog B from each measurement of Frog B. This leaves other properties of Frog B’s distribution, such as the variance, unchanged.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make an array of translated impact forces: translated_force_b
</span><span class="n">translated_force_b</span> <span class="o">=</span> <span class="n">force_b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.55</span>

<span class="c1"># Take bootstrap replicates of Frog B's translated impact forces: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">translated_force_b</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute fraction of replicates that are less than the observed Frog B force: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_replicates</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10000</span>

<span class="c1"># Print the p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p = '</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p =  0.0046
# p = 0.46%
</span>
</code></pre></div></div>

<p>The low p-value suggests that the null hypothesis that Frog B and Frog C have the same mean impact force is false.</p>

<p>####
 A two-sample bootstrap hypothesis test for difference of means</p>

<p>We now want to test the hypothesis that Frog A and Frog B have the same mean impact force, but not necessarily the same distribution, which is also impossible with a permutation test.</p>

<p>To do the two-sample bootstrap test, we shift
 <em>both</em>
 arrays to have the same mean, since we are simulating the hypothesis that their means are, in fact, equal. We then draw bootstrap samples out of the shifted arrays and compute the difference in means. This constitutes a bootstrap replicate, and we generate many of them. The p-value is the fraction of replicates with a difference in means greater than or equal to what was observed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute mean of all forces: mean_force
</span><span class="n">mean_force</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">forces_concat</span><span class="p">)</span>

<span class="c1"># Generate shifted arrays
</span><span class="n">force_a_shifted</span> <span class="o">=</span> <span class="n">force_a</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_force</span>
<span class="n">force_b_shifted</span> <span class="o">=</span> <span class="n">force_b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_force</span>

<span class="c1"># Compute 10,000 bootstrap replicates from shifted arrays
</span><span class="n">bs_replicates_a</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">force_a_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_b</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">force_b_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Get replicates of difference of means: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">bs_replicates_a</span> <span class="o">-</span> <span class="n">bs_replicates_b</span>

<span class="c1"># Compute and print p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_replicates</span> <span class="o">&gt;=</span> <span class="n">empirical_diff_means</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="k">print</span><span class="p">(</span><span class="s">'p-value ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-value = 0.0043
# p-value = 0.43%
</span>
</code></pre></div></div>

<p>You got a similar result as when you did the permutation test. Nonetheless, remember that it is important to carefully think about what question you want to ask. Are you only interested in the mean impact force, or in the distribution of impact forces?</p>

<h2 id="hypothesis-test-examples-2">Hypothesis test examples</h2>

<p>###
 A/B testing</p>

<p>####
 The vote for the Civil Rights Act in 1964</p>

<p>The Civil Rights Act of 1964 was one of the most important pieces of legislation ever passed in the USA. Excluding “present” and “abstain” votes, 153 House Democrats and 136 Republicans voted yea. However, 91 Democrats and 35 Republicans voted nay. Did party affiliation make a difference in the vote?</p>

<p>To answer this question, you will evaluate the hypothesis that the party of a House member has no bearing on his or her vote. You will use the fraction of Democrats voting in favor as your test statistic and evaluate the probability of observing a fraction of Democrats voting in favor at least as small as the observed fraction of 153/244. (That’s right, at least as
 <em>small</em>
 as. In 1964, it was the
 <em>Democrats</em>
 who were less progressive on civil rights issues.) To do this, permute the party labels of the House voters and then arbitrarily divide them into “Democrats” and “Republicans” and compute the fraction of Democrats voting yea.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Construct arrays of data: dems, reps
</span><span class="n">dems</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">153</span> <span class="o">+</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">91</span><span class="p">)</span>
<span class="n">reps</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">136</span> <span class="o">+</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">35</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">frac_yea_dems</span><span class="p">(</span><span class="n">dems</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
    <span class="s">"""Compute fraction of Democrat yea votes."""</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">dems</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dems</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">frac</span>

<span class="c1"># Acquire permutation samples: perm_replicates
</span><span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">draw_perm_reps</span><span class="p">(</span><span class="n">dems</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">frac_yea_dems</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute and print p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">perm_replicates</span> <span class="o">&lt;=</span> <span class="mi">153</span><span class="o">/</span><span class="mi">244</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm_replicates</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'p-value ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-value = 0.0002
# p-value = 0.02%
</span>
</code></pre></div></div>

<p>This small p-value suggests that party identity had a lot to do with the voting. Importantly, the South had a higher fraction of Democrat representatives, and consequently also a more racist bias.</p>

<p>####
 What is equivalent?</p>

<p>You have experience matching a stories to probability distributions. Similarly, you use the same procedure for two different A/B tests if their stories match. In the Civil Rights Act example you just did, you performed an A/B test on voting data, which has a Yes/No type of outcome for each subject (in that case, a voter). Which of the following situations involving testing by a web-based company has an equivalent set up for an A/B test as the one you just did with the Civil Rights Act of 1964?</p>

<p>You measure the number of people who click on an ad on your company’s website before and after changing its color.</p>

<p>The “Democrats” are those who view the ad before the color change, and the “Republicans” are those who view it after.</p>

<p>####
 A time-on-website analog</p>

<p>It turns out that you already did a hypothesis test analogous to an A/B test where you are interested in how much time is spent on the website before and after an ad campaign. The frog tongue force (a continuous quantity like time on the website) is an analog. “Before” = Frog A and “after” = Frog B. Let’s practice this again with something that actually is a before/after scenario.</p>

<p>We return to the no-hitter data set. In 1920, Major League Baseball implemented important rule changes that ended the so-called dead ball era. Importantly, the pitcher was no longer allowed to spit on or scuff the ball, an activity that greatly favors pitchers. In this problem you will perform an A/B test to determine if these rule changes resulted in a slower rate of no-hitters (i.e., longer average time between no-hitters) using the difference in mean inter-no-hitter time as your test statistic. The inter-no-hitter times for the respective eras are stored in the arrays
 <code class="language-plaintext highlighter-rouge">nht_dead</code>
 and
 <code class="language-plaintext highlighter-rouge">nht_live</code>
 , where “nht” is meant to stand for “no-hitter time.”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def diff_of_means(data_1, data_2):
    """Difference in means of two arrays."""

    # The difference of means of data_1, data_2: diff
    diff = np.mean(data_1) - np.mean(data_2)

    return diff

def permutation_sample(data1, data2):
    """Generate a permutation sample from two data sets."""

    # Concatenate the data sets: data
    data = np.concatenate((data1, data2))

    # Permute the concatenated array: permuted_data
    permuted_data = np.random.permutation(data)

    # Split the permuted array into two: perm_sample_1, perm_sample_2
    perm_sample_1 = permuted_data[:len(data1)]
    perm_sample_2 = permuted_data[len(data1):]

    return perm_sample_1, perm_sample_2

def draw_perm_reps(data_1, data_2, func, size=1):
    """Generate multiple permutation replicates."""

    # Initialize array of replicates: perm_replicates
    perm_replicates = np.empty(size)

    for i in range(size):
        # Generate permutation sample
        perm_sample_1, perm_sample_2 = permutation_sample(data_1, data_2)

        # Compute the test statistic
        perm_replicates[i] = func(perm_sample_1, perm_sample_2)

    return perm_replicates



# Compute the observed difference in mean inter-no-hitter times: nht_diff_obs
nht_diff_obs = diff_of_means(nht_dead, nht_live)

# Acquire 10,000 permutation replicates of difference in mean no-hitter time: perm_replicates
perm_replicates = draw_perm_reps(nht_dead, nht_live, diff_of_means, size=10000)

# Compute and print the p-value: p
p = np.sum(perm_replicates &lt;= nht_diff_obs) /len(perm_replicates)
print('p-val =', p)

p-val = 0.0001

</code></pre></div></div>

<p>Your p-value is 0.0001, which means that only one out of your 10,000 replicates had a result as extreme as the actual difference between the dead ball and live ball eras. This suggests strong statistical significance. Watch out, though, you could very well have gotten zero replicates that were as extreme as the observed value. This just means that the p-value is quite small, almost certainly smaller than 0.001.</p>

<p>####
 What should you have done first?</p>

<p>That was a nice hypothesis test you just did to check out whether the rule changes in 1920 changed the rate of no-hitters. But what
 <em>should</em>
 you have done with the data first?</p>

<p>Performed EDA, perhaps plotting the ECDFs of inter-no-hitter times in the dead ball and live ball eras.</p>

<p>Always a good idea to do first! I encourage you to go ahead and plot the ECDFs right now. You will see by eye that the null hypothesis that the distributions are the same is almost certainly not true.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create and plot ECDFs
</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nht_dead</span><span class="p">)</span>
<span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nht_live</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>

<span class="c1"># Label axes, set margin, and show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-17.png" alt="Desktop View" /></p>

<p>###
 Test of correlation</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-16.png" alt="Desktop View" /></p>

<p>####
 Simulating a null hypothesis concerning correlation</p>

<p>The observed correlation between female illiteracy and fertility in the data set of 162 countries may just be by chance; the fertility of a given country may actually be totally independent of its illiteracy. You will test this null hypothesis in the next exercise.</p>

<p>To do the test, you need to simulate the data assuming the null hypothesis is true. Of the following choices, which is the best way to to do it?</p>

<p>Answer: Do a permutation test: Permute the illiteracy values but leave the fertility values fixed to generate a new set of (illiteracy, fertility) data.</p>

<p>This exactly simulates the null hypothesis and does so more efficiently than the last option. It is exact because it uses all data and eliminates any correlation because which illiteracy value pairs to which fertility value is shuffled.</p>

<p>Last option: Do a permutation test: Permute both the illiteracy and fertility values to generate a new set of (illiteracy, fertility data). This exactly simulates the null hypothesis and does so more efficiently than the last option. It is exact because it uses all data and eliminates any correlation because which illiteracy value pairs to which fertility value is shuffled.</p>

<p>####
 Hypothesis test on Pearson correlation</p>

<p>The observed correlation between female illiteracy and fertility may just be by chance; the fertility of a given country may actually be totally independent of its illiteracy. You will test this hypothesis. To do so, permute the illiteracy values but leave the fertility values fixed. This simulates the hypothesis that they are totally independent of each other. For each permutation, compute the Pearson correlation coefficient and assess how many of your permutation replicates have a Pearson correlation coefficient greater than the observed one.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def pearson_r(x, y):
    """Compute Pearson correlation coefficient between two arrays."""
    # Compute correlation matrix: corr_mat
    corr_mat = np.corrcoef(x, y)

    # Return entry [0,1]
    return corr_mat[0,1]

# Compute observed correlation: r_obs
r_obs = pearson_r(illiteracy, fertility)

# r_obs = 0.8041324026815344

# Initialize permutation replicates: perm_replicates
perm_replicates = np.empty(10000)

# Draw replicates
for i in range(10000):
    # Permute illiteracy measurments: illiteracy_permuted
    illiteracy_permuted = np.random.permutation(illiteracy)

    # Compute Pearson correlation
    perm_replicates[i] = pearson_r(illiteracy_permuted, fertility)

# Compute p-value: p
p = np.sum(perm_replicates &gt;= r_obs) /len(perm_replicates)
print('p-val =', p)

# p-val = 0.0

</code></pre></div></div>

<p>You got a p-value of zero. In hacker statistics, this means that your p-value is very low, since you never got a single replicate in the 10,000 you took that had a Pearson correlation greater than the observed one. You could try increasing the number of replicates you take to continue to move the upper bound on your p-value lower and lower.</p>

<p>####
 Do neonicotinoid insecticides have unintended consequences?</p>

<p>As a final exercise in hypothesis testing before we put everything together in our case study in the next chapter, you will investigate the effects of neonicotinoid insecticides on bee reproduction. These insecticides are very widely used in the United States to combat aphids and other pests that damage plants.</p>

<p>In a recent study, Straub, et al. (
 <a href="http://dx.doi.org/10.1098/rspb.2016.0506"><em>Proc. Roy. Soc. B</em>
 , 2016</a>
 ) investigated the effects of neonicotinoids on the sperm of pollinating bees. In this and the next exercise, you will study how the pesticide treatment affected the count of live sperm per half milliliter of semen.</p>

<p>First, we will do EDA, as usual. Plot ECDFs of the alive sperm count for untreated bees (stored in the Numpy array
 <code class="language-plaintext highlighter-rouge">control</code>
 ) and bees treated with pesticide (stored in the Numpy array
 <code class="language-plaintext highlighter-rouge">treated</code>
 ).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute x,y values for ECDFs
</span><span class="n">x_control</span><span class="p">,</span> <span class="n">y_control</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">control</span><span class="p">)</span>
<span class="n">x_treated</span><span class="p">,</span> <span class="n">y_treated</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">treated</span><span class="p">)</span>

<span class="c1"># Plot the ECDFs
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_control</span><span class="p">,</span> <span class="n">y_control</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_treated</span><span class="p">,</span> <span class="n">y_treated</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set the margins
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>

<span class="c1"># Add a legend
</span><span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'control'</span><span class="p">,</span> <span class="s">'treated'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Label axes and show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'millions of alive sperm per mL'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-15.png" alt="Desktop View" /></p>

<p>The ECDFs show a pretty clear difference between the treatment and control; treated bees have fewer alive sperm. Let’s now do a hypothesis test in the next exercise.</p>

<p>####
 Bootstrap hypothesis test on bee sperm counts</p>

<p>Now, you will test the following hypothesis:</p>

<p><strong>On average, male bees treated with neonicotinoid insecticide have the same number of active sperm per milliliter of semen than do untreated male bees.</strong></p>

<p>You will use the difference of means as your test statistic.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def bootstrap_replicate_1d(data, func):
    return func(np.random.choice(data, size=len(data)))

def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates


# Compute the difference in mean sperm count: diff_means
diff_means = np.mean(control) - np.mean(treated)

# Compute mean of pooled data: mean_count
mean_count = np.mean(np.concatenate((control, treated)))

# Generate shifted data sets
control_shifted = control - np.mean(control) + mean_count
treated_shifted = treated - np.mean(treated) + mean_count

# Generate bootstrap replicates
bs_reps_control = draw_bs_reps(control_shifted,
                       np.mean, size=10000)
bs_reps_treated = draw_bs_reps(treated_shifted,
                       np.mean, size=10000)

# Get replicates of difference of means: bs_replicates
bs_replicates = bs_reps_control - bs_reps_treated

# Compute and print p-value: p
p = np.sum(bs_replicates &gt;= np.mean(control) - np.mean(treated)) \
            / len(bs_replicates)
print('p-value =', p)

# p-value = 0.0

</code></pre></div></div>

<p>The p-value is small, most likely less than 0.0001, since you never saw a bootstrap replicated with a difference of means at least as extreme as what was observed. In fact, when I did the calculation with 10 million replicates, I got a p-value of
 <code class="language-plaintext highlighter-rouge">2e-05</code></p>

<h2 id="putting-it-all-together-a-case-study-2">Putting it all together: a case study</h2>

<p>###
 Finch beaks and the need for statistics</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture4-14.png" alt="Desktop View" /></p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture5-12.png" alt="Desktop View" /></p>

<p>####
 EDA of beak depths of Darwin’s finches</p>

<p>For your first foray into the Darwin finch data, you will study how the beak depth (the distance, top to bottom, of a closed beak) of the finch species
 <em>Geospiza scandens</em>
 has changed over time. The Grants have noticed some changes of beak geometry depending on the types of seeds available on the island, and they also noticed that there was some interbreeding with another major species on Daphne Major,
 <em>Geospiza fortis</em>
 . These effects can lead to changes in the species over time.</p>

<p>In the next few problems, you will look at the beak depth of
 <em>G. scandens</em>
 on Daphne Major in 1975 and in 2012. To start with, let’s plot all of the beak depth measurements in 1975 and 2012 in a bee swarm plot.</p>

<p>The data are stored in a pandas DataFrame called
 <code class="language-plaintext highlighter-rouge">df</code>
 with columns
 <code class="language-plaintext highlighter-rouge">'year'</code>
 and
 <code class="language-plaintext highlighter-rouge">'beak_depth'</code>
 . The units of beak depth are millimeters (mm).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   beak_depth  year
0         8.4  1975
1         8.8  1975
2         8.4  1975
3         8.0  1975
4         7.9  1975

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create bee swarm plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">sns</span><span class="p">.</span><span class="n">swarmplot</span><span class="p">(</span><span class="s">'year'</span><span class="p">,</span> <span class="s">'beak_depth'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Label the axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'year'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture6-9.png" alt="Desktop View" /></p>

<p>It is kind of hard to see if there is a clear difference between the 1975 and 2012 data set. Eyeballing it, it appears as though the mean of the 2012 data set might be slightly higher, and it might have a bigger variance.</p>

<p>####
 ECDFs of beak depths</p>

<p>While bee swarm plots are useful, we found that ECDFs are often even better when doing EDA. Plot the ECDFs for the 1975 and 2012 beak depth measurements on the same plot.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute ECDFs
</span><span class="n">x_1975</span><span class="p">,</span> <span class="n">y_1975</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">bd_1975</span><span class="p">)</span>
<span class="n">x_2012</span><span class="p">,</span> <span class="n">y_2012</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">bd_2012</span><span class="p">)</span>

<span class="c1"># Plot the ECDFs
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1975</span><span class="p">,</span> <span class="n">y_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2012</span><span class="p">,</span> <span class="n">y_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set margins
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>

<span class="c1"># Add axis labels and legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture7-10.png" alt="Desktop View" /></p>

<p>The differences are much clearer in the ECDF. The mean is larger in the 2012 data, and the variance does appear larger as well.</p>

<p>####
 Parameter estimates of beak depths</p>

<p>Estimate the
 <em>difference</em>
 of the mean beak depth of the
 <em>G. scandens</em>
 samples from 1975 and 2012 and report a 95% confidence interval.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates


# Compute the difference of the sample means: mean_diff
mean_diff = np.mean(bd_2012) - np.mean(bd_1975)

# Get bootstrap replicates of means
bs_replicates_1975 = draw_bs_reps(bd_1975, np.mean, size=10000)
bs_replicates_2012 = draw_bs_reps(bd_2012, np.mean, size=10000)

# Compute samples of difference of means: bs_diff_replicates
bs_diff_replicates = bs_replicates_2012 - bs_replicates_1975

# Compute 95% confidence interval: conf_int
conf_int = np.percentile(bs_diff_replicates, [2.5, 97.5])

# Print the results
print('difference of means =', mean_diff, 'mm')
print('95% confidence interval =', conf_int, 'mm')

# difference of means = 0.22622047244094645 mm
# 95% confidence interval = [0.05633521 0.39190544] mm

</code></pre></div></div>

<p>####
 Hypothesis test: Are beaks deeper in 2012?</p>

<p>Your plot of the ECDF and determination of the confidence interval make it pretty clear that the beaks of
 <em>G. scandens</em>
 on Daphne Major have gotten deeper. But is it possible that this effect is just due to random chance? In other words, what is the probability that we would get the observed difference in mean beak depth if the means were the same?</p>

<p>Be careful! The hypothesis we are testing is
 <em>not</em>
 that the beak depths come from the same distribution. For that we could use a permutation test.
 <strong>The hypothesis is that the means are equal.</strong>
 To perform this hypothesis test, we need to shift the two data sets so that they have the same mean and then use bootstrap sampling to compute the difference of means.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute mean of combined data set: combined_mean
</span><span class="n">combined_mean</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">bd_1975</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">)))</span>

<span class="c1"># Shift the samples
# why shift the mean?
# to make np.mean(bd_1975_shifted) - np.mean(bd_2012_shifted) = 0 #1
# why make #1 = 0?
# because our hypothesis is "beak depth are the same in 1975 and 2012"
</span><span class="n">bd_1975_shifted</span> <span class="o">=</span> <span class="n">bd_1975</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bd_1975</span><span class="p">)</span> <span class="o">+</span> <span class="n">combined_mean</span>
<span class="n">bd_2012_shifted</span> <span class="o">=</span> <span class="n">bd_2012</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bd_2012</span><span class="p">)</span> <span class="o">+</span> <span class="n">combined_mean</span>

<span class="c1"># Get bootstrap replicates of shifted data sets
</span><span class="n">bs_replicates_1975</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">bd_1975_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_2012</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">bd_2012_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute replicates of difference of means: bs_diff_replicates
</span><span class="n">bs_diff_replicates</span> <span class="o">=</span> <span class="n">bs_replicates_2012</span> <span class="o">-</span> <span class="n">bs_replicates_1975</span>

<span class="c1"># Compute the p-value
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_diff_replicates</span> <span class="o">&gt;=</span> <span class="n">mean_diff</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs_diff_replicates</span><span class="p">)</span>

<span class="c1"># Print p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p = 0.0034
# p = 0.34%
</span>
</code></pre></div></div>

<p>We get a p-value of 0.0034, which suggests that there is a statistically significant difference. But remember: it is very important to know how different they are! In the previous exercise, you got a difference of 0.2 mm between the means. You should combine this with the statistical significance. Changing by 0.2 mm in 37 years is substantial by evolutionary standards. If it kept changing at that rate, the beak depth would double in only 400 years.</p>

<p>###
 Variation of beak shapes</p>

<p>####
 EDA of beak length and depth</p>

<p>The beak length data are stored as
 <code class="language-plaintext highlighter-rouge">bl_1975</code>
 and
 <code class="language-plaintext highlighter-rouge">bl_2012</code>
 , again with units of millimeters (mm). You still have the beak depth data stored in
 <code class="language-plaintext highlighter-rouge">bd_1975</code>
 and
 <code class="language-plaintext highlighter-rouge">bd_2012</code>
 . Make scatter plots of beak depth (y-axis) versus beak length (x-axis) for the 1975 and 2012 specimens.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plot of 1975 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_1975</span><span class="p">,</span> <span class="n">bd_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'None'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Make scatter plot of 2012 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_2012</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s">'None'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes and make legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak length (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture8-7.png" alt="Desktop View" /></p>

<p>In looking at the plot, we see that beaks got deeper (the red points are higher up in the y-direction), but not really longer. If anything, they got a bit shorter, since the red dots are to the left of the blue dots. So, it does not look like the beaks kept the same shape; they became shorter and deeper.</p>

<p>####
 Linear regressions</p>

<p>Perform a linear regression for both the 1975 and 2012 data. Then, perform pairs bootstrap estimates for the regression parameters. Report 95% confidence intervals on the slope and intercept of the regression line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, deg=1)

    return bs_slope_reps, bs_intercept_reps


# Compute the linear regressions
slope_1975, intercept_1975 = np.polyfit(bl_1975, bd_1975, deg=1)
slope_2012, intercept_2012 = np.polyfit(bl_2012, bd_2012, deg=1)

# Perform pairs bootstrap for the linear regressions
bs_slope_reps_1975, bs_intercept_reps_1975 = draw_bs_pairs_linreg(bl_1975, bd_1975, size=1000)
bs_slope_reps_2012, bs_intercept_reps_2012 = draw_bs_pairs_linreg(bl_2012, bd_2012, size=1000)

# Compute confidence intervals of slopes
slope_conf_int_1975 = np.percentile(bs_slope_reps_1975, [2.5, 97.5])
slope_conf_int_2012 = np.percentile(bs_slope_reps_2012, [2.5, 97.5])
intercept_conf_int_1975 = np.percentile(bs_intercept_reps_1975, [2.5, 97.5])
intercept_conf_int_2012 = np.percentile(bs_intercept_reps_2012, [2.5, 97.5])


# Print the results
print('1975: slope =', slope_1975,
      'conf int =', slope_conf_int_1975)
print('1975: intercept =', intercept_1975,
      'conf int =', intercept_conf_int_1975)
print('2012: slope =', slope_2012,
      'conf int =', slope_conf_int_2012)
print('2012: intercept =', intercept_2012,
      'conf int =', intercept_conf_int_2012)

#   1975: slope = 0.4652051691605937 conf int = [0.33851226 0.59306491]
#   1975: intercept = 2.3908752365842263 conf int = [0.64892945 4.18037063]
#   2012: slope = 0.462630358835313 conf int = [0.33137479 0.60695527]
#   2012: intercept = 2.977247498236019 conf int = [1.06792753 4.70599387]

</code></pre></div></div>

<p>It looks like they have the same slope, but different intercepts.</p>

<p>####
 Displaying the linear regression results</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plot of 1975 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_1975</span><span class="p">,</span> <span class="n">bd_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Make scatter plot of 2012 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_2012</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes and make legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak length (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>

<span class="c1"># Generate x-values for bootstrap lines: x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">17</span><span class="p">])</span>

<span class="c1"># Plot the bootstrap lines
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bs_slope_reps_1975</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps_1975</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bs_slope_reps_2012</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps_2012</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

<span class="c1"># Draw the plot again
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture9-6.png" alt="Desktop View" /></p>

<p>####
 Beak length to depth ratio</p>

<p>The linear regressions showed interesting information about the beak geometry. The slope was the same in 1975 and 2012, suggesting that for every millimeter gained in beak length, the birds gained about half a millimeter in depth in both years. However, if we are interested in the shape of the beak, we want to compare the
 <em>ratio</em>
 of beak length to beak depth. Let’s make that comparison.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute length-to-depth ratios
</span><span class="n">ratio_1975</span> <span class="o">=</span> <span class="n">bl_1975</span> <span class="o">/</span> <span class="n">bd_1975</span>
<span class="n">ratio_2012</span> <span class="o">=</span> <span class="n">bl_2012</span> <span class="o">/</span> <span class="n">bd_2012</span>

<span class="c1"># Compute means
</span><span class="n">mean_ratio_1975</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratio_1975</span><span class="p">)</span>
<span class="n">mean_ratio_2012</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratio_2012</span><span class="p">)</span>

<span class="c1"># Generate bootstrap replicates of the means
</span><span class="n">bs_replicates_1975</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">ratio_1975</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_2012</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">ratio_2012</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute the 99% confidence intervals
</span><span class="n">conf_int_1975</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates_1975</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">])</span>
<span class="n">conf_int_2012</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates_2012</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">])</span>

<span class="c1"># Print the results
</span><span class="k">print</span><span class="p">(</span><span class="s">'1975: mean ratio ='</span><span class="p">,</span> <span class="n">mean_ratio_1975</span><span class="p">,</span>
      <span class="s">'conf int ='</span><span class="p">,</span> <span class="n">conf_int_1975</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'2012: mean ratio ='</span><span class="p">,</span> <span class="n">mean_ratio_2012</span><span class="p">,</span>
      <span class="s">'conf int ='</span><span class="p">,</span> <span class="n">conf_int_2012</span><span class="p">)</span>

<span class="c1"># 1975: mean ratio = 1.5788823771858533 conf int = [1.55668803 1.60073509]
# 2012: mean ratio = 1.4658342276847767 conf int = [1.44363932 1.48729149]
</span>
</code></pre></div></div>

<p>####
 How different is the ratio?</p>

<p>In the previous exercise, you computed the mean beak length to depth ratio with 99% confidence intervals for 1975 and for 2012. The results of that calculation are shown graphically in the plot accompanying this problem. In addition to these results, what would you say about the ratio of beak length to depth?</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture10-6.png" alt="Desktop View" /></p>

<p>The mean beak length-to-depth ratio decreased by about 0.1, or 7%, from 1975 to 2012. The 99% confidence intervals are not even close to overlapping, so this is a real change. The beak shape changed.</p>

<p>###
 Calculation of heritability</p>

<p>####
 EDA of heritability</p>

<p>The array
 <code class="language-plaintext highlighter-rouge">bd_parent_scandens</code>
 contains the average beak depth (in mm) of two parents of the species
 <code class="language-plaintext highlighter-rouge">G. scandens</code>
 . The array
 <code class="language-plaintext highlighter-rouge">bd_offspring_scandens</code>
 contains the average beak depth of the offspring of the respective parents. The arrays
 <code class="language-plaintext highlighter-rouge">bd_parent_fortis</code>
 and
 <code class="language-plaintext highlighter-rouge">bd_offspring_fortis</code>
 contain the same information about measurements from
 <em>G. fortis</em>
 birds.</p>

<p>Make a scatter plot of the average offspring beak depth (y-axis) versus average parental beak depth (x-axis) for both species. Use the
 <code class="language-plaintext highlighter-rouge">alpha=0.5</code>
 keyword argument to help you see overlapping points.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plots
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bd_parent_fortis</span><span class="p">,</span> <span class="n">bd_offspring_fortis</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bd_parent_scandens</span><span class="p">,</span> <span class="n">bd_offspring_scandens</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'parental beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'offspring beak depth (mm)'</span><span class="p">)</span>

<span class="c1"># Add legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'G. fortis'</span><span class="p">,</span> <span class="s">'G. scandens'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture11-6.png" alt="Desktop View" /></p>

<p>It appears as though there is a stronger correlation in
 <em>G. fortis</em>
 than than in
 <em>G. scandens</em>
 . This suggests that beak depth is more strongly inherited in
 <em>G. fortis</em>
 . We’ll quantify this correlation next.</p>

<p>####
 Correlation of offspring and parental data</p>

<p>In an effort to quantify the correlation between offspring and parent beak depths, we would like to compute statistics, such as the Pearson correlation coefficient, between parents and offspring. To get confidence intervals on this, we need to do a pairs bootstrap.</p>

<p>You have
 <a href="https://campus.datacamp.com/courses/statistical-thinking-in-python-part-2/bootstrap-confidence-intervals?ex=12">already written</a>
 a function to do pairs bootstrap to get estimates for parameters derived from linear regression. Your task in this exercise is to make a new function with call signature
 <code class="language-plaintext highlighter-rouge">draw_bs_pairs(x, y, func, size=1)</code>
 that performs pairs bootstrap and computes a single statistic on pairs samples defined. The statistic of interest is computed by calling
 <code class="language-plaintext highlighter-rouge">func(bs_x, bs_y)</code>
 . In the next exercise, you will use
 <code class="language-plaintext highlighter-rouge">pearson_r</code>
 for
 <code class="language-plaintext highlighter-rouge">func</code>
 .</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs(x, y, func, size=1):
    """Perform pairs bootstrap for a single statistic."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_replicates[i] = func(bs_x, bs_y)

    return bs_replicates


</code></pre></div></div>

<p>####
 Pearson correlation of offspring and parental data</p>

<p>The Pearson correlation coefficient seems like a useful measure of how strongly the beak depth of parents are inherited by their offspring. Compute the Pearson correlation coefficient between parental and offspring beak depths for
 <em>G. scandens</em>
 . Do the same for
 <em>G. fortis</em>
 . Then, use the function you wrote in the last exercise to compute a 95% confidence interval using pairs bootstrap.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def pearson_r(x, y):
    """Compute Pearson correlation coefficient between two arrays."""
    # Compute correlation matrix: corr_mat
    corr_mat = np.corrcoef(x, y)

    # Return entry [0,1]
    return corr_mat[0,1]


# Compute the Pearson correlation coefficients
r_scandens = pearson_r(bd_parent_scandens, bd_offspring_scandens)
r_fortis = pearson_r(bd_parent_fortis, bd_offspring_fortis)

# Acquire 1000 bootstrap replicates of Pearson r
bs_replicates_scandens = draw_bs_pairs(bd_parent_scandens, bd_offspring_scandens, pearson_r, size=1000)

bs_replicates_fortis = draw_bs_pairs(bd_parent_fortis, bd_offspring_fortis, pearson_r, size=1000)


# Compute 95% confidence intervals
conf_int_scandens = np.percentile(bs_replicates_scandens, [2.5, 97.5])
conf_int_fortis = np.percentile(bs_replicates_fortis, [2.5, 97.5])

# Print results
print('G. scandens:', r_scandens, conf_int_scandens)
print('G. fortis:', r_fortis, conf_int_fortis)

#    G. scandens: 0.4117063629401258 [0.26564228 0.54388972]
#    G. fortis: 0.7283412395518487 [0.6694112  0.77840616]

</code></pre></div></div>

<p>It is clear from the confidence intervals that beak depth of the offspring of
 <em>G. fortis</em>
 parents is more strongly correlated with their offspring than their
 <em>G. scandens</em>
 counterparts.</p>

<p>####
 Measuring heritability</p>

<p>Remember that the Pearson correlation coefficient is the ratio of the covariance to the geometric mean of the variances of the two data sets. This is a measure of the correlation between parents and offspring, but might not be the best estimate of heritability. If we stop and think, it makes more sense to define heritability as the ratio of the covariance between parent and offspring to the
 <em>variance of the parents alone</em>
 . In this exercise, you will estimate the heritability and perform a pairs bootstrap calculation to get the 95% confidence interval.</p>

<p>This exercise highlights a very important point. Statistical inference (and data analysis in general) is not a plug-n-chug enterprise. You need to think carefully about the questions you are seeking to answer with your data and analyze them appropriately. If you are interested in how heritable traits are, the quantity we defined as the heritability is more apt than the off-the-shelf statistic, the Pearson correlation coefficient.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def heritability(parents, offspring):
    """Compute the heritability from parent and offspring samples."""
    covariance_matrix = np.cov(parents, offspring)
    return covariance_matrix[0,1] / covariance_matrix[0,0]

# Compute the heritability
heritability_scandens = heritability(bd_parent_scandens, bd_offspring_scandens)
heritability_fortis = heritability(bd_parent_fortis, bd_offspring_fortis)

# Acquire 1000 bootstrap replicates of heritability
replicates_scandens = draw_bs_pairs(
        bd_parent_scandens, bd_offspring_scandens, heritability, size=1000)

replicates_fortis = draw_bs_pairs(
        bd_parent_fortis, bd_offspring_fortis, heritability, size=1000)


# Compute 95% confidence intervals
conf_int_scandens = np.percentile(replicates_scandens, [2.5, 97.5])
conf_int_fortis = np.percentile(replicates_fortis, [2.5, 97.5])

# Print results
print('G. scandens:', heritability_scandens, conf_int_scandens)
print('G. fortis:', heritability_fortis, conf_int_fortis)


#   G. scandens: 0.5485340868685982 [0.34395487 0.75638267]
#   G. fortis: 0.7229051911438159 [0.64655013 0.79688342]

</code></pre></div></div>

<p>Here again, we see that
 <em>G. fortis</em>
 has stronger heritability than
 <em>G. scandens</em>
 . This suggests that the traits of
 <em>G. fortis</em>
 may be strongly incorporated into
 <em>G. scandens</em>
 by introgressive hybridization.</p>

<p>####
 Is beak depth heritable at all in G. scandens?</p>

<p>The heritability of beak depth in
 <em>G. scandens</em>
 seems low. It could be that this observed heritability was just achieved by chance and
 <strong>beak depth is actually not really heritable in the species</strong>
 . You will test that hypothesis here. To do this, you will do a pairs permutation test.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Initialize array of replicates: perm_replicates
</span><span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Draw replicates
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="c1"># Permute parent beak depths
</span>    <span class="n">bd_parent_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">bd_parent_scandens</span><span class="p">)</span>
    <span class="n">perm_replicates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">heritability</span><span class="p">(</span><span class="n">bd_parent_permuted</span><span class="p">,</span>
                                      <span class="n">bd_offspring_scandens</span><span class="p">)</span>

<span class="c1"># Compute p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">perm_replicates</span> <span class="o">&gt;=</span> <span class="n">heritability_scandens</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm_replicates</span><span class="p">)</span>

<span class="c1"># Print the p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p-val ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-val = 0.0
</span>
</code></pre></div></div>

<p>You get a p-value of zero, which means that none of the 10,000 permutation pairs replicates you drew had a heritability high enough to match that which was observed. This strongly suggests that beak depth is heritable in
 <em>G. scandens</em>
 , just not as much as in
 <em>G. fortis</em>
 . If you like, you can plot a histogram of the heritability replicates to get a feel for how extreme of a value of heritability you might expect by chance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.hist(perm_replicates)
plt.axvline(x=heritability_scandens, color = 'red')
plt.text(heritability_scandens, 1500, 'heritability_scandens', ha='center', va='center',rotation='vertical', backgroundcolor='white')
plt.show()

</code></pre></div></div>

<h2 id="parameter-estimation-by-optimization-3">Parameter estimation by optimization</h2>

<p>###
 Optimal parameters</p>

<p>####
 How often do we get no-hitters?</p>

<p>The number of games played between each no-hitter in the modern era (1901-2015) of Major League Baseball is stored in the array
 <code class="language-plaintext highlighter-rouge">nohitter_times</code>
 .</p>

<p>If you assume that no-hitters are described as a Poisson process, then the time between no-hitters is Exponentially distributed. As you have seen, the Exponential distribution has a single parameter, which we will call ττ, the typical interval time. The value of the parameter ττ that makes the exponential distribution best match the data is the mean interval time (where time is in units of number of games) between no-hitters.</p>

<p>Compute the value of this parameter from the data. Then, use
 <code class="language-plaintext highlighter-rouge">np.random.exponential()</code>
 to “repeat” the history of Major League Baseball by drawing inter-no-hitter times from an exponential distribution with the ττ you found and plot the histogram as an approximation to the PDF.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Seed random number generator
</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Compute mean no-hitter time: tau
</span><span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">)</span>

<span class="c1"># Draw out of an exponential distribution with parameter tau: inter_nohitter_time
</span><span class="n">inter_nohitter_time</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

<span class="c1"># Plot the PDF and label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">inter_nohitter_time</span><span class="p">,</span>
             <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s">'step'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture-16.png" alt="Desktop View" /></p>

<p>We see the typical shape of the Exponential distribution, going from a maximum at 0 and decaying to the right.</p>

<p>####
 Do the data follow our story?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create an ECDF from real data: x, y
</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">)</span>

<span class="c1"># Create a CDF from theoretical samples: x_theor, y_theor
</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">inter_nohitter_time</span><span class="p">)</span>

<span class="c1"># Overlay the plots
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Margins and axis labels
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'CDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-15.png" alt="Desktop View" /></p>

<p>It looks like no-hitters in the modern era of Major League Baseball are Exponentially distributed. Based on the story of the Exponential distribution, this suggests that they are a random process; when a no-hitter will happen is independent of when the last no-hitter was.</p>

<p>####
 How is this parameter optimal?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the theoretical CDFs
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'CDF'</span><span class="p">)</span>

<span class="c1"># Take samples with half tau: samples_half
</span><span class="n">samples_half</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Take samples with double tau: samples_double
</span><span class="n">samples_double</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Generate CDFs from these samples
</span><span class="n">x_half</span><span class="p">,</span> <span class="n">y_half</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">samples_half</span><span class="p">)</span>
<span class="n">x_double</span><span class="p">,</span> <span class="n">y_double</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">samples_double</span><span class="p">)</span>

<span class="c1"># Plot these CDFs as lines
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_half</span><span class="p">,</span> <span class="n">y_half</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_double</span><span class="p">,</span> <span class="n">y_double</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-14.png" alt="Desktop View" /></p>

<p>red = half, purple = double</p>

<p>Notice how the value of tau given by the mean matches the data best. In this way, tau is an optimal parameter.</p>

<p>###
 Linear regression by least squares</p>

<p>####
 EDA of literacy/fertility data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the illiteracy rate versus fertility
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set the margins and label axes
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'percent illiterate'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Show the Pearson correlation coefficient
</span><span class="k">print</span><span class="p">(</span><span class="n">pearson_r</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">))</span>
<span class="mf">0.8041324026815344</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-13.png" alt="Desktop View" /></p>

<p>You can see the correlation between illiteracy and fertility by eye, and by the substantial Pearson correlation coefficient of 0.8. It is difficult to resolve in the scatter plot, but there are many points around near-zero illiteracy and about 1.8 children/woman.</p>

<p>####
 Linear regression</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the illiteracy rate versus fertility
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'percent illiterate'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>

<span class="c1"># Perform a linear regression using np.polyfit(): a, b
</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the results to the screen
</span><span class="k">print</span><span class="p">(</span><span class="s">'slope ='</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s">'children per woman / percent illiterate'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'intercept ='</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">'children per woman'</span><span class="p">)</span>

<span class="c1"># Make theoretical line to plot
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Add regression line to your plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Draw the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1"># slope = 0.04979854809063423 children per woman / percent illiterate
# intercept = 1.888050610636557 children per woman
</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture4-13.png" alt="Desktop View" /></p>

<p>####
 How is it optimal?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Specify slopes to consider: a_vals
</span><span class="n">a_vals</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="c1"># Initialize sum of square of residuals: rss
</span><span class="n">rss</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a_vals</span><span class="p">)</span>

<span class="c1"># Compute sum of square of residuals for each value of a_vals
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_vals</span><span class="p">):</span>
    <span class="n">rss</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">((</span><span class="n">fertility</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">illiteracy</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Plot the RSS
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">a_vals</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="s">'-'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'slope (children per woman / percent illiterate)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'sum of square of residuals'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture5-11.png" alt="Desktop View" /></p>

<p>Notice that the minimum on the plot, that is the value of the slope that gives the minimum sum of the square of the residuals, is the same value you got when performing the regression.</p>

<p>###
 The importance of EDA: Anscombe’s quartet</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture6-8.png" alt="Desktop View" /></p>

<p>####
 The importance of EDA</p>

<p>Why should exploratory data analysis be the first step in an analysis of data (after getting your data imported and cleaned, of course)?</p>

<ul>
  <li>You can be protected from misinterpretation of the type demonstrated by Anscombe’s quartet.</li>
  <li>EDA provides a good starting point for planning the rest of your analysis.</li>
  <li>EDA is not really any more difficult than any of the subsequent analysis, so there is no excuse for not exploring the data.</li>
</ul>

<p>####
 Linear regression on appropriate Anscombe data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Perform linear regression: a, b
</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the slope and intercept
</span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># Generate theoretical x and y data: x_theor, y_theor
</span><span class="n">x_theor</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
<span class="n">y_theor</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x_theor</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Plot the Anscombe data and theoretical line
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span> <span class="o">=</span> <span class="s">'none'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>

<span class="c1"># Label the axes
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture7-9.png" alt="Desktop View" /></p>

<p>####
 Linear regression on all Anscombe data</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for i in range(4):
    plt.subplot(2,2,i+1)

    # plot the scatter plot
    plt.plot(anscombe_x[i], anscombe_y[i], marker = '.', linestyle = 'none')

    # plot the regression line
    a, b = np.polyfit(anscombe_x[i], anscombe_y[i], deg=1)
    x_theor = np.array([np.min(anscombe_x[i]), np.max(anscombe_x[i])])
    y_theor = a * x_theor + b
    plt.plot(x_theor, y_theor)

    # add label
    plt.xlabel('x' + str(i+1))
    plt.ylabel('y' + str(i+1))

plt.show()

# slope1: 0.5000909090909095 intercept: 3.000090909090909
# slope2: 0.5000000000000004 intercept: 3.0009090909090896
# slope3: 0.4997272727272731 intercept: 3.0024545454545453
# slope4: 0.4999090909090908 intercept: 3.0017272727272735

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture8-6.png" alt="Desktop View" /></p>

<p>###
 Generating bootstrap replicates</p>

<p>####
 Getting the terminology down</p>

<p>If we have a data set with n repeated measurements, a
 <strong>bootstrap sample</strong>
 is an array of length n that was drawn from the original data with replacement.</p>

<p><strong>Bootstrap replicate</strong>
 is a single value of a statistic computed from a bootstrap sample.</p>

<p>####
 Visualizing bootstrap samples</p>

<p>np.random.choice()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for _ in range(50):
    # Generate bootstrap sample: bs_sample
    bs_sample = np.random.choice(rainfall, size=len(rainfall))

    # Compute and plot ECDF from bootstrap sample
    x, y = ecdf(bs_sample)
    _ = plt.plot(x, y, marker='.', linestyle='none',
                 color='gray', alpha=0.1)

# Compute and plot ECDF from original data
x, y = ecdf(rainfall)
_ = plt.plot(x, y, marker='.')

# Make margins and label axes
plt.margins(0.02)
_ = plt.xlabel('yearly rainfall (mm)')
_ = plt.ylabel('ECDF')

# Show the plot
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture9-5.png" alt="Desktop View" /></p>

<h2 id="bootstrap-confidence-intervals-3">Bootstrap confidence intervals</h2>

<p>####
 Generating many bootstrap replicates</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def bootstrap_replicate_1d(data, func):
    return func(np.random.choice(data, size=len(data)))

def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates

</code></pre></div></div>

<p>####
 Bootstrap replicates of the mean and the SEM (
 <strong>standard error of the mean</strong>
 )</p>

<p>In fact, it can be shown theoretically that under not-too-restrictive conditions, the value of the mean will always be Normally distributed. (This does not hold in general, just for the mean and a few other statistics.)</p>

<p>The standard deviation of this distribution, called the
 <strong>standard error of the mean</strong>
 , or SEM, is given by the standard deviation of the data divided by the square root of the number of data points. I.e., for a data set,
 <code class="language-plaintext highlighter-rouge">sem = np.std(data) / np.sqrt(len(data))</code>
 . Using hacker statistics, you get this same result without the need to derive it, but you will verify this result from your bootstrap replicates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Take 10,000 bootstrap replicates of the mean: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">rainfall</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute and print SEM
</span><span class="n">sem</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">rainfall</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rainfall</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">sem</span><span class="p">)</span>

<span class="c1"># Compute and print standard deviation of bootstrap replicates
</span><span class="n">bs_std</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bs_std</span><span class="p">)</span>

<span class="c1"># Make a histogram of the results
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'mean annual rainfall (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 10.51054915050619
# 10.465927071184412
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture10-5.png" alt="Desktop View" /></p>

<p>####
 Confidence intervals of rainfall data</p>

<p>Use the bootstrap replicates you just generated to compute the 95% confidence interval. That is, give the 2.5th and 97.5th percentile of your bootstrap replicates stored as
 <code class="language-plaintext highlighter-rouge">bs_replicates</code>
 . What is the 95% confidence interval?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
np.percentile(bs_replicates,2.5)
779.7699248120301

np.percentile(bs_replicates,97.5)
820.950432330827

</code></pre></div></div>

<p>####
 Bootstrap replicates of other statistics</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_reps(data, func, size=1):
    return np.array([bootstrap_replicate_1d(data, func) for _ in range(size)])

# Generate 10,000 bootstrap replicates of the variance: bs_replicates
bs_replicates = draw_bs_reps(rainfall, np.var, size=10000)

# Put the variance in units of square centimeters
bs_replicates /= 100

# Make a histogram of the results
_ = plt.hist(bs_replicates, bins=50, normed=True)
_ = plt.xlabel('variance of annual rainfall (sq. cm)')
_ = plt.ylabel('PDF')

# Show the plot
plt.show()


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture11-5.png" alt="Desktop View" /></p>

<p>This is not normally distributed, as it has a longer tail to the right. Note that you can also compute a confidence interval on the variance, or any other statistic, using
 <code class="language-plaintext highlighter-rouge">np.percentile()</code>
 with your bootstrap replicates.</p>

<p>####
 Confidence interval on the rate of no-hitters</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Draw bootstrap replicates of the mean no-hitter time (equal to tau): bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute the 95% confidence interval: conf_int
</span><span class="n">conf_int</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">])</span>

<span class="c1"># Print the confidence interval
</span><span class="k">print</span><span class="p">(</span><span class="s">'95% confidence interval ='</span><span class="p">,</span> <span class="n">conf_int</span><span class="p">,</span> <span class="s">'games'</span><span class="p">)</span>

<span class="c1"># Plot the histogram of the replicates
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s">'$\tau$ (games)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 95% confidence interval = [660.67280876 871.63077689] games
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture12-4.png" alt="Desktop View" /></p>

<p>This gives you an estimate of what the typical time between no-hitters is. It could be anywhere between 660 and 870 games.</p>

<p>###
 Pairs bootstrap</p>

<p>####
 A function to do pairs bootstrap</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, deg=1)

    return bs_slope_reps, bs_intercept_reps


</code></pre></div></div>

<p>####
 Pairs bootstrap of literacy/fertility data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Generate replicates of slope and intercept using pairs bootstrap
</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="n">bs_intercept_reps</span> <span class="o">=</span> <span class="n">draw_bs_pairs_linreg</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Compute and print 95% CI for slope
</span><span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">]))</span>

<span class="c1"># Plot the histogram
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'slope'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># [0.04378061 0.0551616 ]
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture13-4.png" alt="Desktop View" /></p>

<p>####
 Plotting bootstrap regressions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Generate array of x-values for bootstrap lines: x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>

<span class="c1"># Plot the bootstrap lines
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                 <span class="n">bs_slope_reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

<span class="c1"># Plot the data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Label axes, set the margins, and show the plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'illiteracy'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture14-3.png" alt="Desktop View" /></p>

<h2 id="introduction-to-hypothesis-testing-3">Introduction to hypothesis testing</h2>

<p>###
 Formulating and simulating a hypothesis</p>

<dl>
  <dt><strong>Null hypothesis</strong></dt>
  <dd>another name for the hypothesis you are testing</dd>
  <dt><strong>Permutation</strong></dt>
  <dd>random reordering of entries in an array</dd>
</dl>

<p>####
 Generating a permutation sample</p>

<p>np.random.permutation()</p>

<p>Permutation sampling is a great way to simulate the hypothesis that two variables have identical probability distributions. This is often a hypothesis you want to test, so in this exercise, you will write a function to generate a permutation sample from two data sets.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def permutation_sample(data1, data2):
    """Generate a permutation sample from two data sets."""

    # Concatenate the data sets: data
    data = np.concatenate((data1, data2))

    # Permute the concatenated array: permuted_data
    permuted_data = np.random.permutation(data)

    # Split the permuted array into two: perm_sample_1, perm_sample_2
    perm_sample_1 = permuted_data[:len(data1)]
    perm_sample_2 = permuted_data[len(data1):]

    return perm_sample_1, perm_sample_2

</code></pre></div></div>

<p>####
 Visualizing permutation sampling</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for _ in range(50):
    # Generate permutation samples
    perm_sample_1, perm_sample_2 = permutation_sample(rain_june, rain_november)


    # Compute ECDFs
    x_1, y_1 = ecdf(perm_sample_1)
    x_2, y_2 = ecdf(perm_sample_2)

    # Plot ECDFs of permutation sample
    _ = plt.plot(x_1, y_1, marker='.', linestyle='none',
                 color='red', alpha=0.02)
    _ = plt.plot(x_2, y_2, marker='.', linestyle='none',
                 color='blue', alpha=0.02)

# Create and plot ECDFs from original data
x_1, y_1 = ecdf(rain_june)
x_2, y_2 = ecdf(rain_november)
_ = plt.plot(x_1, y_1, marker='.', linestyle='none', color='red')
_ = plt.plot(x_2, y_2, marker='.', linestyle='none', color='blue')

# Label axes, set margin, and show plot
plt.margins(0.02)
_ = plt.xlabel('monthly rainfall (mm)')
_ = plt.ylabel('ECDF')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-16.png" alt="Desktop View" /></p>

<p>Notice that the permutation samples ECDFs overlap and give a purple haze. None of the ECDFs from the permutation samples overlap with the observed data, suggesting that the hypothesis is not commensurate with the data. June and November rainfall are not identically distributed.</p>

<p>###
 Test statistics and p-values</p>

<p>####
 Test statistics</p>

<p>When performing hypothesis tests, your choice of test statistic should be pertinent to the question you are seeking to answer in your hypothesis test.</p>

<p>The most important thing to consider is:
 <strong>What are you asking?</strong></p>

<p>####
 What is a p-value?</p>

<p>The p-value is generally a measure of the probability of observing a test statistic equally or more extreme than the one you observed, given that the null hypothesis is true.</p>

<p>####
 Generating permutation replicates</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># In most circumstances, func will be a function you write yourself.
</span><span class="k">def</span> <span class="nf">draw_perm_reps</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s">"""Generate multiple permutation replicates."""</span>

    <span class="c1"># Initialize array of replicates: perm_replicates
</span>    <span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="c1"># Generate permutation sample
</span>        <span class="n">perm_sample_1</span><span class="p">,</span> <span class="n">perm_sample_2</span> <span class="o">=</span> <span class="n">permutation_sample</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">)</span>

        <span class="c1"># Compute the test statistic
</span>        <span class="n">perm_replicates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">perm_sample_1</span><span class="p">,</span> <span class="n">perm_sample_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">perm_replicates</span>

</code></pre></div></div>

<p>####
 Look before you leap: EDA before hypothesis testing</p>

<p>Kleinteich and Gorb (
 <em>Sci. Rep.</em>
 ,
 <strong>4</strong>
 , 5225, 2014) performed an interesting experiment with South American horned frogs. They held a plate connected to a force transducer, along with a bait fly, in front of them. They then measured the impact force and adhesive force of the frog’s tongue when it struck the target.</p>

<p>Frog A is an adult and Frog B is a juvenile. The researchers measured the impact force of 20 strikes for each frog. In the next exercise, we will test the hypothesis that the two frogs have the same distribution of impact forces. But, remember, it is important to do EDA first! Let’s make a bee swarm plot for the data. They are stored in a Pandas data frame,
 <code class="language-plaintext highlighter-rouge">df</code>
 , where column
 <code class="language-plaintext highlighter-rouge">ID</code>
 is the identity of the frog and column
 <code class="language-plaintext highlighter-rouge">impact_force</code>
 is the impact force in Newtons (N).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   ID  impact_force
20  A         1.612
21  A         0.605
22  A         0.327
23  A         0.946
24  A         0.541

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make bee swarm plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">sns</span><span class="p">.</span><span class="n">swarmplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s">'ID'</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s">'impact_force'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'frog'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'impact force (N)'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-15.png" alt="Desktop View" /></p>

<p>Eyeballing it, it does not look like they come from the same distribution. Frog A, the adult, has three or four very hard strikes, and Frog B, the juvenile, has a couple weak ones. However, it is possible that with only 20 samples it might be too difficult to tell if they have difference distributions, so we should proceed with the hypothesis test.</p>

<p>####
 Permutation test on frog data</p>

<p>The average strike force of Frog A was 0.71 Newtons (N), and that of Frog B was 0.42 N for a difference of 0.29 N. It is possible the frogs strike with the same force and this observed difference was by chance. You will compute the probability of getting at least a 0.29 N difference in mean strike force under the hypothesis that the distributions of strike forces for the two frogs are identical. We use a permutation test with a test statistic of the difference of means to test this hypothesis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def diff_of_means(data_1, data_2):
    """Difference in means of two arrays."""

    # The difference of means of data_1, data_2: diff
    diff = np.mean(data_1) - np.mean(data_2)

    return diff

# Compute difference of mean impact force from experiment: empirical_diff_means
empirical_diff_means = diff_of_means(force_a, force_b)

# Draw 10,000 permutation replicates: perm_replicates
perm_replicates = draw_perm_reps(force_a, force_b,
                                 diff_of_means, size=10000)

# Compute p-value: p
p = np.sum(perm_replicates &gt;= empirical_diff_means) / len(perm_replicates)

# Print the result
print('p-value =', p)

# p-value = 0.0063
# p-value = 0.63%

</code></pre></div></div>

<p>The p-value tells you that there is about a 0.6% chance that you would get the difference of means observed in the experiment if frogs were exactly the same.</p>

<p>A p-value below 0.01 is typically said to be “statistically significant,” but: warning! warning! warning! You have computed a p-value; it is a number. I encourage you not to distill it to a yes-or-no phrase. p = 0.006 and p = 0.000000006 are both said to be “statistically significant,” but they are definitely not the same!</p>

<p>###
 Bootstrap hypothesis tests</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-14.png" alt="Desktop View" /></p>

<p>####
 A one-sample bootstrap hypothesis test</p>

<p>Another juvenile frog was studied, Frog C, and you want to see if Frog B and Frog C have similar impact forces. Unfortunately, you do not have Frog C’s impact forces available, but you know they have a mean of 0.55 N. Because you don’t have the original data, you cannot do a permutation test, and you cannot assess the hypothesis that the forces from Frog B and Frog C come from the same distribution. You will therefore test another, less restrictive hypothesis: The mean strike force of Frog B is equal to that of Frog C.</p>

<p>To set up the bootstrap hypothesis test, you will take the mean as our test statistic. Remember, your goal is to calculate the probability of getting a mean impact force less than or equal to what was observed for Frog B
 <em>if the hypothesis that the true mean of Frog B’s impact forces is equal to that of Frog C is true</em>
 . You first translate all of the data of Frog B such that the mean is 0.55 N. This involves adding the mean force of Frog C and subtracting the mean force of Frog B from each measurement of Frog B. This leaves other properties of Frog B’s distribution, such as the variance, unchanged.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make an array of translated impact forces: translated_force_b
</span><span class="n">translated_force_b</span> <span class="o">=</span> <span class="n">force_b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.55</span>

<span class="c1"># Take bootstrap replicates of Frog B's translated impact forces: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">translated_force_b</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute fraction of replicates that are less than the observed Frog B force: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_replicates</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10000</span>

<span class="c1"># Print the p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p = '</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p =  0.0046
# p = 0.46%
</span>
</code></pre></div></div>

<p>The low p-value suggests that the null hypothesis that Frog B and Frog C have the same mean impact force is false.</p>

<p>####
 A two-sample bootstrap hypothesis test for difference of means</p>

<p>We now want to test the hypothesis that Frog A and Frog B have the same mean impact force, but not necessarily the same distribution, which is also impossible with a permutation test.</p>

<p>To do the two-sample bootstrap test, we shift
 <em>both</em>
 arrays to have the same mean, since we are simulating the hypothesis that their means are, in fact, equal. We then draw bootstrap samples out of the shifted arrays and compute the difference in means. This constitutes a bootstrap replicate, and we generate many of them. The p-value is the fraction of replicates with a difference in means greater than or equal to what was observed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute mean of all forces: mean_force
</span><span class="n">mean_force</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">forces_concat</span><span class="p">)</span>

<span class="c1"># Generate shifted arrays
</span><span class="n">force_a_shifted</span> <span class="o">=</span> <span class="n">force_a</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_force</span>
<span class="n">force_b_shifted</span> <span class="o">=</span> <span class="n">force_b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_force</span>

<span class="c1"># Compute 10,000 bootstrap replicates from shifted arrays
</span><span class="n">bs_replicates_a</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">force_a_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_b</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">force_b_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Get replicates of difference of means: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">bs_replicates_a</span> <span class="o">-</span> <span class="n">bs_replicates_b</span>

<span class="c1"># Compute and print p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_replicates</span> <span class="o">&gt;=</span> <span class="n">empirical_diff_means</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="k">print</span><span class="p">(</span><span class="s">'p-value ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-value = 0.0043
# p-value = 0.43%
</span>
</code></pre></div></div>

<p>You got a similar result as when you did the permutation test. Nonetheless, remember that it is important to carefully think about what question you want to ask. Are you only interested in the mean impact force, or in the distribution of impact forces?</p>

<h2 id="hypothesis-test-examples-3">Hypothesis test examples</h2>

<p>###
 A/B testing</p>

<p>####
 The vote for the Civil Rights Act in 1964</p>

<p>The Civil Rights Act of 1964 was one of the most important pieces of legislation ever passed in the USA. Excluding “present” and “abstain” votes, 153 House Democrats and 136 Republicans voted yea. However, 91 Democrats and 35 Republicans voted nay. Did party affiliation make a difference in the vote?</p>

<p>To answer this question, you will evaluate the hypothesis that the party of a House member has no bearing on his or her vote. You will use the fraction of Democrats voting in favor as your test statistic and evaluate the probability of observing a fraction of Democrats voting in favor at least as small as the observed fraction of 153/244. (That’s right, at least as
 <em>small</em>
 as. In 1964, it was the
 <em>Democrats</em>
 who were less progressive on civil rights issues.) To do this, permute the party labels of the House voters and then arbitrarily divide them into “Democrats” and “Republicans” and compute the fraction of Democrats voting yea.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Construct arrays of data: dems, reps
</span><span class="n">dems</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">153</span> <span class="o">+</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">91</span><span class="p">)</span>
<span class="n">reps</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">136</span> <span class="o">+</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">35</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">frac_yea_dems</span><span class="p">(</span><span class="n">dems</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
    <span class="s">"""Compute fraction of Democrat yea votes."""</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">dems</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dems</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">frac</span>

<span class="c1"># Acquire permutation samples: perm_replicates
</span><span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">draw_perm_reps</span><span class="p">(</span><span class="n">dems</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">frac_yea_dems</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute and print p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">perm_replicates</span> <span class="o">&lt;=</span> <span class="mi">153</span><span class="o">/</span><span class="mi">244</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm_replicates</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'p-value ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-value = 0.0002
# p-value = 0.02%
</span>
</code></pre></div></div>

<p>This small p-value suggests that party identity had a lot to do with the voting. Importantly, the South had a higher fraction of Democrat representatives, and consequently also a more racist bias.</p>

<p>####
 What is equivalent?</p>

<p>You have experience matching a stories to probability distributions. Similarly, you use the same procedure for two different A/B tests if their stories match. In the Civil Rights Act example you just did, you performed an A/B test on voting data, which has a Yes/No type of outcome for each subject (in that case, a voter). Which of the following situations involving testing by a web-based company has an equivalent set up for an A/B test as the one you just did with the Civil Rights Act of 1964?</p>

<p>You measure the number of people who click on an ad on your company’s website before and after changing its color.</p>

<p>The “Democrats” are those who view the ad before the color change, and the “Republicans” are those who view it after.</p>

<p>####
 A time-on-website analog</p>

<p>It turns out that you already did a hypothesis test analogous to an A/B test where you are interested in how much time is spent on the website before and after an ad campaign. The frog tongue force (a continuous quantity like time on the website) is an analog. “Before” = Frog A and “after” = Frog B. Let’s practice this again with something that actually is a before/after scenario.</p>

<p>We return to the no-hitter data set. In 1920, Major League Baseball implemented important rule changes that ended the so-called dead ball era. Importantly, the pitcher was no longer allowed to spit on or scuff the ball, an activity that greatly favors pitchers. In this problem you will perform an A/B test to determine if these rule changes resulted in a slower rate of no-hitters (i.e., longer average time between no-hitters) using the difference in mean inter-no-hitter time as your test statistic. The inter-no-hitter times for the respective eras are stored in the arrays
 <code class="language-plaintext highlighter-rouge">nht_dead</code>
 and
 <code class="language-plaintext highlighter-rouge">nht_live</code>
 , where “nht” is meant to stand for “no-hitter time.”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def diff_of_means(data_1, data_2):
    """Difference in means of two arrays."""

    # The difference of means of data_1, data_2: diff
    diff = np.mean(data_1) - np.mean(data_2)

    return diff

def permutation_sample(data1, data2):
    """Generate a permutation sample from two data sets."""

    # Concatenate the data sets: data
    data = np.concatenate((data1, data2))

    # Permute the concatenated array: permuted_data
    permuted_data = np.random.permutation(data)

    # Split the permuted array into two: perm_sample_1, perm_sample_2
    perm_sample_1 = permuted_data[:len(data1)]
    perm_sample_2 = permuted_data[len(data1):]

    return perm_sample_1, perm_sample_2

def draw_perm_reps(data_1, data_2, func, size=1):
    """Generate multiple permutation replicates."""

    # Initialize array of replicates: perm_replicates
    perm_replicates = np.empty(size)

    for i in range(size):
        # Generate permutation sample
        perm_sample_1, perm_sample_2 = permutation_sample(data_1, data_2)

        # Compute the test statistic
        perm_replicates[i] = func(perm_sample_1, perm_sample_2)

    return perm_replicates



# Compute the observed difference in mean inter-no-hitter times: nht_diff_obs
nht_diff_obs = diff_of_means(nht_dead, nht_live)

# Acquire 10,000 permutation replicates of difference in mean no-hitter time: perm_replicates
perm_replicates = draw_perm_reps(nht_dead, nht_live, diff_of_means, size=10000)

# Compute and print the p-value: p
p = np.sum(perm_replicates &lt;= nht_diff_obs) /len(perm_replicates)
print('p-val =', p)

p-val = 0.0001

</code></pre></div></div>

<p>Your p-value is 0.0001, which means that only one out of your 10,000 replicates had a result as extreme as the actual difference between the dead ball and live ball eras. This suggests strong statistical significance. Watch out, though, you could very well have gotten zero replicates that were as extreme as the observed value. This just means that the p-value is quite small, almost certainly smaller than 0.001.</p>

<p>####
 What should you have done first?</p>

<p>That was a nice hypothesis test you just did to check out whether the rule changes in 1920 changed the rate of no-hitters. But what
 <em>should</em>
 you have done with the data first?</p>

<p>Performed EDA, perhaps plotting the ECDFs of inter-no-hitter times in the dead ball and live ball eras.</p>

<p>Always a good idea to do first! I encourage you to go ahead and plot the ECDFs right now. You will see by eye that the null hypothesis that the distributions are the same is almost certainly not true.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create and plot ECDFs
</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nht_dead</span><span class="p">)</span>
<span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nht_live</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>

<span class="c1"># Label axes, set margin, and show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-17.png" alt="Desktop View" /></p>

<p>###
 Test of correlation</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-16.png" alt="Desktop View" /></p>

<p>####
 Simulating a null hypothesis concerning correlation</p>

<p>The observed correlation between female illiteracy and fertility in the data set of 162 countries may just be by chance; the fertility of a given country may actually be totally independent of its illiteracy. You will test this null hypothesis in the next exercise.</p>

<p>To do the test, you need to simulate the data assuming the null hypothesis is true. Of the following choices, which is the best way to to do it?</p>

<p>Answer: Do a permutation test: Permute the illiteracy values but leave the fertility values fixed to generate a new set of (illiteracy, fertility) data.</p>

<p>This exactly simulates the null hypothesis and does so more efficiently than the last option. It is exact because it uses all data and eliminates any correlation because which illiteracy value pairs to which fertility value is shuffled.</p>

<p>Last option: Do a permutation test: Permute both the illiteracy and fertility values to generate a new set of (illiteracy, fertility data). This exactly simulates the null hypothesis and does so more efficiently than the last option. It is exact because it uses all data and eliminates any correlation because which illiteracy value pairs to which fertility value is shuffled.</p>

<p>####
 Hypothesis test on Pearson correlation</p>

<p>The observed correlation between female illiteracy and fertility may just be by chance; the fertility of a given country may actually be totally independent of its illiteracy. You will test this hypothesis. To do so, permute the illiteracy values but leave the fertility values fixed. This simulates the hypothesis that they are totally independent of each other. For each permutation, compute the Pearson correlation coefficient and assess how many of your permutation replicates have a Pearson correlation coefficient greater than the observed one.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def pearson_r(x, y):
    """Compute Pearson correlation coefficient between two arrays."""
    # Compute correlation matrix: corr_mat
    corr_mat = np.corrcoef(x, y)

    # Return entry [0,1]
    return corr_mat[0,1]

# Compute observed correlation: r_obs
r_obs = pearson_r(illiteracy, fertility)

# r_obs = 0.8041324026815344

# Initialize permutation replicates: perm_replicates
perm_replicates = np.empty(10000)

# Draw replicates
for i in range(10000):
    # Permute illiteracy measurments: illiteracy_permuted
    illiteracy_permuted = np.random.permutation(illiteracy)

    # Compute Pearson correlation
    perm_replicates[i] = pearson_r(illiteracy_permuted, fertility)

# Compute p-value: p
p = np.sum(perm_replicates &gt;= r_obs) /len(perm_replicates)
print('p-val =', p)

# p-val = 0.0

</code></pre></div></div>

<p>You got a p-value of zero. In hacker statistics, this means that your p-value is very low, since you never got a single replicate in the 10,000 you took that had a Pearson correlation greater than the observed one. You could try increasing the number of replicates you take to continue to move the upper bound on your p-value lower and lower.</p>

<p>####
 Do neonicotinoid insecticides have unintended consequences?</p>

<p>As a final exercise in hypothesis testing before we put everything together in our case study in the next chapter, you will investigate the effects of neonicotinoid insecticides on bee reproduction. These insecticides are very widely used in the United States to combat aphids and other pests that damage plants.</p>

<p>In a recent study, Straub, et al. (
 <a href="http://dx.doi.org/10.1098/rspb.2016.0506"><em>Proc. Roy. Soc. B</em>
 , 2016</a>
 ) investigated the effects of neonicotinoids on the sperm of pollinating bees. In this and the next exercise, you will study how the pesticide treatment affected the count of live sperm per half milliliter of semen.</p>

<p>First, we will do EDA, as usual. Plot ECDFs of the alive sperm count for untreated bees (stored in the Numpy array
 <code class="language-plaintext highlighter-rouge">control</code>
 ) and bees treated with pesticide (stored in the Numpy array
 <code class="language-plaintext highlighter-rouge">treated</code>
 ).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute x,y values for ECDFs
</span><span class="n">x_control</span><span class="p">,</span> <span class="n">y_control</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">control</span><span class="p">)</span>
<span class="n">x_treated</span><span class="p">,</span> <span class="n">y_treated</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">treated</span><span class="p">)</span>

<span class="c1"># Plot the ECDFs
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_control</span><span class="p">,</span> <span class="n">y_control</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_treated</span><span class="p">,</span> <span class="n">y_treated</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set the margins
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>

<span class="c1"># Add a legend
</span><span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'control'</span><span class="p">,</span> <span class="s">'treated'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Label axes and show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'millions of alive sperm per mL'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-15.png" alt="Desktop View" /></p>

<p>The ECDFs show a pretty clear difference between the treatment and control; treated bees have fewer alive sperm. Let’s now do a hypothesis test in the next exercise.</p>

<p>####
 Bootstrap hypothesis test on bee sperm counts</p>

<p>Now, you will test the following hypothesis:</p>

<p><strong>On average, male bees treated with neonicotinoid insecticide have the same number of active sperm per milliliter of semen than do untreated male bees.</strong></p>

<p>You will use the difference of means as your test statistic.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def bootstrap_replicate_1d(data, func):
    return func(np.random.choice(data, size=len(data)))

def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates


# Compute the difference in mean sperm count: diff_means
diff_means = np.mean(control) - np.mean(treated)

# Compute mean of pooled data: mean_count
mean_count = np.mean(np.concatenate((control, treated)))

# Generate shifted data sets
control_shifted = control - np.mean(control) + mean_count
treated_shifted = treated - np.mean(treated) + mean_count

# Generate bootstrap replicates
bs_reps_control = draw_bs_reps(control_shifted,
                       np.mean, size=10000)
bs_reps_treated = draw_bs_reps(treated_shifted,
                       np.mean, size=10000)

# Get replicates of difference of means: bs_replicates
bs_replicates = bs_reps_control - bs_reps_treated

# Compute and print p-value: p
p = np.sum(bs_replicates &gt;= np.mean(control) - np.mean(treated)) \
            / len(bs_replicates)
print('p-value =', p)

# p-value = 0.0

</code></pre></div></div>

<p>The p-value is small, most likely less than 0.0001, since you never saw a bootstrap replicated with a difference of means at least as extreme as what was observed. In fact, when I did the calculation with 10 million replicates, I got a p-value of
 <code class="language-plaintext highlighter-rouge">2e-05</code></p>

<h2 id="putting-it-all-together-a-case-study-3">Putting it all together: a case study</h2>

<p>###
 Finch beaks and the need for statistics</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture4-14.png" alt="Desktop View" /></p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture5-12.png" alt="Desktop View" /></p>

<p>####
 EDA of beak depths of Darwin’s finches</p>

<p>For your first foray into the Darwin finch data, you will study how the beak depth (the distance, top to bottom, of a closed beak) of the finch species
 <em>Geospiza scandens</em>
 has changed over time. The Grants have noticed some changes of beak geometry depending on the types of seeds available on the island, and they also noticed that there was some interbreeding with another major species on Daphne Major,
 <em>Geospiza fortis</em>
 . These effects can lead to changes in the species over time.</p>

<p>In the next few problems, you will look at the beak depth of
 <em>G. scandens</em>
 on Daphne Major in 1975 and in 2012. To start with, let’s plot all of the beak depth measurements in 1975 and 2012 in a bee swarm plot.</p>

<p>The data are stored in a pandas DataFrame called
 <code class="language-plaintext highlighter-rouge">df</code>
 with columns
 <code class="language-plaintext highlighter-rouge">'year'</code>
 and
 <code class="language-plaintext highlighter-rouge">'beak_depth'</code>
 . The units of beak depth are millimeters (mm).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   beak_depth  year
0         8.4  1975
1         8.8  1975
2         8.4  1975
3         8.0  1975
4         7.9  1975

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create bee swarm plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">sns</span><span class="p">.</span><span class="n">swarmplot</span><span class="p">(</span><span class="s">'year'</span><span class="p">,</span> <span class="s">'beak_depth'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Label the axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'year'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture6-9.png" alt="Desktop View" /></p>

<p>It is kind of hard to see if there is a clear difference between the 1975 and 2012 data set. Eyeballing it, it appears as though the mean of the 2012 data set might be slightly higher, and it might have a bigger variance.</p>

<p>####
 ECDFs of beak depths</p>

<p>While bee swarm plots are useful, we found that ECDFs are often even better when doing EDA. Plot the ECDFs for the 1975 and 2012 beak depth measurements on the same plot.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute ECDFs
</span><span class="n">x_1975</span><span class="p">,</span> <span class="n">y_1975</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">bd_1975</span><span class="p">)</span>
<span class="n">x_2012</span><span class="p">,</span> <span class="n">y_2012</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">bd_2012</span><span class="p">)</span>

<span class="c1"># Plot the ECDFs
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1975</span><span class="p">,</span> <span class="n">y_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2012</span><span class="p">,</span> <span class="n">y_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set margins
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>

<span class="c1"># Add axis labels and legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture7-10.png" alt="Desktop View" /></p>

<p>The differences are much clearer in the ECDF. The mean is larger in the 2012 data, and the variance does appear larger as well.</p>

<p>####
 Parameter estimates of beak depths</p>

<p>Estimate the
 <em>difference</em>
 of the mean beak depth of the
 <em>G. scandens</em>
 samples from 1975 and 2012 and report a 95% confidence interval.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates


# Compute the difference of the sample means: mean_diff
mean_diff = np.mean(bd_2012) - np.mean(bd_1975)

# Get bootstrap replicates of means
bs_replicates_1975 = draw_bs_reps(bd_1975, np.mean, size=10000)
bs_replicates_2012 = draw_bs_reps(bd_2012, np.mean, size=10000)

# Compute samples of difference of means: bs_diff_replicates
bs_diff_replicates = bs_replicates_2012 - bs_replicates_1975

# Compute 95% confidence interval: conf_int
conf_int = np.percentile(bs_diff_replicates, [2.5, 97.5])

# Print the results
print('difference of means =', mean_diff, 'mm')
print('95% confidence interval =', conf_int, 'mm')

# difference of means = 0.22622047244094645 mm
# 95% confidence interval = [0.05633521 0.39190544] mm

</code></pre></div></div>

<p>####
 Hypothesis test: Are beaks deeper in 2012?</p>

<p>Your plot of the ECDF and determination of the confidence interval make it pretty clear that the beaks of
 <em>G. scandens</em>
 on Daphne Major have gotten deeper. But is it possible that this effect is just due to random chance? In other words, what is the probability that we would get the observed difference in mean beak depth if the means were the same?</p>

<p>Be careful! The hypothesis we are testing is
 <em>not</em>
 that the beak depths come from the same distribution. For that we could use a permutation test.
 <strong>The hypothesis is that the means are equal.</strong>
 To perform this hypothesis test, we need to shift the two data sets so that they have the same mean and then use bootstrap sampling to compute the difference of means.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute mean of combined data set: combined_mean
</span><span class="n">combined_mean</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">bd_1975</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">)))</span>

<span class="c1"># Shift the samples
# why shift the mean?
# to make np.mean(bd_1975_shifted) - np.mean(bd_2012_shifted) = 0 #1
# why make #1 = 0?
# because our hypothesis is "beak depth are the same in 1975 and 2012"
</span><span class="n">bd_1975_shifted</span> <span class="o">=</span> <span class="n">bd_1975</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bd_1975</span><span class="p">)</span> <span class="o">+</span> <span class="n">combined_mean</span>
<span class="n">bd_2012_shifted</span> <span class="o">=</span> <span class="n">bd_2012</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bd_2012</span><span class="p">)</span> <span class="o">+</span> <span class="n">combined_mean</span>

<span class="c1"># Get bootstrap replicates of shifted data sets
</span><span class="n">bs_replicates_1975</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">bd_1975_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_2012</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">bd_2012_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute replicates of difference of means: bs_diff_replicates
</span><span class="n">bs_diff_replicates</span> <span class="o">=</span> <span class="n">bs_replicates_2012</span> <span class="o">-</span> <span class="n">bs_replicates_1975</span>

<span class="c1"># Compute the p-value
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_diff_replicates</span> <span class="o">&gt;=</span> <span class="n">mean_diff</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs_diff_replicates</span><span class="p">)</span>

<span class="c1"># Print p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p = 0.0034
# p = 0.34%
</span>
</code></pre></div></div>

<p>We get a p-value of 0.0034, which suggests that there is a statistically significant difference. But remember: it is very important to know how different they are! In the previous exercise, you got a difference of 0.2 mm between the means. You should combine this with the statistical significance. Changing by 0.2 mm in 37 years is substantial by evolutionary standards. If it kept changing at that rate, the beak depth would double in only 400 years.</p>

<p>###
 Variation of beak shapes</p>

<p>####
 EDA of beak length and depth</p>

<p>The beak length data are stored as
 <code class="language-plaintext highlighter-rouge">bl_1975</code>
 and
 <code class="language-plaintext highlighter-rouge">bl_2012</code>
 , again with units of millimeters (mm). You still have the beak depth data stored in
 <code class="language-plaintext highlighter-rouge">bd_1975</code>
 and
 <code class="language-plaintext highlighter-rouge">bd_2012</code>
 . Make scatter plots of beak depth (y-axis) versus beak length (x-axis) for the 1975 and 2012 specimens.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plot of 1975 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_1975</span><span class="p">,</span> <span class="n">bd_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'None'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Make scatter plot of 2012 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_2012</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s">'None'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes and make legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak length (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture8-7.png" alt="Desktop View" /></p>

<p>In looking at the plot, we see that beaks got deeper (the red points are higher up in the y-direction), but not really longer. If anything, they got a bit shorter, since the red dots are to the left of the blue dots. So, it does not look like the beaks kept the same shape; they became shorter and deeper.</p>

<p>####
 Linear regressions</p>

<p>Perform a linear regression for both the 1975 and 2012 data. Then, perform pairs bootstrap estimates for the regression parameters. Report 95% confidence intervals on the slope and intercept of the regression line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, deg=1)

    return bs_slope_reps, bs_intercept_reps


# Compute the linear regressions
slope_1975, intercept_1975 = np.polyfit(bl_1975, bd_1975, deg=1)
slope_2012, intercept_2012 = np.polyfit(bl_2012, bd_2012, deg=1)

# Perform pairs bootstrap for the linear regressions
bs_slope_reps_1975, bs_intercept_reps_1975 = draw_bs_pairs_linreg(bl_1975, bd_1975, size=1000)
bs_slope_reps_2012, bs_intercept_reps_2012 = draw_bs_pairs_linreg(bl_2012, bd_2012, size=1000)

# Compute confidence intervals of slopes
slope_conf_int_1975 = np.percentile(bs_slope_reps_1975, [2.5, 97.5])
slope_conf_int_2012 = np.percentile(bs_slope_reps_2012, [2.5, 97.5])
intercept_conf_int_1975 = np.percentile(bs_intercept_reps_1975, [2.5, 97.5])
intercept_conf_int_2012 = np.percentile(bs_intercept_reps_2012, [2.5, 97.5])


# Print the results
print('1975: slope =', slope_1975,
      'conf int =', slope_conf_int_1975)
print('1975: intercept =', intercept_1975,
      'conf int =', intercept_conf_int_1975)
print('2012: slope =', slope_2012,
      'conf int =', slope_conf_int_2012)
print('2012: intercept =', intercept_2012,
      'conf int =', intercept_conf_int_2012)

#   1975: slope = 0.4652051691605937 conf int = [0.33851226 0.59306491]
#   1975: intercept = 2.3908752365842263 conf int = [0.64892945 4.18037063]
#   2012: slope = 0.462630358835313 conf int = [0.33137479 0.60695527]
#   2012: intercept = 2.977247498236019 conf int = [1.06792753 4.70599387]

</code></pre></div></div>

<p>It looks like they have the same slope, but different intercepts.</p>

<p>####
 Displaying the linear regression results</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plot of 1975 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_1975</span><span class="p">,</span> <span class="n">bd_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Make scatter plot of 2012 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_2012</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes and make legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak length (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>

<span class="c1"># Generate x-values for bootstrap lines: x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">17</span><span class="p">])</span>

<span class="c1"># Plot the bootstrap lines
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bs_slope_reps_1975</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps_1975</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bs_slope_reps_2012</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps_2012</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

<span class="c1"># Draw the plot again
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture9-6.png" alt="Desktop View" /></p>

<p>####
 Beak length to depth ratio</p>

<p>The linear regressions showed interesting information about the beak geometry. The slope was the same in 1975 and 2012, suggesting that for every millimeter gained in beak length, the birds gained about half a millimeter in depth in both years. However, if we are interested in the shape of the beak, we want to compare the
 <em>ratio</em>
 of beak length to beak depth. Let’s make that comparison.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute length-to-depth ratios
</span><span class="n">ratio_1975</span> <span class="o">=</span> <span class="n">bl_1975</span> <span class="o">/</span> <span class="n">bd_1975</span>
<span class="n">ratio_2012</span> <span class="o">=</span> <span class="n">bl_2012</span> <span class="o">/</span> <span class="n">bd_2012</span>

<span class="c1"># Compute means
</span><span class="n">mean_ratio_1975</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratio_1975</span><span class="p">)</span>
<span class="n">mean_ratio_2012</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratio_2012</span><span class="p">)</span>

<span class="c1"># Generate bootstrap replicates of the means
</span><span class="n">bs_replicates_1975</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">ratio_1975</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_2012</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">ratio_2012</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute the 99% confidence intervals
</span><span class="n">conf_int_1975</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates_1975</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">])</span>
<span class="n">conf_int_2012</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates_2012</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">])</span>

<span class="c1"># Print the results
</span><span class="k">print</span><span class="p">(</span><span class="s">'1975: mean ratio ='</span><span class="p">,</span> <span class="n">mean_ratio_1975</span><span class="p">,</span>
      <span class="s">'conf int ='</span><span class="p">,</span> <span class="n">conf_int_1975</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'2012: mean ratio ='</span><span class="p">,</span> <span class="n">mean_ratio_2012</span><span class="p">,</span>
      <span class="s">'conf int ='</span><span class="p">,</span> <span class="n">conf_int_2012</span><span class="p">)</span>

<span class="c1"># 1975: mean ratio = 1.5788823771858533 conf int = [1.55668803 1.60073509]
# 2012: mean ratio = 1.4658342276847767 conf int = [1.44363932 1.48729149]
</span>
</code></pre></div></div>

<p>####
 How different is the ratio?</p>

<p>In the previous exercise, you computed the mean beak length to depth ratio with 99% confidence intervals for 1975 and for 2012. The results of that calculation are shown graphically in the plot accompanying this problem. In addition to these results, what would you say about the ratio of beak length to depth?</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture10-6.png" alt="Desktop View" /></p>

<p>The mean beak length-to-depth ratio decreased by about 0.1, or 7%, from 1975 to 2012. The 99% confidence intervals are not even close to overlapping, so this is a real change. The beak shape changed.</p>

<p>###
 Calculation of heritability</p>

<p>####
 EDA of heritability</p>

<p>The array
 <code class="language-plaintext highlighter-rouge">bd_parent_scandens</code>
 contains the average beak depth (in mm) of two parents of the species
 <code class="language-plaintext highlighter-rouge">G. scandens</code>
 . The array
 <code class="language-plaintext highlighter-rouge">bd_offspring_scandens</code>
 contains the average beak depth of the offspring of the respective parents. The arrays
 <code class="language-plaintext highlighter-rouge">bd_parent_fortis</code>
 and
 <code class="language-plaintext highlighter-rouge">bd_offspring_fortis</code>
 contain the same information about measurements from
 <em>G. fortis</em>
 birds.</p>

<p>Make a scatter plot of the average offspring beak depth (y-axis) versus average parental beak depth (x-axis) for both species. Use the
 <code class="language-plaintext highlighter-rouge">alpha=0.5</code>
 keyword argument to help you see overlapping points.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plots
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bd_parent_fortis</span><span class="p">,</span> <span class="n">bd_offspring_fortis</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bd_parent_scandens</span><span class="p">,</span> <span class="n">bd_offspring_scandens</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'parental beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'offspring beak depth (mm)'</span><span class="p">)</span>

<span class="c1"># Add legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'G. fortis'</span><span class="p">,</span> <span class="s">'G. scandens'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture11-6.png" alt="Desktop View" /></p>

<p>It appears as though there is a stronger correlation in
 <em>G. fortis</em>
 than than in
 <em>G. scandens</em>
 . This suggests that beak depth is more strongly inherited in
 <em>G. fortis</em>
 . We’ll quantify this correlation next.</p>

<p>####
 Correlation of offspring and parental data</p>

<p>In an effort to quantify the correlation between offspring and parent beak depths, we would like to compute statistics, such as the Pearson correlation coefficient, between parents and offspring. To get confidence intervals on this, we need to do a pairs bootstrap.</p>

<p>You have
 <a href="https://campus.datacamp.com/courses/statistical-thinking-in-python-part-2/bootstrap-confidence-intervals?ex=12">already written</a>
 a function to do pairs bootstrap to get estimates for parameters derived from linear regression. Your task in this exercise is to make a new function with call signature
 <code class="language-plaintext highlighter-rouge">draw_bs_pairs(x, y, func, size=1)</code>
 that performs pairs bootstrap and computes a single statistic on pairs samples defined. The statistic of interest is computed by calling
 <code class="language-plaintext highlighter-rouge">func(bs_x, bs_y)</code>
 . In the next exercise, you will use
 <code class="language-plaintext highlighter-rouge">pearson_r</code>
 for
 <code class="language-plaintext highlighter-rouge">func</code>
 .</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs(x, y, func, size=1):
    """Perform pairs bootstrap for a single statistic."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_replicates[i] = func(bs_x, bs_y)

    return bs_replicates


</code></pre></div></div>

<p>####
 Pearson correlation of offspring and parental data</p>

<p>The Pearson correlation coefficient seems like a useful measure of how strongly the beak depth of parents are inherited by their offspring. Compute the Pearson correlation coefficient between parental and offspring beak depths for
 <em>G. scandens</em>
 . Do the same for
 <em>G. fortis</em>
 . Then, use the function you wrote in the last exercise to compute a 95% confidence interval using pairs bootstrap.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def pearson_r(x, y):
    """Compute Pearson correlation coefficient between two arrays."""
    # Compute correlation matrix: corr_mat
    corr_mat = np.corrcoef(x, y)

    # Return entry [0,1]
    return corr_mat[0,1]


# Compute the Pearson correlation coefficients
r_scandens = pearson_r(bd_parent_scandens, bd_offspring_scandens)
r_fortis = pearson_r(bd_parent_fortis, bd_offspring_fortis)

# Acquire 1000 bootstrap replicates of Pearson r
bs_replicates_scandens = draw_bs_pairs(bd_parent_scandens, bd_offspring_scandens, pearson_r, size=1000)

bs_replicates_fortis = draw_bs_pairs(bd_parent_fortis, bd_offspring_fortis, pearson_r, size=1000)


# Compute 95% confidence intervals
conf_int_scandens = np.percentile(bs_replicates_scandens, [2.5, 97.5])
conf_int_fortis = np.percentile(bs_replicates_fortis, [2.5, 97.5])

# Print results
print('G. scandens:', r_scandens, conf_int_scandens)
print('G. fortis:', r_fortis, conf_int_fortis)

#    G. scandens: 0.4117063629401258 [0.26564228 0.54388972]
#    G. fortis: 0.7283412395518487 [0.6694112  0.77840616]

</code></pre></div></div>

<p>It is clear from the confidence intervals that beak depth of the offspring of
 <em>G. fortis</em>
 parents is more strongly correlated with their offspring than their
 <em>G. scandens</em>
 counterparts.</p>

<p>####
 Measuring heritability</p>

<p>Remember that the Pearson correlation coefficient is the ratio of the covariance to the geometric mean of the variances of the two data sets. This is a measure of the correlation between parents and offspring, but might not be the best estimate of heritability. If we stop and think, it makes more sense to define heritability as the ratio of the covariance between parent and offspring to the
 <em>variance of the parents alone</em>
 . In this exercise, you will estimate the heritability and perform a pairs bootstrap calculation to get the 95% confidence interval.</p>

<p>This exercise highlights a very important point. Statistical inference (and data analysis in general) is not a plug-n-chug enterprise. You need to think carefully about the questions you are seeking to answer with your data and analyze them appropriately. If you are interested in how heritable traits are, the quantity we defined as the heritability is more apt than the off-the-shelf statistic, the Pearson correlation coefficient.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def heritability(parents, offspring):
    """Compute the heritability from parent and offspring samples."""
    covariance_matrix = np.cov(parents, offspring)
    return covariance_matrix[0,1] / covariance_matrix[0,0]

# Compute the heritability
heritability_scandens = heritability(bd_parent_scandens, bd_offspring_scandens)
heritability_fortis = heritability(bd_parent_fortis, bd_offspring_fortis)

# Acquire 1000 bootstrap replicates of heritability
replicates_scandens = draw_bs_pairs(
        bd_parent_scandens, bd_offspring_scandens, heritability, size=1000)

replicates_fortis = draw_bs_pairs(
        bd_parent_fortis, bd_offspring_fortis, heritability, size=1000)


# Compute 95% confidence intervals
conf_int_scandens = np.percentile(replicates_scandens, [2.5, 97.5])
conf_int_fortis = np.percentile(replicates_fortis, [2.5, 97.5])

# Print results
print('G. scandens:', heritability_scandens, conf_int_scandens)
print('G. fortis:', heritability_fortis, conf_int_fortis)


#   G. scandens: 0.5485340868685982 [0.34395487 0.75638267]
#   G. fortis: 0.7229051911438159 [0.64655013 0.79688342]

</code></pre></div></div>

<p>Here again, we see that
 <em>G. fortis</em>
 has stronger heritability than
 <em>G. scandens</em>
 . This suggests that the traits of
 <em>G. fortis</em>
 may be strongly incorporated into
 <em>G. scandens</em>
 by introgressive hybridization.</p>

<p>####
 Is beak depth heritable at all in G. scandens?</p>

<p>The heritability of beak depth in
 <em>G. scandens</em>
 seems low. It could be that this observed heritability was just achieved by chance and
 <strong>beak depth is actually not really heritable in the species</strong>
 . You will test that hypothesis here. To do this, you will do a pairs permutation test.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Initialize array of replicates: perm_replicates
</span><span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Draw replicates
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="c1"># Permute parent beak depths
</span>    <span class="n">bd_parent_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">bd_parent_scandens</span><span class="p">)</span>
    <span class="n">perm_replicates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">heritability</span><span class="p">(</span><span class="n">bd_parent_permuted</span><span class="p">,</span>
                                      <span class="n">bd_offspring_scandens</span><span class="p">)</span>

<span class="c1"># Compute p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">perm_replicates</span> <span class="o">&gt;=</span> <span class="n">heritability_scandens</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm_replicates</span><span class="p">)</span>

<span class="c1"># Print the p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p-val ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-val = 0.0
</span>
</code></pre></div></div>

<p>You get a p-value of zero, which means that none of the 10,000 permutation pairs replicates you drew had a heritability high enough to match that which was observed. This strongly suggests that beak depth is heritable in
 <em>G. scandens</em>
 , just not as much as in
 <em>G. fortis</em>
 . If you like, you can plot a histogram of the heritability replicates to get a feel for how extreme of a value of heritability you might expect by chance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.hist(perm_replicates)
plt.axvline(x=heritability_scandens, color = 'red')
plt.text(heritability_scandens, 1500, 'heritability_scandens', ha='center', va='center',rotation='vertical', backgroundcolor='white')
plt.show()

</code></pre></div></div>

<h2 id="parameter-estimation-by-optimization-4">Parameter estimation by optimization</h2>

<p>###
 Optimal parameters</p>

<p>####
 How often do we get no-hitters?</p>

<p>The number of games played between each no-hitter in the modern era (1901-2015) of Major League Baseball is stored in the array
 <code class="language-plaintext highlighter-rouge">nohitter_times</code>
 .</p>

<p>If you assume that no-hitters are described as a Poisson process, then the time between no-hitters is Exponentially distributed. As you have seen, the Exponential distribution has a single parameter, which we will call ττ, the typical interval time. The value of the parameter ττ that makes the exponential distribution best match the data is the mean interval time (where time is in units of number of games) between no-hitters.</p>

<p>Compute the value of this parameter from the data. Then, use
 <code class="language-plaintext highlighter-rouge">np.random.exponential()</code>
 to “repeat” the history of Major League Baseball by drawing inter-no-hitter times from an exponential distribution with the ττ you found and plot the histogram as an approximation to the PDF.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Seed random number generator
</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Compute mean no-hitter time: tau
</span><span class="n">tau</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">)</span>

<span class="c1"># Draw out of an exponential distribution with parameter tau: inter_nohitter_time
</span><span class="n">inter_nohitter_time</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tau</span><span class="p">,</span> <span class="mi">100000</span><span class="p">)</span>

<span class="c1"># Plot the PDF and label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">inter_nohitter_time</span><span class="p">,</span>
             <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s">'step'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture-16.png" alt="Desktop View" /></p>

<p>We see the typical shape of the Exponential distribution, going from a maximum at 0 and decaying to the right.</p>

<p>####
 Do the data follow our story?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create an ECDF from real data: x, y
</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">)</span>

<span class="c1"># Create a CDF from theoretical samples: x_theor, y_theor
</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">inter_nohitter_time</span><span class="p">)</span>

<span class="c1"># Overlay the plots
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Margins and axis labels
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'CDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-15.png" alt="Desktop View" /></p>

<p>It looks like no-hitters in the modern era of Major League Baseball are Exponentially distributed. Based on the story of the Exponential distribution, this suggests that they are a random process; when a no-hitter will happen is independent of when the last no-hitter was.</p>

<p>####
 How is this parameter optimal?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the theoretical CDFs
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'CDF'</span><span class="p">)</span>

<span class="c1"># Take samples with half tau: samples_half
</span><span class="n">samples_half</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="n">tau</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Take samples with double tau: samples_double
</span><span class="n">samples_double</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">exponential</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">tau</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Generate CDFs from these samples
</span><span class="n">x_half</span><span class="p">,</span> <span class="n">y_half</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">samples_half</span><span class="p">)</span>
<span class="n">x_double</span><span class="p">,</span> <span class="n">y_double</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">samples_double</span><span class="p">)</span>

<span class="c1"># Plot these CDFs as lines
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_half</span><span class="p">,</span> <span class="n">y_half</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_double</span><span class="p">,</span> <span class="n">y_double</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-14.png" alt="Desktop View" /></p>

<p>red = half, purple = double</p>

<p>Notice how the value of tau given by the mean matches the data best. In this way, tau is an optimal parameter.</p>

<p>###
 Linear regression by least squares</p>

<p>####
 EDA of literacy/fertility data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the illiteracy rate versus fertility
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set the margins and label axes
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'percent illiterate'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Show the Pearson correlation coefficient
</span><span class="k">print</span><span class="p">(</span><span class="n">pearson_r</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">))</span>
<span class="mf">0.8041324026815344</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-13.png" alt="Desktop View" /></p>

<p>You can see the correlation between illiteracy and fertility by eye, and by the substantial Pearson correlation coefficient of 0.8. It is difficult to resolve in the scatter plot, but there are many points around near-zero illiteracy and about 1.8 children/woman.</p>

<p>####
 Linear regression</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Plot the illiteracy rate versus fertility
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'percent illiterate'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>

<span class="c1"># Perform a linear regression using np.polyfit(): a, b
</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the results to the screen
</span><span class="k">print</span><span class="p">(</span><span class="s">'slope ='</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s">'children per woman / percent illiterate'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'intercept ='</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="s">'children per woman'</span><span class="p">)</span>

<span class="c1"># Make theoretical line to plot
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Add regression line to your plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="c1"># Draw the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1"># slope = 0.04979854809063423 children per woman / percent illiterate
# intercept = 1.888050610636557 children per woman
</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture4-13.png" alt="Desktop View" /></p>

<p>####
 How is it optimal?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Specify slopes to consider: a_vals
</span><span class="n">a_vals</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="c1"># Initialize sum of square of residuals: rss
</span><span class="n">rss</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a_vals</span><span class="p">)</span>

<span class="c1"># Compute sum of square of residuals for each value of a_vals
</span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_vals</span><span class="p">):</span>
    <span class="n">rss</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">((</span><span class="n">fertility</span> <span class="o">-</span> <span class="n">a</span><span class="o">*</span><span class="n">illiteracy</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Plot the RSS
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">a_vals</span><span class="p">,</span> <span class="n">rss</span><span class="p">,</span> <span class="s">'-'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'slope (children per woman / percent illiterate)'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'sum of square of residuals'</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture5-11.png" alt="Desktop View" /></p>

<p>Notice that the minimum on the plot, that is the value of the slope that gives the minimum sum of the square of the residuals, is the same value you got when performing the regression.</p>

<p>###
 The importance of EDA: Anscombe’s quartet</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture6-8.png" alt="Desktop View" /></p>

<p>####
 The importance of EDA</p>

<p>Why should exploratory data analysis be the first step in an analysis of data (after getting your data imported and cleaned, of course)?</p>

<ul>
  <li>You can be protected from misinterpretation of the type demonstrated by Anscombe’s quartet.</li>
  <li>EDA provides a good starting point for planning the rest of your analysis.</li>
  <li>EDA is not really any more difficult than any of the subsequent analysis, so there is no excuse for not exploring the data.</li>
</ul>

<p>####
 Linear regression on appropriate Anscombe data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Perform linear regression: a, b
</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Print the slope and intercept
</span><span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

<span class="c1"># Generate theoretical x and y data: x_theor, y_theor
</span><span class="n">x_theor</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">])</span>
<span class="n">y_theor</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x_theor</span> <span class="o">+</span> <span class="n">b</span>

<span class="c1"># Plot the Anscombe data and theoretical line
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">marker</span> <span class="o">=</span> <span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span> <span class="o">=</span> <span class="s">'none'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_theor</span><span class="p">,</span> <span class="n">y_theor</span><span class="p">)</span>

<span class="c1"># Label the axes
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture7-9.png" alt="Desktop View" /></p>

<p>####
 Linear regression on all Anscombe data</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for i in range(4):
    plt.subplot(2,2,i+1)

    # plot the scatter plot
    plt.plot(anscombe_x[i], anscombe_y[i], marker = '.', linestyle = 'none')

    # plot the regression line
    a, b = np.polyfit(anscombe_x[i], anscombe_y[i], deg=1)
    x_theor = np.array([np.min(anscombe_x[i]), np.max(anscombe_x[i])])
    y_theor = a * x_theor + b
    plt.plot(x_theor, y_theor)

    # add label
    plt.xlabel('x' + str(i+1))
    plt.ylabel('y' + str(i+1))

plt.show()

# slope1: 0.5000909090909095 intercept: 3.000090909090909
# slope2: 0.5000000000000004 intercept: 3.0009090909090896
# slope3: 0.4997272727272731 intercept: 3.0024545454545453
# slope4: 0.4999090909090908 intercept: 3.0017272727272735

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture8-6.png" alt="Desktop View" /></p>

<p>###
 Generating bootstrap replicates</p>

<p>####
 Getting the terminology down</p>

<p>If we have a data set with n repeated measurements, a
 <strong>bootstrap sample</strong>
 is an array of length n that was drawn from the original data with replacement.</p>

<p><strong>Bootstrap replicate</strong>
 is a single value of a statistic computed from a bootstrap sample.</p>

<p>####
 Visualizing bootstrap samples</p>

<p>np.random.choice()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for _ in range(50):
    # Generate bootstrap sample: bs_sample
    bs_sample = np.random.choice(rainfall, size=len(rainfall))

    # Compute and plot ECDF from bootstrap sample
    x, y = ecdf(bs_sample)
    _ = plt.plot(x, y, marker='.', linestyle='none',
                 color='gray', alpha=0.1)

# Compute and plot ECDF from original data
x, y = ecdf(rainfall)
_ = plt.plot(x, y, marker='.')

# Make margins and label axes
plt.margins(0.02)
_ = plt.xlabel('yearly rainfall (mm)')
_ = plt.ylabel('ECDF')

# Show the plot
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture9-5.png" alt="Desktop View" /></p>

<h2 id="bootstrap-confidence-intervals-4">Bootstrap confidence intervals</h2>

<p>####
 Generating many bootstrap replicates</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def bootstrap_replicate_1d(data, func):
    return func(np.random.choice(data, size=len(data)))

def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates

</code></pre></div></div>

<p>####
 Bootstrap replicates of the mean and the SEM (
 <strong>standard error of the mean</strong>
 )</p>

<p>In fact, it can be shown theoretically that under not-too-restrictive conditions, the value of the mean will always be Normally distributed. (This does not hold in general, just for the mean and a few other statistics.)</p>

<p>The standard deviation of this distribution, called the
 <strong>standard error of the mean</strong>
 , or SEM, is given by the standard deviation of the data divided by the square root of the number of data points. I.e., for a data set,
 <code class="language-plaintext highlighter-rouge">sem = np.std(data) / np.sqrt(len(data))</code>
 . Using hacker statistics, you get this same result without the need to derive it, but you will verify this result from your bootstrap replicates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Take 10,000 bootstrap replicates of the mean: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">rainfall</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute and print SEM
</span><span class="n">sem</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">rainfall</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rainfall</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">sem</span><span class="p">)</span>

<span class="c1"># Compute and print standard deviation of bootstrap replicates
</span><span class="n">bs_std</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">std</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bs_std</span><span class="p">)</span>

<span class="c1"># Make a histogram of the results
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'mean annual rainfall (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 10.51054915050619
# 10.465927071184412
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture10-5.png" alt="Desktop View" /></p>

<p>####
 Confidence intervals of rainfall data</p>

<p>Use the bootstrap replicates you just generated to compute the 95% confidence interval. That is, give the 2.5th and 97.5th percentile of your bootstrap replicates stored as
 <code class="language-plaintext highlighter-rouge">bs_replicates</code>
 . What is the 95% confidence interval?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
np.percentile(bs_replicates,2.5)
779.7699248120301

np.percentile(bs_replicates,97.5)
820.950432330827

</code></pre></div></div>

<p>####
 Bootstrap replicates of other statistics</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_reps(data, func, size=1):
    return np.array([bootstrap_replicate_1d(data, func) for _ in range(size)])

# Generate 10,000 bootstrap replicates of the variance: bs_replicates
bs_replicates = draw_bs_reps(rainfall, np.var, size=10000)

# Put the variance in units of square centimeters
bs_replicates /= 100

# Make a histogram of the results
_ = plt.hist(bs_replicates, bins=50, normed=True)
_ = plt.xlabel('variance of annual rainfall (sq. cm)')
_ = plt.ylabel('PDF')

# Show the plot
plt.show()


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture11-5.png" alt="Desktop View" /></p>

<p>This is not normally distributed, as it has a longer tail to the right. Note that you can also compute a confidence interval on the variance, or any other statistic, using
 <code class="language-plaintext highlighter-rouge">np.percentile()</code>
 with your bootstrap replicates.</p>

<p>####
 Confidence interval on the rate of no-hitters</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Draw bootstrap replicates of the mean no-hitter time (equal to tau): bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">nohitter_times</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute the 95% confidence interval: conf_int
</span><span class="n">conf_int</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">])</span>

<span class="c1"># Print the confidence interval
</span><span class="k">print</span><span class="p">(</span><span class="s">'95% confidence interval ='</span><span class="p">,</span> <span class="n">conf_int</span><span class="p">,</span> <span class="s">'games'</span><span class="p">)</span>

<span class="c1"># Plot the histogram of the replicates
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_replicates</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s">'$\tau$ (games)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># 95% confidence interval = [660.67280876 871.63077689] games
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture12-4.png" alt="Desktop View" /></p>

<p>This gives you an estimate of what the typical time between no-hitters is. It could be anywhere between 660 and 870 games.</p>

<p>###
 Pairs bootstrap</p>

<p>####
 A function to do pairs bootstrap</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, deg=1)

    return bs_slope_reps, bs_intercept_reps


</code></pre></div></div>

<p>####
 Pairs bootstrap of literacy/fertility data</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Generate replicates of slope and intercept using pairs bootstrap
</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="n">bs_intercept_reps</span> <span class="o">=</span> <span class="n">draw_bs_pairs_linreg</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># Compute and print 95% CI for slope
</span><span class="k">print</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">97.5</span><span class="p">]))</span>

<span class="c1"># Plot the histogram
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bs_slope_reps</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'slope'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'PDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># [0.04378061 0.0551616 ]
</span>
</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture13-4.png" alt="Desktop View" /></p>

<p>####
 Plotting bootstrap regressions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Generate array of x-values for bootstrap lines: x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>

<span class="c1"># Plot the bootstrap lines
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span>
                 <span class="n">bs_slope_reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                 <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

<span class="c1"># Plot the data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">illiteracy</span><span class="p">,</span> <span class="n">fertility</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Label axes, set the margins, and show the plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'illiteracy'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'fertility'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture14-3.png" alt="Desktop View" /></p>

<h2 id="introduction-to-hypothesis-testing-4">Introduction to hypothesis testing</h2>

<p>###
 Formulating and simulating a hypothesis</p>

<dl>
  <dt><strong>Null hypothesis</strong></dt>
  <dd>another name for the hypothesis you are testing</dd>
  <dt><strong>Permutation</strong></dt>
  <dd>random reordering of entries in an array</dd>
</dl>

<p>####
 Generating a permutation sample</p>

<p>np.random.permutation()</p>

<p>Permutation sampling is a great way to simulate the hypothesis that two variables have identical probability distributions. This is often a hypothesis you want to test, so in this exercise, you will write a function to generate a permutation sample from two data sets.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def permutation_sample(data1, data2):
    """Generate a permutation sample from two data sets."""

    # Concatenate the data sets: data
    data = np.concatenate((data1, data2))

    # Permute the concatenated array: permuted_data
    permuted_data = np.random.permutation(data)

    # Split the permuted array into two: perm_sample_1, perm_sample_2
    perm_sample_1 = permuted_data[:len(data1)]
    perm_sample_2 = permuted_data[len(data1):]

    return perm_sample_1, perm_sample_2

</code></pre></div></div>

<p>####
 Visualizing permutation sampling</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
for _ in range(50):
    # Generate permutation samples
    perm_sample_1, perm_sample_2 = permutation_sample(rain_june, rain_november)


    # Compute ECDFs
    x_1, y_1 = ecdf(perm_sample_1)
    x_2, y_2 = ecdf(perm_sample_2)

    # Plot ECDFs of permutation sample
    _ = plt.plot(x_1, y_1, marker='.', linestyle='none',
                 color='red', alpha=0.02)
    _ = plt.plot(x_2, y_2, marker='.', linestyle='none',
                 color='blue', alpha=0.02)

# Create and plot ECDFs from original data
x_1, y_1 = ecdf(rain_june)
x_2, y_2 = ecdf(rain_november)
_ = plt.plot(x_1, y_1, marker='.', linestyle='none', color='red')
_ = plt.plot(x_2, y_2, marker='.', linestyle='none', color='blue')

# Label axes, set margin, and show plot
plt.margins(0.02)
_ = plt.xlabel('monthly rainfall (mm)')
_ = plt.ylabel('ECDF')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-16.png" alt="Desktop View" /></p>

<p>Notice that the permutation samples ECDFs overlap and give a purple haze. None of the ECDFs from the permutation samples overlap with the observed data, suggesting that the hypothesis is not commensurate with the data. June and November rainfall are not identically distributed.</p>

<p>###
 Test statistics and p-values</p>

<p>####
 Test statistics</p>

<p>When performing hypothesis tests, your choice of test statistic should be pertinent to the question you are seeking to answer in your hypothesis test.</p>

<p>The most important thing to consider is:
 <strong>What are you asking?</strong></p>

<p>####
 What is a p-value?</p>

<p>The p-value is generally a measure of the probability of observing a test statistic equally or more extreme than the one you observed, given that the null hypothesis is true.</p>

<p>####
 Generating permutation replicates</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># In most circumstances, func will be a function you write yourself.
</span><span class="k">def</span> <span class="nf">draw_perm_reps</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="s">"""Generate multiple permutation replicates."""</span>

    <span class="c1"># Initialize array of replicates: perm_replicates
</span>    <span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="c1"># Generate permutation sample
</span>        <span class="n">perm_sample_1</span><span class="p">,</span> <span class="n">perm_sample_2</span> <span class="o">=</span> <span class="n">permutation_sample</span><span class="p">(</span><span class="n">data_1</span><span class="p">,</span> <span class="n">data_2</span><span class="p">)</span>

        <span class="c1"># Compute the test statistic
</span>        <span class="n">perm_replicates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">perm_sample_1</span><span class="p">,</span> <span class="n">perm_sample_2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">perm_replicates</span>

</code></pre></div></div>

<p>####
 Look before you leap: EDA before hypothesis testing</p>

<p>Kleinteich and Gorb (
 <em>Sci. Rep.</em>
 ,
 <strong>4</strong>
 , 5225, 2014) performed an interesting experiment with South American horned frogs. They held a plate connected to a force transducer, along with a bait fly, in front of them. They then measured the impact force and adhesive force of the frog’s tongue when it struck the target.</p>

<p>Frog A is an adult and Frog B is a juvenile. The researchers measured the impact force of 20 strikes for each frog. In the next exercise, we will test the hypothesis that the two frogs have the same distribution of impact forces. But, remember, it is important to do EDA first! Let’s make a bee swarm plot for the data. They are stored in a Pandas data frame,
 <code class="language-plaintext highlighter-rouge">df</code>
 , where column
 <code class="language-plaintext highlighter-rouge">ID</code>
 is the identity of the frog and column
 <code class="language-plaintext highlighter-rouge">impact_force</code>
 is the impact force in Newtons (N).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   ID  impact_force
20  A         1.612
21  A         0.605
22  A         0.327
23  A         0.946
24  A         0.541

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make bee swarm plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">sns</span><span class="p">.</span><span class="n">swarmplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s">'ID'</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s">'impact_force'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'frog'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'impact force (N)'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-15.png" alt="Desktop View" /></p>

<p>Eyeballing it, it does not look like they come from the same distribution. Frog A, the adult, has three or four very hard strikes, and Frog B, the juvenile, has a couple weak ones. However, it is possible that with only 20 samples it might be too difficult to tell if they have difference distributions, so we should proceed with the hypothesis test.</p>

<p>####
 Permutation test on frog data</p>

<p>The average strike force of Frog A was 0.71 Newtons (N), and that of Frog B was 0.42 N for a difference of 0.29 N. It is possible the frogs strike with the same force and this observed difference was by chance. You will compute the probability of getting at least a 0.29 N difference in mean strike force under the hypothesis that the distributions of strike forces for the two frogs are identical. We use a permutation test with a test statistic of the difference of means to test this hypothesis.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def diff_of_means(data_1, data_2):
    """Difference in means of two arrays."""

    # The difference of means of data_1, data_2: diff
    diff = np.mean(data_1) - np.mean(data_2)

    return diff

# Compute difference of mean impact force from experiment: empirical_diff_means
empirical_diff_means = diff_of_means(force_a, force_b)

# Draw 10,000 permutation replicates: perm_replicates
perm_replicates = draw_perm_reps(force_a, force_b,
                                 diff_of_means, size=10000)

# Compute p-value: p
p = np.sum(perm_replicates &gt;= empirical_diff_means) / len(perm_replicates)

# Print the result
print('p-value =', p)

# p-value = 0.0063
# p-value = 0.63%

</code></pre></div></div>

<p>The p-value tells you that there is about a 0.6% chance that you would get the difference of means observed in the experiment if frogs were exactly the same.</p>

<p>A p-value below 0.01 is typically said to be “statistically significant,” but: warning! warning! warning! You have computed a p-value; it is a number. I encourage you not to distill it to a yes-or-no phrase. p = 0.006 and p = 0.000000006 are both said to be “statistically significant,” but they are definitely not the same!</p>

<p>###
 Bootstrap hypothesis tests</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-14.png" alt="Desktop View" /></p>

<p>####
 A one-sample bootstrap hypothesis test</p>

<p>Another juvenile frog was studied, Frog C, and you want to see if Frog B and Frog C have similar impact forces. Unfortunately, you do not have Frog C’s impact forces available, but you know they have a mean of 0.55 N. Because you don’t have the original data, you cannot do a permutation test, and you cannot assess the hypothesis that the forces from Frog B and Frog C come from the same distribution. You will therefore test another, less restrictive hypothesis: The mean strike force of Frog B is equal to that of Frog C.</p>

<p>To set up the bootstrap hypothesis test, you will take the mean as our test statistic. Remember, your goal is to calculate the probability of getting a mean impact force less than or equal to what was observed for Frog B
 <em>if the hypothesis that the true mean of Frog B’s impact forces is equal to that of Frog C is true</em>
 . You first translate all of the data of Frog B such that the mean is 0.55 N. This involves adding the mean force of Frog C and subtracting the mean force of Frog B from each measurement of Frog B. This leaves other properties of Frog B’s distribution, such as the variance, unchanged.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make an array of translated impact forces: translated_force_b
</span><span class="n">translated_force_b</span> <span class="o">=</span> <span class="n">force_b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.55</span>

<span class="c1"># Take bootstrap replicates of Frog B's translated impact forces: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">translated_force_b</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute fraction of replicates that are less than the observed Frog B force: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_replicates</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">))</span> <span class="o">/</span> <span class="mi">10000</span>

<span class="c1"># Print the p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p = '</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p =  0.0046
# p = 0.46%
</span>
</code></pre></div></div>

<p>The low p-value suggests that the null hypothesis that Frog B and Frog C have the same mean impact force is false.</p>

<p>####
 A two-sample bootstrap hypothesis test for difference of means</p>

<p>We now want to test the hypothesis that Frog A and Frog B have the same mean impact force, but not necessarily the same distribution, which is also impossible with a permutation test.</p>

<p>To do the two-sample bootstrap test, we shift
 <em>both</em>
 arrays to have the same mean, since we are simulating the hypothesis that their means are, in fact, equal. We then draw bootstrap samples out of the shifted arrays and compute the difference in means. This constitutes a bootstrap replicate, and we generate many of them. The p-value is the fraction of replicates with a difference in means greater than or equal to what was observed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute mean of all forces: mean_force
</span><span class="n">mean_force</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">forces_concat</span><span class="p">)</span>

<span class="c1"># Generate shifted arrays
</span><span class="n">force_a_shifted</span> <span class="o">=</span> <span class="n">force_a</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_force</span>
<span class="n">force_b_shifted</span> <span class="o">=</span> <span class="n">force_b</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">force_b</span><span class="p">)</span> <span class="o">+</span> <span class="n">mean_force</span>

<span class="c1"># Compute 10,000 bootstrap replicates from shifted arrays
</span><span class="n">bs_replicates_a</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">force_a_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_b</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">force_b_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Get replicates of difference of means: bs_replicates
</span><span class="n">bs_replicates</span> <span class="o">=</span> <span class="n">bs_replicates_a</span> <span class="o">-</span> <span class="n">bs_replicates_b</span>

<span class="c1"># Compute and print p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_replicates</span> <span class="o">&gt;=</span> <span class="n">empirical_diff_means</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10000</span>
<span class="k">print</span><span class="p">(</span><span class="s">'p-value ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-value = 0.0043
# p-value = 0.43%
</span>
</code></pre></div></div>

<p>You got a similar result as when you did the permutation test. Nonetheless, remember that it is important to carefully think about what question you want to ask. Are you only interested in the mean impact force, or in the distribution of impact forces?</p>

<h2 id="hypothesis-test-examples-4">Hypothesis test examples</h2>

<p>###
 A/B testing</p>

<p>####
 The vote for the Civil Rights Act in 1964</p>

<p>The Civil Rights Act of 1964 was one of the most important pieces of legislation ever passed in the USA. Excluding “present” and “abstain” votes, 153 House Democrats and 136 Republicans voted yea. However, 91 Democrats and 35 Republicans voted nay. Did party affiliation make a difference in the vote?</p>

<p>To answer this question, you will evaluate the hypothesis that the party of a House member has no bearing on his or her vote. You will use the fraction of Democrats voting in favor as your test statistic and evaluate the probability of observing a fraction of Democrats voting in favor at least as small as the observed fraction of 153/244. (That’s right, at least as
 <em>small</em>
 as. In 1964, it was the
 <em>Democrats</em>
 who were less progressive on civil rights issues.) To do this, permute the party labels of the House voters and then arbitrarily divide them into “Democrats” and “Republicans” and compute the fraction of Democrats voting yea.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Construct arrays of data: dems, reps
</span><span class="n">dems</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">153</span> <span class="o">+</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">91</span><span class="p">)</span>
<span class="n">reps</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="mi">136</span> <span class="o">+</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="mi">35</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">frac_yea_dems</span><span class="p">(</span><span class="n">dems</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
    <span class="s">"""Compute fraction of Democrat yea votes."""</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">dems</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">dems</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">frac</span>

<span class="c1"># Acquire permutation samples: perm_replicates
</span><span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">draw_perm_reps</span><span class="p">(</span><span class="n">dems</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">frac_yea_dems</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute and print p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">perm_replicates</span> <span class="o">&lt;=</span> <span class="mi">153</span><span class="o">/</span><span class="mi">244</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm_replicates</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'p-value ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-value = 0.0002
# p-value = 0.02%
</span>
</code></pre></div></div>

<p>This small p-value suggests that party identity had a lot to do with the voting. Importantly, the South had a higher fraction of Democrat representatives, and consequently also a more racist bias.</p>

<p>####
 What is equivalent?</p>

<p>You have experience matching a stories to probability distributions. Similarly, you use the same procedure for two different A/B tests if their stories match. In the Civil Rights Act example you just did, you performed an A/B test on voting data, which has a Yes/No type of outcome for each subject (in that case, a voter). Which of the following situations involving testing by a web-based company has an equivalent set up for an A/B test as the one you just did with the Civil Rights Act of 1964?</p>

<p>You measure the number of people who click on an ad on your company’s website before and after changing its color.</p>

<p>The “Democrats” are those who view the ad before the color change, and the “Republicans” are those who view it after.</p>

<p>####
 A time-on-website analog</p>

<p>It turns out that you already did a hypothesis test analogous to an A/B test where you are interested in how much time is spent on the website before and after an ad campaign. The frog tongue force (a continuous quantity like time on the website) is an analog. “Before” = Frog A and “after” = Frog B. Let’s practice this again with something that actually is a before/after scenario.</p>

<p>We return to the no-hitter data set. In 1920, Major League Baseball implemented important rule changes that ended the so-called dead ball era. Importantly, the pitcher was no longer allowed to spit on or scuff the ball, an activity that greatly favors pitchers. In this problem you will perform an A/B test to determine if these rule changes resulted in a slower rate of no-hitters (i.e., longer average time between no-hitters) using the difference in mean inter-no-hitter time as your test statistic. The inter-no-hitter times for the respective eras are stored in the arrays
 <code class="language-plaintext highlighter-rouge">nht_dead</code>
 and
 <code class="language-plaintext highlighter-rouge">nht_live</code>
 , where “nht” is meant to stand for “no-hitter time.”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def diff_of_means(data_1, data_2):
    """Difference in means of two arrays."""

    # The difference of means of data_1, data_2: diff
    diff = np.mean(data_1) - np.mean(data_2)

    return diff

def permutation_sample(data1, data2):
    """Generate a permutation sample from two data sets."""

    # Concatenate the data sets: data
    data = np.concatenate((data1, data2))

    # Permute the concatenated array: permuted_data
    permuted_data = np.random.permutation(data)

    # Split the permuted array into two: perm_sample_1, perm_sample_2
    perm_sample_1 = permuted_data[:len(data1)]
    perm_sample_2 = permuted_data[len(data1):]

    return perm_sample_1, perm_sample_2

def draw_perm_reps(data_1, data_2, func, size=1):
    """Generate multiple permutation replicates."""

    # Initialize array of replicates: perm_replicates
    perm_replicates = np.empty(size)

    for i in range(size):
        # Generate permutation sample
        perm_sample_1, perm_sample_2 = permutation_sample(data_1, data_2)

        # Compute the test statistic
        perm_replicates[i] = func(perm_sample_1, perm_sample_2)

    return perm_replicates



# Compute the observed difference in mean inter-no-hitter times: nht_diff_obs
nht_diff_obs = diff_of_means(nht_dead, nht_live)

# Acquire 10,000 permutation replicates of difference in mean no-hitter time: perm_replicates
perm_replicates = draw_perm_reps(nht_dead, nht_live, diff_of_means, size=10000)

# Compute and print the p-value: p
p = np.sum(perm_replicates &lt;= nht_diff_obs) /len(perm_replicates)
print('p-val =', p)

p-val = 0.0001

</code></pre></div></div>

<p>Your p-value is 0.0001, which means that only one out of your 10,000 replicates had a result as extreme as the actual difference between the dead ball and live ball eras. This suggests strong statistical significance. Watch out, though, you could very well have gotten zero replicates that were as extreme as the observed value. This just means that the p-value is quite small, almost certainly smaller than 0.001.</p>

<p>####
 What should you have done first?</p>

<p>That was a nice hypothesis test you just did to check out whether the rule changes in 1920 changed the rate of no-hitters. But what
 <em>should</em>
 you have done with the data first?</p>

<p>Performed EDA, perhaps plotting the ECDFs of inter-no-hitter times in the dead ball and live ball eras.</p>

<p>Always a good idea to do first! I encourage you to go ahead and plot the ECDFs right now. You will see by eye that the null hypothesis that the distributions are the same is almost certainly not true.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create and plot ECDFs
</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nht_dead</span><span class="p">)</span>
<span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">nht_live</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span> <span class="n">y_1</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2</span><span class="p">,</span> <span class="n">y_2</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>

<span class="c1"># Label axes, set margin, and show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'Games between no-hitters'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture1-17.png" alt="Desktop View" /></p>

<p>###
 Test of correlation</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture2-16.png" alt="Desktop View" /></p>

<p>####
 Simulating a null hypothesis concerning correlation</p>

<p>The observed correlation between female illiteracy and fertility in the data set of 162 countries may just be by chance; the fertility of a given country may actually be totally independent of its illiteracy. You will test this null hypothesis in the next exercise.</p>

<p>To do the test, you need to simulate the data assuming the null hypothesis is true. Of the following choices, which is the best way to to do it?</p>

<p>Answer: Do a permutation test: Permute the illiteracy values but leave the fertility values fixed to generate a new set of (illiteracy, fertility) data.</p>

<p>This exactly simulates the null hypothesis and does so more efficiently than the last option. It is exact because it uses all data and eliminates any correlation because which illiteracy value pairs to which fertility value is shuffled.</p>

<p>Last option: Do a permutation test: Permute both the illiteracy and fertility values to generate a new set of (illiteracy, fertility data). This exactly simulates the null hypothesis and does so more efficiently than the last option. It is exact because it uses all data and eliminates any correlation because which illiteracy value pairs to which fertility value is shuffled.</p>

<p>####
 Hypothesis test on Pearson correlation</p>

<p>The observed correlation between female illiteracy and fertility may just be by chance; the fertility of a given country may actually be totally independent of its illiteracy. You will test this hypothesis. To do so, permute the illiteracy values but leave the fertility values fixed. This simulates the hypothesis that they are totally independent of each other. For each permutation, compute the Pearson correlation coefficient and assess how many of your permutation replicates have a Pearson correlation coefficient greater than the observed one.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def pearson_r(x, y):
    """Compute Pearson correlation coefficient between two arrays."""
    # Compute correlation matrix: corr_mat
    corr_mat = np.corrcoef(x, y)

    # Return entry [0,1]
    return corr_mat[0,1]

# Compute observed correlation: r_obs
r_obs = pearson_r(illiteracy, fertility)

# r_obs = 0.8041324026815344

# Initialize permutation replicates: perm_replicates
perm_replicates = np.empty(10000)

# Draw replicates
for i in range(10000):
    # Permute illiteracy measurments: illiteracy_permuted
    illiteracy_permuted = np.random.permutation(illiteracy)

    # Compute Pearson correlation
    perm_replicates[i] = pearson_r(illiteracy_permuted, fertility)

# Compute p-value: p
p = np.sum(perm_replicates &gt;= r_obs) /len(perm_replicates)
print('p-val =', p)

# p-val = 0.0

</code></pre></div></div>

<p>You got a p-value of zero. In hacker statistics, this means that your p-value is very low, since you never got a single replicate in the 10,000 you took that had a Pearson correlation greater than the observed one. You could try increasing the number of replicates you take to continue to move the upper bound on your p-value lower and lower.</p>

<p>####
 Do neonicotinoid insecticides have unintended consequences?</p>

<p>As a final exercise in hypothesis testing before we put everything together in our case study in the next chapter, you will investigate the effects of neonicotinoid insecticides on bee reproduction. These insecticides are very widely used in the United States to combat aphids and other pests that damage plants.</p>

<p>In a recent study, Straub, et al. (
 <a href="http://dx.doi.org/10.1098/rspb.2016.0506"><em>Proc. Roy. Soc. B</em>
 , 2016</a>
 ) investigated the effects of neonicotinoids on the sperm of pollinating bees. In this and the next exercise, you will study how the pesticide treatment affected the count of live sperm per half milliliter of semen.</p>

<p>First, we will do EDA, as usual. Plot ECDFs of the alive sperm count for untreated bees (stored in the Numpy array
 <code class="language-plaintext highlighter-rouge">control</code>
 ) and bees treated with pesticide (stored in the Numpy array
 <code class="language-plaintext highlighter-rouge">treated</code>
 ).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute x,y values for ECDFs
</span><span class="n">x_control</span><span class="p">,</span> <span class="n">y_control</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">control</span><span class="p">)</span>
<span class="n">x_treated</span><span class="p">,</span> <span class="n">y_treated</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">treated</span><span class="p">)</span>

<span class="c1"># Plot the ECDFs
</span><span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_control</span><span class="p">,</span> <span class="n">y_control</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_treated</span><span class="p">,</span> <span class="n">y_treated</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set the margins
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>

<span class="c1"># Add a legend
</span><span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'control'</span><span class="p">,</span> <span class="s">'treated'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Label axes and show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'millions of alive sperm per mL'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture3-15.png" alt="Desktop View" /></p>

<p>The ECDFs show a pretty clear difference between the treatment and control; treated bees have fewer alive sperm. Let’s now do a hypothesis test in the next exercise.</p>

<p>####
 Bootstrap hypothesis test on bee sperm counts</p>

<p>Now, you will test the following hypothesis:</p>

<p><strong>On average, male bees treated with neonicotinoid insecticide have the same number of active sperm per milliliter of semen than do untreated male bees.</strong></p>

<p>You will use the difference of means as your test statistic.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def bootstrap_replicate_1d(data, func):
    return func(np.random.choice(data, size=len(data)))

def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates


# Compute the difference in mean sperm count: diff_means
diff_means = np.mean(control) - np.mean(treated)

# Compute mean of pooled data: mean_count
mean_count = np.mean(np.concatenate((control, treated)))

# Generate shifted data sets
control_shifted = control - np.mean(control) + mean_count
treated_shifted = treated - np.mean(treated) + mean_count

# Generate bootstrap replicates
bs_reps_control = draw_bs_reps(control_shifted,
                       np.mean, size=10000)
bs_reps_treated = draw_bs_reps(treated_shifted,
                       np.mean, size=10000)

# Get replicates of difference of means: bs_replicates
bs_replicates = bs_reps_control - bs_reps_treated

# Compute and print p-value: p
p = np.sum(bs_replicates &gt;= np.mean(control) - np.mean(treated)) \
            / len(bs_replicates)
print('p-value =', p)

# p-value = 0.0

</code></pre></div></div>

<p>The p-value is small, most likely less than 0.0001, since you never saw a bootstrap replicated with a difference of means at least as extreme as what was observed. In fact, when I did the calculation with 10 million replicates, I got a p-value of
 <code class="language-plaintext highlighter-rouge">2e-05</code></p>

<h2 id="putting-it-all-together-a-case-study-4">Putting it all together: a case study</h2>

<p>###
 Finch beaks and the need for statistics</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture4-14.png" alt="Desktop View" /></p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture5-12.png" alt="Desktop View" /></p>

<p>####
 EDA of beak depths of Darwin’s finches</p>

<p>For your first foray into the Darwin finch data, you will study how the beak depth (the distance, top to bottom, of a closed beak) of the finch species
 <em>Geospiza scandens</em>
 has changed over time. The Grants have noticed some changes of beak geometry depending on the types of seeds available on the island, and they also noticed that there was some interbreeding with another major species on Daphne Major,
 <em>Geospiza fortis</em>
 . These effects can lead to changes in the species over time.</p>

<p>In the next few problems, you will look at the beak depth of
 <em>G. scandens</em>
 on Daphne Major in 1975 and in 2012. To start with, let’s plot all of the beak depth measurements in 1975 and 2012 in a bee swarm plot.</p>

<p>The data are stored in a pandas DataFrame called
 <code class="language-plaintext highlighter-rouge">df</code>
 with columns
 <code class="language-plaintext highlighter-rouge">'year'</code>
 and
 <code class="language-plaintext highlighter-rouge">'beak_depth'</code>
 . The units of beak depth are millimeters (mm).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
df.head()
   beak_depth  year
0         8.4  1975
1         8.8  1975
2         8.4  1975
3         8.0  1975
4         7.9  1975

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Create bee swarm plot
</span><span class="n">_</span> <span class="o">=</span> <span class="n">sns</span><span class="p">.</span><span class="n">swarmplot</span><span class="p">(</span><span class="s">'year'</span><span class="p">,</span> <span class="s">'beak_depth'</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df</span><span class="p">)</span>

<span class="c1"># Label the axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'year'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture6-9.png" alt="Desktop View" /></p>

<p>It is kind of hard to see if there is a clear difference between the 1975 and 2012 data set. Eyeballing it, it appears as though the mean of the 2012 data set might be slightly higher, and it might have a bigger variance.</p>

<p>####
 ECDFs of beak depths</p>

<p>While bee swarm plots are useful, we found that ECDFs are often even better when doing EDA. Plot the ECDFs for the 1975 and 2012 beak depth measurements on the same plot.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute ECDFs
</span><span class="n">x_1975</span><span class="p">,</span> <span class="n">y_1975</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">bd_1975</span><span class="p">)</span>
<span class="n">x_2012</span><span class="p">,</span> <span class="n">y_2012</span> <span class="o">=</span> <span class="n">ecdf</span><span class="p">(</span><span class="n">bd_2012</span><span class="p">)</span>

<span class="c1"># Plot the ECDFs
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_1975</span><span class="p">,</span> <span class="n">y_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_2012</span><span class="p">,</span> <span class="n">y_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">)</span>

<span class="c1"># Set margins
</span><span class="n">plt</span><span class="p">.</span><span class="n">margins</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>

<span class="c1"># Add axis labels and legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'ECDF'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture7-10.png" alt="Desktop View" /></p>

<p>The differences are much clearer in the ECDF. The mean is larger in the 2012 data, and the variance does appear larger as well.</p>

<p>####
 Parameter estimates of beak depths</p>

<p>Estimate the
 <em>difference</em>
 of the mean beak depth of the
 <em>G. scandens</em>
 samples from 1975 and 2012 and report a 95% confidence interval.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_reps(data, func, size=1):
    """Draw bootstrap replicates."""

    # Initialize array of replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_replicates[i] = bootstrap_replicate_1d(data, func)

    return bs_replicates


# Compute the difference of the sample means: mean_diff
mean_diff = np.mean(bd_2012) - np.mean(bd_1975)

# Get bootstrap replicates of means
bs_replicates_1975 = draw_bs_reps(bd_1975, np.mean, size=10000)
bs_replicates_2012 = draw_bs_reps(bd_2012, np.mean, size=10000)

# Compute samples of difference of means: bs_diff_replicates
bs_diff_replicates = bs_replicates_2012 - bs_replicates_1975

# Compute 95% confidence interval: conf_int
conf_int = np.percentile(bs_diff_replicates, [2.5, 97.5])

# Print the results
print('difference of means =', mean_diff, 'mm')
print('95% confidence interval =', conf_int, 'mm')

# difference of means = 0.22622047244094645 mm
# 95% confidence interval = [0.05633521 0.39190544] mm

</code></pre></div></div>

<p>####
 Hypothesis test: Are beaks deeper in 2012?</p>

<p>Your plot of the ECDF and determination of the confidence interval make it pretty clear that the beaks of
 <em>G. scandens</em>
 on Daphne Major have gotten deeper. But is it possible that this effect is just due to random chance? In other words, what is the probability that we would get the observed difference in mean beak depth if the means were the same?</p>

<p>Be careful! The hypothesis we are testing is
 <em>not</em>
 that the beak depths come from the same distribution. For that we could use a permutation test.
 <strong>The hypothesis is that the means are equal.</strong>
 To perform this hypothesis test, we need to shift the two data sets so that they have the same mean and then use bootstrap sampling to compute the difference of means.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute mean of combined data set: combined_mean
</span><span class="n">combined_mean</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">bd_1975</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">)))</span>

<span class="c1"># Shift the samples
# why shift the mean?
# to make np.mean(bd_1975_shifted) - np.mean(bd_2012_shifted) = 0 #1
# why make #1 = 0?
# because our hypothesis is "beak depth are the same in 1975 and 2012"
</span><span class="n">bd_1975_shifted</span> <span class="o">=</span> <span class="n">bd_1975</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bd_1975</span><span class="p">)</span> <span class="o">+</span> <span class="n">combined_mean</span>
<span class="n">bd_2012_shifted</span> <span class="o">=</span> <span class="n">bd_2012</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">bd_2012</span><span class="p">)</span> <span class="o">+</span> <span class="n">combined_mean</span>

<span class="c1"># Get bootstrap replicates of shifted data sets
</span><span class="n">bs_replicates_1975</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">bd_1975_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_2012</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">bd_2012_shifted</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute replicates of difference of means: bs_diff_replicates
</span><span class="n">bs_diff_replicates</span> <span class="o">=</span> <span class="n">bs_replicates_2012</span> <span class="o">-</span> <span class="n">bs_replicates_1975</span>

<span class="c1"># Compute the p-value
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">bs_diff_replicates</span> <span class="o">&gt;=</span> <span class="n">mean_diff</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">bs_diff_replicates</span><span class="p">)</span>

<span class="c1"># Print p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p = 0.0034
# p = 0.34%
</span>
</code></pre></div></div>

<p>We get a p-value of 0.0034, which suggests that there is a statistically significant difference. But remember: it is very important to know how different they are! In the previous exercise, you got a difference of 0.2 mm between the means. You should combine this with the statistical significance. Changing by 0.2 mm in 37 years is substantial by evolutionary standards. If it kept changing at that rate, the beak depth would double in only 400 years.</p>

<p>###
 Variation of beak shapes</p>

<p>####
 EDA of beak length and depth</p>

<p>The beak length data are stored as
 <code class="language-plaintext highlighter-rouge">bl_1975</code>
 and
 <code class="language-plaintext highlighter-rouge">bl_2012</code>
 , again with units of millimeters (mm). You still have the beak depth data stored in
 <code class="language-plaintext highlighter-rouge">bd_1975</code>
 and
 <code class="language-plaintext highlighter-rouge">bd_2012</code>
 . Make scatter plots of beak depth (y-axis) versus beak length (x-axis) for the 1975 and 2012 specimens.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plot of 1975 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_1975</span><span class="p">,</span> <span class="n">bd_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'None'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Make scatter plot of 2012 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_2012</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s">'None'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes and make legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak length (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>

<span class="c1"># Show the plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture8-7.png" alt="Desktop View" /></p>

<p>In looking at the plot, we see that beaks got deeper (the red points are higher up in the y-direction), but not really longer. If anything, they got a bit shorter, since the red dots are to the left of the blue dots. So, it does not look like the beaks kept the same shape; they became shorter and deeper.</p>

<p>####
 Linear regressions</p>

<p>Perform a linear regression for both the 1975 and 2012 data. Then, perform pairs bootstrap estimates for the regression parameters. Report 95% confidence intervals on the slope and intercept of the regression line.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs_linreg(x, y, size=1):
    """Perform pairs bootstrap for linear regression."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_slope_reps, bs_intercept_reps
    bs_slope_reps = np.empty(size)
    bs_intercept_reps = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_slope_reps[i], bs_intercept_reps[i] = np.polyfit(bs_x, bs_y, deg=1)

    return bs_slope_reps, bs_intercept_reps


# Compute the linear regressions
slope_1975, intercept_1975 = np.polyfit(bl_1975, bd_1975, deg=1)
slope_2012, intercept_2012 = np.polyfit(bl_2012, bd_2012, deg=1)

# Perform pairs bootstrap for the linear regressions
bs_slope_reps_1975, bs_intercept_reps_1975 = draw_bs_pairs_linreg(bl_1975, bd_1975, size=1000)
bs_slope_reps_2012, bs_intercept_reps_2012 = draw_bs_pairs_linreg(bl_2012, bd_2012, size=1000)

# Compute confidence intervals of slopes
slope_conf_int_1975 = np.percentile(bs_slope_reps_1975, [2.5, 97.5])
slope_conf_int_2012 = np.percentile(bs_slope_reps_2012, [2.5, 97.5])
intercept_conf_int_1975 = np.percentile(bs_intercept_reps_1975, [2.5, 97.5])
intercept_conf_int_2012 = np.percentile(bs_intercept_reps_2012, [2.5, 97.5])


# Print the results
print('1975: slope =', slope_1975,
      'conf int =', slope_conf_int_1975)
print('1975: intercept =', intercept_1975,
      'conf int =', intercept_conf_int_1975)
print('2012: slope =', slope_2012,
      'conf int =', slope_conf_int_2012)
print('2012: intercept =', intercept_2012,
      'conf int =', intercept_conf_int_2012)

#   1975: slope = 0.4652051691605937 conf int = [0.33851226 0.59306491]
#   1975: intercept = 2.3908752365842263 conf int = [0.64892945 4.18037063]
#   2012: slope = 0.462630358835313 conf int = [0.33137479 0.60695527]
#   2012: intercept = 2.977247498236019 conf int = [1.06792753 4.70599387]

</code></pre></div></div>

<p>It looks like they have the same slope, but different intercepts.</p>

<p>####
 Displaying the linear regression results</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plot of 1975 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_1975</span><span class="p">,</span> <span class="n">bd_1975</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Make scatter plot of 2012 data
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bl_2012</span><span class="p">,</span> <span class="n">bd_2012</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span>
             <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes and make legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'beak length (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'1975'</span><span class="p">,</span> <span class="s">'2012'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">)</span>

<span class="c1"># Generate x-values for bootstrap lines: x
</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">17</span><span class="p">])</span>

<span class="c1"># Plot the bootstrap lines
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bs_slope_reps_1975</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps_1975</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bs_slope_reps_2012</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">bs_intercept_reps_2012</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
             <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

<span class="c1"># Draw the plot again
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture9-6.png" alt="Desktop View" /></p>

<p>####
 Beak length to depth ratio</p>

<p>The linear regressions showed interesting information about the beak geometry. The slope was the same in 1975 and 2012, suggesting that for every millimeter gained in beak length, the birds gained about half a millimeter in depth in both years. However, if we are interested in the shape of the beak, we want to compare the
 <em>ratio</em>
 of beak length to beak depth. Let’s make that comparison.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Compute length-to-depth ratios
</span><span class="n">ratio_1975</span> <span class="o">=</span> <span class="n">bl_1975</span> <span class="o">/</span> <span class="n">bd_1975</span>
<span class="n">ratio_2012</span> <span class="o">=</span> <span class="n">bl_2012</span> <span class="o">/</span> <span class="n">bd_2012</span>

<span class="c1"># Compute means
</span><span class="n">mean_ratio_1975</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratio_1975</span><span class="p">)</span>
<span class="n">mean_ratio_2012</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ratio_2012</span><span class="p">)</span>

<span class="c1"># Generate bootstrap replicates of the means
</span><span class="n">bs_replicates_1975</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">ratio_1975</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">bs_replicates_2012</span> <span class="o">=</span> <span class="n">draw_bs_reps</span><span class="p">(</span><span class="n">ratio_2012</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Compute the 99% confidence intervals
</span><span class="n">conf_int_1975</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates_1975</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">])</span>
<span class="n">conf_int_2012</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">bs_replicates_2012</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">99.5</span><span class="p">])</span>

<span class="c1"># Print the results
</span><span class="k">print</span><span class="p">(</span><span class="s">'1975: mean ratio ='</span><span class="p">,</span> <span class="n">mean_ratio_1975</span><span class="p">,</span>
      <span class="s">'conf int ='</span><span class="p">,</span> <span class="n">conf_int_1975</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'2012: mean ratio ='</span><span class="p">,</span> <span class="n">mean_ratio_2012</span><span class="p">,</span>
      <span class="s">'conf int ='</span><span class="p">,</span> <span class="n">conf_int_2012</span><span class="p">)</span>

<span class="c1"># 1975: mean ratio = 1.5788823771858533 conf int = [1.55668803 1.60073509]
# 2012: mean ratio = 1.4658342276847767 conf int = [1.44363932 1.48729149]
</span>
</code></pre></div></div>

<p>####
 How different is the ratio?</p>

<p>In the previous exercise, you computed the mean beak length to depth ratio with 99% confidence intervals for 1975 and for 2012. The results of that calculation are shown graphically in the plot accompanying this problem. In addition to these results, what would you say about the ratio of beak length to depth?</p>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture10-6.png" alt="Desktop View" /></p>

<p>The mean beak length-to-depth ratio decreased by about 0.1, or 7%, from 1975 to 2012. The 99% confidence intervals are not even close to overlapping, so this is a real change. The beak shape changed.</p>

<p>###
 Calculation of heritability</p>

<p>####
 EDA of heritability</p>

<p>The array
 <code class="language-plaintext highlighter-rouge">bd_parent_scandens</code>
 contains the average beak depth (in mm) of two parents of the species
 <code class="language-plaintext highlighter-rouge">G. scandens</code>
 . The array
 <code class="language-plaintext highlighter-rouge">bd_offspring_scandens</code>
 contains the average beak depth of the offspring of the respective parents. The arrays
 <code class="language-plaintext highlighter-rouge">bd_parent_fortis</code>
 and
 <code class="language-plaintext highlighter-rouge">bd_offspring_fortis</code>
 contain the same information about measurements from
 <em>G. fortis</em>
 birds.</p>

<p>Make a scatter plot of the average offspring beak depth (y-axis) versus average parental beak depth (x-axis) for both species. Use the
 <code class="language-plaintext highlighter-rouge">alpha=0.5</code>
 keyword argument to help you see overlapping points.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Make scatter plots
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bd_parent_fortis</span><span class="p">,</span> <span class="n">bd_offspring_fortis</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'blue'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">bd_parent_scandens</span><span class="p">,</span> <span class="n">bd_offspring_scandens</span><span class="p">,</span>
             <span class="n">marker</span><span class="o">=</span><span class="s">'.'</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s">'none'</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s">'red'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># Label axes
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'parental beak depth (mm)'</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'offspring beak depth (mm)'</span><span class="p">)</span>

<span class="c1"># Add legend
</span><span class="n">_</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">((</span><span class="s">'G. fortis'</span><span class="p">,</span> <span class="s">'G. scandens'</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s">'lower right'</span><span class="p">)</span>

<span class="c1"># Show plot
</span><span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>


</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture11-6.png" alt="Desktop View" /></p>

<p>It appears as though there is a stronger correlation in
 <em>G. fortis</em>
 than than in
 <em>G. scandens</em>
 . This suggests that beak depth is more strongly inherited in
 <em>G. fortis</em>
 . We’ll quantify this correlation next.</p>

<p>####
 Correlation of offspring and parental data</p>

<p>In an effort to quantify the correlation between offspring and parent beak depths, we would like to compute statistics, such as the Pearson correlation coefficient, between parents and offspring. To get confidence intervals on this, we need to do a pairs bootstrap.</p>

<p>You have
 <a href="https://campus.datacamp.com/courses/statistical-thinking-in-python-part-2/bootstrap-confidence-intervals?ex=12">already written</a>
 a function to do pairs bootstrap to get estimates for parameters derived from linear regression. Your task in this exercise is to make a new function with call signature
 <code class="language-plaintext highlighter-rouge">draw_bs_pairs(x, y, func, size=1)</code>
 that performs pairs bootstrap and computes a single statistic on pairs samples defined. The statistic of interest is computed by calling
 <code class="language-plaintext highlighter-rouge">func(bs_x, bs_y)</code>
 . In the next exercise, you will use
 <code class="language-plaintext highlighter-rouge">pearson_r</code>
 for
 <code class="language-plaintext highlighter-rouge">func</code>
 .</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def draw_bs_pairs(x, y, func, size=1):
    """Perform pairs bootstrap for a single statistic."""

    # Set up array of indices to sample from: inds
    inds = np.arange(len(x))

    # Initialize replicates: bs_replicates
    bs_replicates = np.empty(size)

    # Generate replicates
    for i in range(size):
        bs_inds = np.random.choice(inds, size=len(inds))
        bs_x, bs_y = x[bs_inds], y[bs_inds]
        bs_replicates[i] = func(bs_x, bs_y)

    return bs_replicates


</code></pre></div></div>

<p>####
 Pearson correlation of offspring and parental data</p>

<p>The Pearson correlation coefficient seems like a useful measure of how strongly the beak depth of parents are inherited by their offspring. Compute the Pearson correlation coefficient between parental and offspring beak depths for
 <em>G. scandens</em>
 . Do the same for
 <em>G. fortis</em>
 . Then, use the function you wrote in the last exercise to compute a 95% confidence interval using pairs bootstrap.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def pearson_r(x, y):
    """Compute Pearson correlation coefficient between two arrays."""
    # Compute correlation matrix: corr_mat
    corr_mat = np.corrcoef(x, y)

    # Return entry [0,1]
    return corr_mat[0,1]


# Compute the Pearson correlation coefficients
r_scandens = pearson_r(bd_parent_scandens, bd_offspring_scandens)
r_fortis = pearson_r(bd_parent_fortis, bd_offspring_fortis)

# Acquire 1000 bootstrap replicates of Pearson r
bs_replicates_scandens = draw_bs_pairs(bd_parent_scandens, bd_offspring_scandens, pearson_r, size=1000)

bs_replicates_fortis = draw_bs_pairs(bd_parent_fortis, bd_offspring_fortis, pearson_r, size=1000)


# Compute 95% confidence intervals
conf_int_scandens = np.percentile(bs_replicates_scandens, [2.5, 97.5])
conf_int_fortis = np.percentile(bs_replicates_fortis, [2.5, 97.5])

# Print results
print('G. scandens:', r_scandens, conf_int_scandens)
print('G. fortis:', r_fortis, conf_int_fortis)

#    G. scandens: 0.4117063629401258 [0.26564228 0.54388972]
#    G. fortis: 0.7283412395518487 [0.6694112  0.77840616]

</code></pre></div></div>

<p>It is clear from the confidence intervals that beak depth of the offspring of
 <em>G. fortis</em>
 parents is more strongly correlated with their offspring than their
 <em>G. scandens</em>
 counterparts.</p>

<p>####
 Measuring heritability</p>

<p>Remember that the Pearson correlation coefficient is the ratio of the covariance to the geometric mean of the variances of the two data sets. This is a measure of the correlation between parents and offspring, but might not be the best estimate of heritability. If we stop and think, it makes more sense to define heritability as the ratio of the covariance between parent and offspring to the
 <em>variance of the parents alone</em>
 . In this exercise, you will estimate the heritability and perform a pairs bootstrap calculation to get the 95% confidence interval.</p>

<p>This exercise highlights a very important point. Statistical inference (and data analysis in general) is not a plug-n-chug enterprise. You need to think carefully about the questions you are seeking to answer with your data and analyze them appropriately. If you are interested in how heritable traits are, the quantity we defined as the heritability is more apt than the off-the-shelf statistic, the Pearson correlation coefficient.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
def heritability(parents, offspring):
    """Compute the heritability from parent and offspring samples."""
    covariance_matrix = np.cov(parents, offspring)
    return covariance_matrix[0,1] / covariance_matrix[0,0]

# Compute the heritability
heritability_scandens = heritability(bd_parent_scandens, bd_offspring_scandens)
heritability_fortis = heritability(bd_parent_fortis, bd_offspring_fortis)

# Acquire 1000 bootstrap replicates of heritability
replicates_scandens = draw_bs_pairs(
        bd_parent_scandens, bd_offspring_scandens, heritability, size=1000)

replicates_fortis = draw_bs_pairs(
        bd_parent_fortis, bd_offspring_fortis, heritability, size=1000)


# Compute 95% confidence intervals
conf_int_scandens = np.percentile(replicates_scandens, [2.5, 97.5])
conf_int_fortis = np.percentile(replicates_fortis, [2.5, 97.5])

# Print results
print('G. scandens:', heritability_scandens, conf_int_scandens)
print('G. fortis:', heritability_fortis, conf_int_fortis)


#   G. scandens: 0.5485340868685982 [0.34395487 0.75638267]
#   G. fortis: 0.7229051911438159 [0.64655013 0.79688342]

</code></pre></div></div>

<p>Here again, we see that
 <em>G. fortis</em>
 has stronger heritability than
 <em>G. scandens</em>
 . This suggests that the traits of
 <em>G. fortis</em>
 may be strongly incorporated into
 <em>G. scandens</em>
 by introgressive hybridization.</p>

<p>####
 Is beak depth heritable at all in G. scandens?</p>

<p>The heritability of beak depth in
 <em>G. scandens</em>
 seems low. It could be that this observed heritability was just achieved by chance and
 <strong>beak depth is actually not really heritable in the species</strong>
 . You will test that hypothesis here. To do this, you will do a pairs permutation test.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># Initialize array of replicates: perm_replicates
</span><span class="n">perm_replicates</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Draw replicates
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">):</span>
    <span class="c1"># Permute parent beak depths
</span>    <span class="n">bd_parent_permuted</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">bd_parent_scandens</span><span class="p">)</span>
    <span class="n">perm_replicates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">heritability</span><span class="p">(</span><span class="n">bd_parent_permuted</span><span class="p">,</span>
                                      <span class="n">bd_offspring_scandens</span><span class="p">)</span>

<span class="c1"># Compute p-value: p
</span><span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">perm_replicates</span> <span class="o">&gt;=</span> <span class="n">heritability_scandens</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">perm_replicates</span><span class="p">)</span>

<span class="c1"># Print the p-value
</span><span class="k">print</span><span class="p">(</span><span class="s">'p-val ='</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

<span class="c1"># p-val = 0.0
</span>
</code></pre></div></div>

<p>You get a p-value of zero, which means that none of the 10,000 permutation pairs replicates you drew had a heritability high enough to match that which was observed. This strongly suggests that beak depth is heritable in
 <em>G. scandens</em>
 , just not as much as in
 <em>G. fortis</em>
 . If you like, you can plot a histogram of the heritability replicates to get a feel for how extreme of a value of heritability you might expect by chance.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
plt.hist(perm_replicates)
plt.axvline(x=heritability_scandens, color = 'red')
plt.text(heritability_scandens, 1500, 'heritability_scandens', ha='center', va='center',rotation='vertical', backgroundcolor='white')
plt.show()

</code></pre></div></div>

<p><img src="/blog/assets/datacamp/statistical-thinking-in-python-(part-2)/capture12-5.png" alt="Desktop View" /></p>

